<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-03-10T19:55:23+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">공부 기록 블로그</title><author><name>nobbaggu</name></author><entry><title type="html">(클린코드) Chapter03 - 함수</title><link href="http://localhost:4000/2020/03/09/%ED%95%A8%EC%88%98/" rel="alternate" type="text/html" title="(클린코드) Chapter03 - 함수" /><published>2020-03-09T16:37:19+09:00</published><updated>2020-03-09T16:37:19+09:00</updated><id>http://localhost:4000/2020/03/09/%ED%95%A8%EC%88%98</id><content type="html" xml:base="http://localhost:4000/2020/03/09/%ED%95%A8%EC%88%98/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;들어가면서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;작게 만들어라!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;한 가지만 해라!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;함수 당 추상화 수준은 하나로!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;Switch 문&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6&quot;&gt;서술적인 이름을 사용하라!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#7&quot;&gt;함수 인수&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#8&quot;&gt;부수 효과를 일으키지 마라!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#9&quot;&gt;명령과 조회를 분리하라!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#10&quot;&gt;오류 코드보다 예외를 사용하라!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#11&quot;&gt;반복하지 마라!&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#12&quot;&gt;구조적 프로그래밍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#13&quot;&gt;함수를 어떻게 짜죠?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#14&quot;&gt;결론&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;들어가면서&quot;&gt;들어가면서&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;작게-만들어라&quot;&gt;작게 만들어라!&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;한-가지만-해라&quot;&gt;한 가지만 해라!&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;함수-당-추상화-수준은-하나로&quot;&gt;함수 당 추상화 수준은 하나로!&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;switch-문&quot;&gt;Switch 문&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;서술적인-이름을-사용하라&quot;&gt;서술적인 이름을 사용하라!&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;함수-인수&quot;&gt;함수 인수&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;8&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;부수-효과를-일으키지-마라&quot;&gt;부수 효과를 일으키지 마라!&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;명령과-조회를-분리하라&quot;&gt;명령과 조회를 분리하라!&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;10&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;오류-코드보다-예외를-사용하라&quot;&gt;오류 코드보다 예외를 사용하라!&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;11&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;반복하지-마라&quot;&gt;반복하지 마라!&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;12&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;구조적-프로그래밍&quot;&gt;구조적 프로그래밍&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;13&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;함수를-어떻게-짜죠&quot;&gt;함수를 어떻게 짜죠?&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;14&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;</content><author><name>nobbaggu</name></author><category term="클린코드" /><category term="함수" /><summary type="html">목차 들어가면서 작게 만들어라! 한 가지만 해라! 함수 당 추상화 수준은 하나로! Switch 문 서술적인 이름을 사용하라! 함수 인수 부수 효과를 일으키지 마라! 명령과 조회를 분리하라! 오류 코드보다 예외를 사용하라! 반복하지 마라! 구조적 프로그래밍 함수를 어떻게 짜죠? 결론 들어가면서 작게 만들어라! 한 가지만 해라! 함수 당 추상화 수준은 하나로! Switch 문 서술적인 이름을 사용하라! 함수 인수 부수 효과를 일으키지 마라! 명령과 조회를 분리하라! 오류 코드보다 예외를 사용하라! 반복하지 마라! 구조적 프로그래밍 함수를 어떻게 짜죠? 결론</summary></entry><entry><title type="html">(클린코드) Chapter02 - 의미 있는 이름</title><link href="http://localhost:4000/2020/03/08/%EC%9D%98%EB%AF%B8-%EC%9E%88%EB%8A%94-%EC%9D%B4%EB%A6%84/" rel="alternate" type="text/html" title="(클린코드) Chapter02 - 의미 있는 이름" /><published>2020-03-08T13:37:19+09:00</published><updated>2020-03-08T13:37:19+09:00</updated><id>http://localhost:4000/2020/03/08/%EC%9D%98%EB%AF%B8%20%EC%9E%88%EB%8A%94%20%EC%9D%B4%EB%A6%84</id><content type="html" xml:base="http://localhost:4000/2020/03/08/%EC%9D%98%EB%AF%B8-%EC%9E%88%EB%8A%94-%EC%9D%B4%EB%A6%84/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;들어가면서&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;의도를 분명히 밝혀라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;그릇된 정보를 피하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;의미 있게 구분하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;발음하기 쉬운 이름을 사용하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#6&quot;&gt;검색하기 쉬운 이름을 사용하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#7&quot;&gt;인코딩을 피하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#8&quot;&gt;자신의 기억력을 자랑하지마라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#9&quot;&gt;클래스 이름&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#10&quot;&gt;메소드 이름&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#11&quot;&gt;기발한 이름은 피하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#12&quot;&gt;한 개념에 한 단어를 사용하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#13&quot;&gt;말장난을 하지마라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#14&quot;&gt;해법 영역에서 가져온 이름을 사용하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#15&quot;&gt;문제 영역에서 가져온 이름을 사용하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#16&quot;&gt;의미 있는 맥락을 ㅊ추가하라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#17&quot;&gt;불필요한 맥락을 없애라&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#18&quot;&gt;마치면서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;들어가면서&quot;&gt;들어가면서&lt;/h2&gt;

&lt;p&gt;클래스, 변수, 함수, 패키지 등의 이름을 지을 때 적용되는 몇 가지 규칙을 소개한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;의도를-분명히-밝혀라&quot;&gt;의도를 분명히 밝혀라&lt;/h2&gt;

&lt;p&gt;좋은 이름을 짓는데 고민이 필요하지만 이로인해 절약되는 시간이 훨씬 많다.&lt;/p&gt;

&lt;p&gt;변수, 클래스, 메소드 이름은 다음의 질문들에 모두 답해야한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;변수, 클래스, 메소드의 존재 이유는?&lt;/li&gt;
  &lt;li&gt;수행하는 기능은?&lt;/li&gt;
  &lt;li&gt;사용 방법은?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 따로 주석이 필요하다면 의도를 분명히 드러내지 못한것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&amp;lt;bad&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//경과 시간(단위: 날짜)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&amp;lt;good&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elapsedTimeInDays&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;daySinceCreation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;daySinceModification&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;d에 비해 아래의 변수들은 어떤 시간을 의미하는지 뜻이 명확히 들어난다. 따라서 코드 이해와 변경이 쉬워진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&amp;lt;bad&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getThem&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;theList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;list1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;코드가 하는일을 짐작하기 어렵다. 문제는 코드의 &lt;strong&gt;함축성&lt;/strong&gt;이다. 코드의 맥락이 변수, 메소드, 리스트 이름에서 전혀 드러나지 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;theList에는 무엇이 들어있는가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;0번째 값(x[0])은 무엇이고 그것이 4인 것이 어떤 의미인가?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반환하는 list1은 어떻게 사용되는가?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사실 위 코드는 지뢰찾기 게임을 만드는 코드의 일부이고 theList가 게임판이다. 배열은 각 칸이다. 0번째 값은 칸의 상태를 뜻한다. 4는 깃발이 꽂힌 상태를 나타낸다. 아래는 개념의 이름을 붙여 재구성한 코드이다.&lt;/p&gt;

&lt;p&gt;&amp;lt;good&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getFlaggedCells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flaggedCells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&amp;gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gameBoard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;STATUS_VALUE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;FLAGGED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;flaggedCells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flaggedCells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이름만 바꾸었을 뿐인데 어떤 기능을 위해 만든 코드인지 주석이 없어도 알기 쉽다. 0과 4를 상수로 지정해 더욱 명확하게 표현한 것도 포인트이다.&lt;/p&gt;

&lt;p&gt;아래처럼 셀을 배열로 표현하는 대신 클래스로 만드는 것도 좋겠다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getFlaggedCells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flaggedCells&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Cell&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gameBoard&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isFlagged&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;flaggedCells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cell&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flaggedCells&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이번에는 isFlagged() 좀 더 명시적인 메소드를 사용해 FLAGGED 상수를 감추어주었다.&lt;/p&gt;

&lt;p&gt;이처럼 변수, 메소드의 좋은 이름을 통해 의도를 명확히 밝힘으로써 주석이 없이도 코드가 술술 읽힐 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;그릇된-정보를-피하라&quot;&gt;그릇된 정보를 피하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;널리 쓰이는 의미가 있는 단어를 변수 이름으로 사용하지마라
    &lt;ul&gt;
      &lt;li&gt;ex) hp, aix, sco는 유닉스 플랫폼이나 유닉스 변종을 가리키는 이름이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;여러 자료를 그룹으로 묶을 때 실제로 사용한 자료형이 아닌것을 이름에 포함시키지마라
    &lt;ul&gt;
      &lt;li&gt;ex) 계정을 담는 컨테이너가 List 자료형이 아니라면 accountList와 같은 이름을 피해라. 차라리 groupOfAccounts 혹은 accounts 같은 이름을 사용하라&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서로 흡사한 이름을 사용하지 마라
    &lt;ul&gt;
      &lt;li&gt;ex) XYZControllerForEfficientHandlingOfStrings, XYZControllerForEfficientStorageOfStrings 두 개의 차이가 짐작이 가는가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유사한 개념은 유사한 표기법을 사용해라(일관성을 지켜라)
    &lt;ul&gt;
      &lt;li&gt;ex) String studentNames, String teacherNames&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;의미-있게-구분하라&quot;&gt;의미 있게 구분하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;컴파일러나 인터프리터만 통과하는것을 목적으로 변수나 메소드명을 막 짓지마라.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;연속적인 숫자를 덧붙인 이름은 최악이다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) a1, a2, a3, …&lt;/li&gt;
      &lt;li&gt;이러한 이름은 아무런 정보도 제공하지 못한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;bad&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copyChars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;a2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&amp;lt;good&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;copyChars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;destination&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;불용어를 사용한 구분을 피해라.
    &lt;ul&gt;
      &lt;li&gt;ex) ProductInfo, ProductData 두 클래스의 차이를 알겠는가?&lt;/li&gt;
      &lt;li&gt;ex) NameString -&amp;gt; Name으로 충분히 String임을 알 수 있다. 부동소수점 같은 것일리는 없지 않은가?&lt;/li&gt;
      &lt;li&gt;ex) Customer와 CustomerObjcect, money와 moneyAmount, accountData와 account 이들이 서로 구분이 되는가? Object, Amount, Data라는 단어는 두 개 사이의 구분을 지을 수 없는 불용어이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;발음하기-쉬운-이름을-사용하라&quot;&gt;발음하기 쉬운 이름을 사용하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래밍은 사회활동이고 토론이 필요하다. 발음하기 어려운 이름은 대화를 어렵게한다.
    &lt;ul&gt;
      &lt;li&gt;ex) genymdhms(generate year month day hour minute second라는 의미) 메소드를 “젠와이엠디에이치엠에스” 라고 부를 것인가?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;bad&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DtaRcrd102&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;genymdhms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modymdhms&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pszqint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;102&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&amp;lt;good&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Customer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;generationTimestamp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Date&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modificationTimestamp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recordId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;102&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;검색하기-쉬운-이름을-사용하라&quot;&gt;검색하기 쉬운 이름을 사용하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;문자 하나를 사용하는 이름, 상수 등은 코드에서 눈에 잘 띄지않아 찾기가 어렵다.
    &lt;ul&gt;
      &lt;li&gt;ex) int a, String s에서 a혹은 s는 거의 모든 문장에서 등장한다.&lt;/li&gt;
      &lt;li&gt;같은 의미로 숫자를 그대로 사용하기보다는 상수를 사용한다.(7 대신 MAX_CLASSES_PER_STUDENT)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MAX_CLASSES_PER_STUDENT와 같은 상수는 찾기가 쉽다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;7&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;인코딩쓸데없는-부가정보을-피하라&quot;&gt;인코딩(쓸데없는 부가정보)을 피하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;헝가리식 표기법을 사용하지마라
    &lt;ul&gt;
      &lt;li&gt;헝가리식 표기법은 프로그래밍 언어에서 변수 및 함수 이름 앞에 데이터 타입을 명시하는 코딩 규칙이다.&lt;/li&gt;
      &lt;li&gt;ex) iNum, sName&lt;/li&gt;
      &lt;li&gt;요즘 IDE는 컴파일 하지 않고도 타입 오류를 감지할 정도로 발전했으므로 헝가리식 표기법은 코드 리딩에 방해만 될 뿐이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;멤버변수 접두어
    &lt;ul&gt;
      &lt;li&gt;멤버변수의 이름앞에 m_를 붙이는 관례가 있었지만 이미 구닥다리가 된지 오래다.&lt;/li&gt;
      &lt;li&gt;ex) private String m_dsc -&amp;gt; private String description&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;인터페이스 접두어
    &lt;ul&gt;
      &lt;li&gt;도형을 생성하는 팩토리를 만들기 위해 인터페이스를 IShapeFactory, 구현클래스를 ShapeFactory로 하는 것은 좋지않다. -&amp;gt; 인터페이스, 구현클래스를 나타내는 접두어는 피해라&lt;/li&gt;
      &lt;li&gt;주의를 흐트리고 과도한 정보를 제공할 뿐이다.&lt;/li&gt;
      &lt;li&gt;둘 중 하나를 인코딩해야한다면 ShapeFactory 인터페이스와 ShapeFactoryImp가 낫다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;8&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;자신의-기억력을-자랑하지마라&quot;&gt;자신의 기억력을 자랑하지마라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;내가 만든 한글자 변수 r이 url을 의미한다는 사실을 언제나 기억할것이라 자만하지마라.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;쉽고 명료한게 최고다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반복문에서의 반복횟수를 카운트하는 i,j,k 정도는 괜찮다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;9&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;클래스-이름&quot;&gt;클래스 이름&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;클래스나 객체 이름은 명사 혹은 명사구가 적합하다.
    &lt;ul&gt;
      &lt;li&gt;good ex) Customer, WikiPage, Account, AddressParser&lt;/li&gt;
      &lt;li&gt;bad ex) Manager, Processor, Data, Info와 같은 불분명한 명사는 피하고 동사는 사용하지 마라.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;10&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;메소드-이름&quot;&gt;메소드 이름&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;메소드 이름은 동사구가 적합하다.
    &lt;ul&gt;
      &lt;li&gt;ex) postPayment, deletePage, save&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;접근자, 변경자, 조건자는 javabean 표준에 따라 이름앞에 get, set, is를 붙인다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Strirng&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;employee&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;customer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mike&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;paycheck&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isPosted&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{...};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;생성자를 오버로딩 할 경우 정적(static) 팩토리 메소드를 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fulcrumPoint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;FromRealNumber&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;23.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;O&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fulcrumPoint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;23.0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;X&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;11&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;기발한-이름은-피하라&quot;&gt;기발한 이름은 피하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;예를 들어 특정 문화권에서만 이해할 수 있는 이름은 피하라.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;구어나 속어체를 피하라.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;ex) whack(X) -&amp;gt; kill(O)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;12&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;한-개념에-한-단어를-사용하라&quot;&gt;한 개념에 한 단어를 사용하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;추상적 개념들은 비슷한 단어를 사용하라.
    &lt;ul&gt;
      &lt;li&gt;fetch(), retrieve(), get() 등의 메소드가 비슷한 기능을 한다면 한 단어로 통일하라.&lt;/li&gt;
      &lt;li&gt;DeviceManager와 ProtocolController는 어떻게 다른가? Controller, Manager 둘 중 하나만 사용해라.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;13&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;말장난을-하지마라&quot;&gt;말장난을 하지마라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;한 단어를 두가지 목적으로 사용하지마라.
    &lt;ul&gt;
      &lt;li&gt;리스트에 element를 추가하는 add와 두 값을 더하는 add는 구분해라. 예를들어 리스트에 element를 추가하는 이름은 insert나 append로 바꾸는게 좋다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;14&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;해법-영역에서-가져온-이름을-사용하라&quot;&gt;해법 영역에서 가져온 이름을 사용하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;코드를 읽을 사람도 프로그래머다.
    &lt;ul&gt;
      &lt;li&gt;전산용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 이름을 문제(domain - 분야) 영역에서 가져오는 것은 좋지않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;15&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;문제-영역에서-가져온-이름을-사용하라&quot;&gt;문제 영역에서 가져온 이름을 사용하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;적절한 프로그래머 용어(해법 영역 이름)이 없다면 문제 영역에서 이름을 가져온다.
    &lt;ul&gt;
      &lt;li&gt;코드를 보수하는 프로그래머가 문제(분야) 전문가에게 의미를 물어 파악할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;16&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;의미있는-맥락을-추가하라&quot;&gt;의미있는 맥락을 추가하라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;이름이 스스로 분명한 의미를 가지도록 한다.
    &lt;ul&gt;
      &lt;li&gt;firstname, lastName, street, houseNumber, city, state, zipcode 변수들이 있으면 주소라는 것을 금방 알아챈다.&lt;/li&gt;
      &lt;li&gt;하지만 state 변수 하나만 있다면? 주소의 일부라는 것을 알기 힘들다.&lt;/li&gt;
      &lt;li&gt;addrFirstName, addrLastName을 사용하면 두 변수가 좀 더 큰 구조(주소)에 속한다는 사실이 좀 더 분명해진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;bad&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;printGuessStatistics&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;no&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;are&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;is&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;are&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guessMessage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
		&lt;span class=&quot;s&quot;&gt;&quot;There %s %s %s%s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guessMessage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;분석을 해보면 candidate 매개변수로 들어온 문자가 몇 개 있는지 출력해주는 함수라는 것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;예를들어 candidate가 ‘a’이고 count가 3이면 “There are 3as”가 출력된다.&lt;/p&gt;

&lt;p&gt;불행하게도 메소드 내용을 끝까지 읽어봐야 파악할 수 있다.&lt;/p&gt;

&lt;p&gt;&amp;lt;good&amp;gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GuessStatisticsMessage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;createPluraDependentMessagerParts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
			&lt;span class=&quot;s&quot;&gt;&quot;There %s %s %s%s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;candidate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createPluraDependentMessageParts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;thereAreNoLeggers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;thereIsOneLetter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;ThereAreManyLetters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thereAreNoLetters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;no&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;are&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pluraModifer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thereIsOneLetter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;is&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;thereAreManyLetters&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;verb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;are&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;pluraModifier&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;클래스를 따로 만들어 메소드를 쪼개고 이름을 붙여주어 맥락을 확실히 해주었다. 알고리즘도 더 명확해진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;17&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;불필요한-맥락을-없애라&quot;&gt;불필요한 맥락을 없애라&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주유소(Gas Station Deluxe) 애플리케이션을 개발할 때 모든 클래스를 GSD로 시작하지는 마라.
    &lt;ul&gt;
      &lt;li&gt;긴 이름보다는 짧은 이름이 좋다. 단, 의미가 분명한 경우에 한해서다.&lt;/li&gt;
      &lt;li&gt;주유소 앱에서 클래스 앞의 GSD는 불필요한 정보일 뿐이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;18&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot;&gt;마치면서&lt;/h2&gt;

&lt;p&gt;좋은 이름을 붙이는 이유는 개발자는 자신이 짠 클래스 이름과 메소드 이름을 모두 기억하지 못한다. 따라서 잘 읽히는 코드를 짜야한다. 다른사람이 읽기 쉽도록 하는 목적도 있다.&lt;/p&gt;</content><author><name>nobbaggu</name></author><category term="깨끗한코드" /><category term="클린코드" /><category term="보이스카우트규칙" /><summary type="html">목차 들어가면서 의도를 분명히 밝혀라 그릇된 정보를 피하라 의미 있게 구분하라 발음하기 쉬운 이름을 사용하라 검색하기 쉬운 이름을 사용하라 인코딩을 피하라 자신의 기억력을 자랑하지마라 클래스 이름 메소드 이름 기발한 이름은 피하라 한 개념에 한 단어를 사용하라 말장난을 하지마라 해법 영역에서 가져온 이름을 사용하라 문제 영역에서 가져온 이름을 사용하라 의미 있는 맥락을 ㅊ추가하라 불필요한 맥락을 없애라 마치면서 들어가면서 클래스, 변수, 함수, 패키지 등의 이름을 지을 때 적용되는 몇 가지 규칙을 소개한다. 의도를 분명히 밝혀라 좋은 이름을 짓는데 고민이 필요하지만 이로인해 절약되는 시간이 훨씬 많다. 변수, 클래스, 메소드 이름은 다음의 질문들에 모두 답해야한다. 변수, 클래스, 메소드의 존재 이유는? 수행하는 기능은? 사용 방법은? 만약 따로 주석이 필요하다면 의도를 분명히 드러내지 못한것이다. &amp;lt;bad&amp;gt; int d; //경과 시간(단위: 날짜) &amp;lt;good&amp;gt; int elapsedTimeInDays; int daySinceCreation; int daySinceModification d에 비해 아래의 변수들은 어떤 시간을 의미하는지 뜻이 명확히 들어난다. 따라서 코드 이해와 변경이 쉬워진다. &amp;lt;bad&amp;gt; public List&amp;lt;int[]&amp;gt; getThem() { List&amp;lt;int[]&amp;gt; list1 = new ArrayList&amp;lt;int[]&amp;gt;(); for(int[] x : theList) { if(x[0] == 4) { list1.add(x); } } return list1; } 코드가 하는일을 짐작하기 어렵다. 문제는 코드의 함축성이다. 코드의 맥락이 변수, 메소드, 리스트 이름에서 전혀 드러나지 않는다. theList에는 무엇이 들어있는가? 0번째 값(x[0])은 무엇이고 그것이 4인 것이 어떤 의미인가? 반환하는 list1은 어떻게 사용되는가? 사실 위 코드는 지뢰찾기 게임을 만드는 코드의 일부이고 theList가 게임판이다. 배열은 각 칸이다. 0번째 값은 칸의 상태를 뜻한다. 4는 깃발이 꽂힌 상태를 나타낸다. 아래는 개념의 이름을 붙여 재구성한 코드이다. &amp;lt;good&amp;gt; public List&amp;lt;int[]&amp;gt; getFlaggedCells() { List&amp;lt;int[]&amp;gt; flaggedCells = new ArrayList&amp;lt;int[]&amp;gt;(); for(int[] cell : gameBoard) { if(cell[STATUS_VALUE] == FLAGGED) { flaggedCells.add(cell); } } return flaggedCells; } 이름만 바꾸었을 뿐인데 어떤 기능을 위해 만든 코드인지 주석이 없어도 알기 쉽다. 0과 4를 상수로 지정해 더욱 명확하게 표현한 것도 포인트이다. 아래처럼 셀을 배열로 표현하는 대신 클래스로 만드는 것도 좋겠다. public List&amp;lt;Cell&amp;gt; getFlaggedCells() { List&amp;lt;Cell&amp;gt; flaggedCells = new ArrayList&amp;lt;Cell&amp;gt;(); for(Cell cell : gameBoard) { if(cell.isFlagged()) { flaggedCells.add(cell); } } return flaggedCells; } 이번에는 isFlagged() 좀 더 명시적인 메소드를 사용해 FLAGGED 상수를 감추어주었다. 이처럼 변수, 메소드의 좋은 이름을 통해 의도를 명확히 밝힘으로써 주석이 없이도 코드가 술술 읽힐 수 있다. 그릇된 정보를 피하라 널리 쓰이는 의미가 있는 단어를 변수 이름으로 사용하지마라 ex) hp, aix, sco는 유닉스 플랫폼이나 유닉스 변종을 가리키는 이름이다. 여러 자료를 그룹으로 묶을 때 실제로 사용한 자료형이 아닌것을 이름에 포함시키지마라 ex) 계정을 담는 컨테이너가 List 자료형이 아니라면 accountList와 같은 이름을 피해라. 차라리 groupOfAccounts 혹은 accounts 같은 이름을 사용하라 서로 흡사한 이름을 사용하지 마라 ex) XYZControllerForEfficientHandlingOfStrings, XYZControllerForEfficientStorageOfStrings 두 개의 차이가 짐작이 가는가? 유사한 개념은 유사한 표기법을 사용해라(일관성을 지켜라) ex) String studentNames, String teacherNames 의미 있게 구분하라 컴파일러나 인터프리터만 통과하는것을 목적으로 변수나 메소드명을 막 짓지마라. 연속적인 숫자를 덧붙인 이름은 최악이다. ex) a1, a2, a3, … 이러한 이름은 아무런 정보도 제공하지 못한다. &amp;lt;bad&amp;gt; public static void copyChars(char[] a1, char[] a2) { for(int i = 0; i &amp;lt; a1.length; i++) { a2[i] = a1[i]; } } &amp;lt;good&amp;gt; public static void copyChars(char[] source, char[] destination) { for(int i = 0; i &amp;lt; source.length; i++) { destination[i] = source[i]; } } 불용어를 사용한 구분을 피해라. ex) ProductInfo, ProductData 두 클래스의 차이를 알겠는가? ex) NameString -&amp;gt; Name으로 충분히 String임을 알 수 있다. 부동소수점 같은 것일리는 없지 않은가? ex) Customer와 CustomerObjcect, money와 moneyAmount, accountData와 account 이들이 서로 구분이 되는가? Object, Amount, Data라는 단어는 두 개 사이의 구분을 지을 수 없는 불용어이다. 발음하기 쉬운 이름을 사용하라 프로그래밍은 사회활동이고 토론이 필요하다. 발음하기 어려운 이름은 대화를 어렵게한다. ex) genymdhms(generate year month day hour minute second라는 의미) 메소드를 “젠와이엠디에이치엠에스” 라고 부를 것인가? &amp;lt;bad&amp;gt; class DtaRcrd102 { private Date genymdhms; private Date modymdhms; private final String pszqint = &quot;102&quot;; } &amp;lt;good&amp;gt; class Customer { private Date generationTimestamp; private Date modificationTimestamp; private final String recordId = &quot;102&quot;; } 검색하기 쉬운 이름을 사용하라 문자 하나를 사용하는 이름, 상수 등은 코드에서 눈에 잘 띄지않아 찾기가 어렵다. ex) int a, String s에서 a혹은 s는 거의 모든 문장에서 등장한다. 같은 의미로 숫자를 그대로 사용하기보다는 상수를 사용한다.(7 대신 MAX_CLASSES_PER_STUDENT) MAX_CLASSES_PER_STUDENT와 같은 상수는 찾기가 쉽다. 인코딩(쓸데없는 부가정보)을 피하라 헝가리식 표기법을 사용하지마라 헝가리식 표기법은 프로그래밍 언어에서 변수 및 함수 이름 앞에 데이터 타입을 명시하는 코딩 규칙이다. ex) iNum, sName 요즘 IDE는 컴파일 하지 않고도 타입 오류를 감지할 정도로 발전했으므로 헝가리식 표기법은 코드 리딩에 방해만 될 뿐이다. 멤버변수 접두어 멤버변수의 이름앞에 m_를 붙이는 관례가 있었지만 이미 구닥다리가 된지 오래다. ex) private String m_dsc -&amp;gt; private String description 인터페이스 접두어 도형을 생성하는 팩토리를 만들기 위해 인터페이스를 IShapeFactory, 구현클래스를 ShapeFactory로 하는 것은 좋지않다. -&amp;gt; 인터페이스, 구현클래스를 나타내는 접두어는 피해라 주의를 흐트리고 과도한 정보를 제공할 뿐이다. 둘 중 하나를 인코딩해야한다면 ShapeFactory 인터페이스와 ShapeFactoryImp가 낫다. 자신의 기억력을 자랑하지마라 내가 만든 한글자 변수 r이 url을 의미한다는 사실을 언제나 기억할것이라 자만하지마라. 쉽고 명료한게 최고다. 반복문에서의 반복횟수를 카운트하는 i,j,k 정도는 괜찮다. 클래스 이름 클래스나 객체 이름은 명사 혹은 명사구가 적합하다. good ex) Customer, WikiPage, Account, AddressParser bad ex) Manager, Processor, Data, Info와 같은 불분명한 명사는 피하고 동사는 사용하지 마라. 메소드 이름 메소드 이름은 동사구가 적합하다. ex) postPayment, deletePage, save 접근자, 변경자, 조건자는 javabean 표준에 따라 이름앞에 get, set, is를 붙인다. Strirng name = employee.getName(); customer.setName(&quot;mike&quot;); if(paycheck.isPosted()) {...}; 생성자를 오버로딩 할 경우 정적(static) 팩토리 메소드를 사용한다. Complex fulcrumPoint = Complex.FromRealNumber(23.0); (O) Complex fulcrumPoint = new Complex(23.0); (X) 기발한 이름은 피하라 예를 들어 특정 문화권에서만 이해할 수 있는 이름은 피하라. 구어나 속어체를 피하라. ex) whack(X) -&amp;gt; kill(O) 한 개념에 한 단어를 사용하라 추상적 개념들은 비슷한 단어를 사용하라. fetch(), retrieve(), get() 등의 메소드가 비슷한 기능을 한다면 한 단어로 통일하라. DeviceManager와 ProtocolController는 어떻게 다른가? Controller, Manager 둘 중 하나만 사용해라. 말장난을 하지마라 한 단어를 두가지 목적으로 사용하지마라. 리스트에 element를 추가하는 add와 두 값을 더하는 add는 구분해라. 예를들어 리스트에 element를 추가하는 이름은 insert나 append로 바꾸는게 좋다. 해법 영역에서 가져온 이름을 사용하라 코드를 읽을 사람도 프로그래머다. 전산용어, 알고리즘 이름, 패턴 이름, 수학 용어 등을 사용해도 괜찮다. 모든 이름을 문제(domain - 분야) 영역에서 가져오는 것은 좋지않다. 문제 영역에서 가져온 이름을 사용하라 적절한 프로그래머 용어(해법 영역 이름)이 없다면 문제 영역에서 이름을 가져온다. 코드를 보수하는 프로그래머가 문제(분야) 전문가에게 의미를 물어 파악할 수 있다. 의미있는 맥락을 추가하라 이름이 스스로 분명한 의미를 가지도록 한다. firstname, lastName, street, houseNumber, city, state, zipcode 변수들이 있으면 주소라는 것을 금방 알아챈다. 하지만 state 변수 하나만 있다면? 주소의 일부라는 것을 알기 힘들다. addrFirstName, addrLastName을 사용하면 두 변수가 좀 더 큰 구조(주소)에 속한다는 사실이 좀 더 분명해진다. &amp;lt;bad&amp;gt; private void printGuessStatistics(char candidate, int count) { String number; String verb; String pluraModifier; if(count == 0) { number = &quot;no&quot;; verb = &quot;are&quot;; pluraModifier = &quot;s&quot;; } else if(count == 1) { number = &quot;1&quot;; verb = &quot;is&quot;; pluraModifier = &quot;&quot;; } else { number = String.valueOf(count); verb = &quot;are&quot;; pluraModifier = &quot;s&quot;; } String guessMessage = String.format( &quot;There %s %s %s%s&quot;, verb, number, candidate, pluraModifier ); print(guessMessage); } 분석을 해보면 candidate 매개변수로 들어온 문자가 몇 개 있는지 출력해주는 함수라는 것을 알 수 있다. 예를들어 candidate가 ‘a’이고 count가 3이면 “There are 3as”가 출력된다. 불행하게도 메소드 내용을 끝까지 읽어봐야 파악할 수 있다. &amp;lt;good&amp;gt; public class GuessStatisticsMessage { String number; String verb; String pluraModifier; public String make(char candidate, int count) { createPluraDependentMessagerParts(count); return String.format( &quot;There %s %s %s%s&quot;, verb, number, candidate, pluraModifier ); } private void createPluraDependentMessageParts(int count) { if (count == 0) { thereAreNoLeggers(); } else if (count == 1) ) { thereIsOneLetter(); } else { ThereAreManyLetters(count); } } private void thereAreNoLetters() { number = &quot;no&quot;; verb = &quot;are&quot;; pluraModifer = &quot;s&quot;; } private void thereIsOneLetter() { number = &quot;1&quot;; verb = &quot;is&quot;; pluraModifier = &quot;&quot;; } private void thereAreManyLetters(int count) { number = String.valueOf(count); verb = &quot;are&quot;; pluraModifier = &quot;s&quot;; } } 클래스를 따로 만들어 메소드를 쪼개고 이름을 붙여주어 맥락을 확실히 해주었다. 알고리즘도 더 명확해진다. 불필요한 맥락을 없애라 주유소(Gas Station Deluxe) 애플리케이션을 개발할 때 모든 클래스를 GSD로 시작하지는 마라. 긴 이름보다는 짧은 이름이 좋다. 단, 의미가 분명한 경우에 한해서다. 주유소 앱에서 클래스 앞의 GSD는 불필요한 정보일 뿐이다. 마치면서 좋은 이름을 붙이는 이유는 개발자는 자신이 짠 클래스 이름과 메소드 이름을 모두 기억하지 못한다. 따라서 잘 읽히는 코드를 짜야한다. 다른사람이 읽기 쉽도록 하는 목적도 있다.</summary></entry><entry><title type="html">(클린코드) Chapter01 - 깨끗한 코드</title><link href="http://localhost:4000/2020/03/07/%EA%B9%A8%EB%81%97%ED%95%9C%EC%BD%94%EB%93%9C/" rel="alternate" type="text/html" title="(클린코드) Chapter01 - 깨끗한 코드" /><published>2020-03-07T13:37:19+09:00</published><updated>2020-03-07T13:37:19+09:00</updated><id>http://localhost:4000/2020/03/07/%EA%B9%A8%EB%81%97%ED%95%9C%EC%BD%94%EB%93%9C</id><content type="html" xml:base="http://localhost:4000/2020/03/07/%EA%B9%A8%EB%81%97%ED%95%9C%EC%BD%94%EB%93%9C/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;나쁜코드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;깨끗한코드&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;결론&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt; 
&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;나쁜코드&quot;&gt;나쁜코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;나쁜코드가 만들어지는 과정
    &lt;ul&gt;
      &lt;li&gt;출시 압박에 마구짠 코드&lt;/li&gt;
      &lt;li&gt;기능을 추가할수록 엉망이 되고 결국 감당 불가능한 수준에 이름&lt;/li&gt;
      &lt;li&gt;상사한테 욕먹을까봐 서둘러 짠 코드&lt;/li&gt;
      &lt;li&gt;다른 업무가 밀려 후딱 해치우려고 세심한 주의를 기울이지 않은 코드&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;나중에 손보겠다고 일단 돌아가게만 짠 코드 -&amp;gt; 르블랑의 법칙 : 나중은 결코 오지 않는다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;나쁜 코드로 치르는 대가
    &lt;ul&gt;
      &lt;li&gt;코드가 엉망이라 프로젝트 진도가 나가지 못함&lt;/li&gt;
      &lt;li&gt;코드를 고칠때마다 문제가 생기고 더욱 엉킨 코드가 됨&lt;/li&gt;
      &lt;li&gt;시간이 지날수록 쓰레기더미는 점점 높아지고 청소를 할 수 없을 지경에 이르름&lt;/li&gt;
      &lt;li&gt;팀 생산성이 저하하다가 마침내 0으로 수렴&lt;/li&gt;
      &lt;li&gt;원대한 재설계의 꿈
        &lt;ul&gt;
          &lt;li&gt;마침내 기존 프로젝트를 버리고 재설계를 시작(인력, 돈, 시간 소모)&lt;/li&gt;
          &lt;li&gt;기존 프로젝트보다 괜찮은 결과를 내야한다는 압박에 서둘러 쓰레기를 생산&lt;/li&gt;
          &lt;li&gt;위의 과정 반복&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;원초적 난제
    &lt;ul&gt;
      &lt;li&gt;누구나 나쁜 코드가 업무속도를 늦춘다는 사실을 안다.&lt;/li&gt;
      &lt;li&gt;그럼에도 기한을 맞추려 나쁜 코드를 양산할 수 밖에 없는 원초적인 난제가 존재한다.&lt;/li&gt;
      &lt;li&gt;과연 기한을 맞추려 서두르는 것이 더 빠른 결과를 내는가?
        &lt;ul&gt;
          &lt;li&gt;초기에는 그럴지도 모른다. 하지만 시간이 지날수록 코드가 나빠지고 결국은 느리다는 사실!&lt;/li&gt;
          &lt;li&gt;결론은 빨리가기 위해 시간을 들여라. -&amp;gt; 생각하고 신중히 고민하여 설계하기 위한 시간을 충분히 가지면서 깨끗한 코드를 유지하면서 진행해라.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;깨끗한-코드&quot;&gt;깨끗한 코드&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;깨끗한 코드의 정의는 전문가마다 다르다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;비야네 스트롭스트룹(Bjarne Stroustrup) - C++ 창시자&lt;/em&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;우아하고 효율적인 코드&lt;/li&gt;
    &lt;li&gt;논리가 간단한 코드&lt;/li&gt;
    &lt;li&gt;최소의 의존성으로 쉬운 유지보수가 가능한 코드&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;한 가지를 제대로 하는 깨끗한 코드&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;그래디 부치(Grady Booch) - Objected Oriented Analysis and Design with Application 저자&lt;/em&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;단순하고 직접적인 코드&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;잘 읽히는 코드&lt;/strong&gt;(가독성)&lt;/li&gt;
    &lt;li&gt;숨겨진 설계자의 의도가 없는 코드&lt;/li&gt;
    &lt;li&gt;명쾌한 추상화와 단순한 제어문&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;빅 데이브 토마스(Big Dave Thomas) - OTI 창립자&lt;/em&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;작성자가 아닌 사람이 읽기 쉽고 고치기 쉬운 코드&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;단위 테스트와 인수 테스트케이스가 존재하는 코드&lt;/li&gt;
    &lt;li&gt;의미있는 이름&lt;/li&gt;
    &lt;li&gt;하나의 기능당 하나의 방법&lt;/li&gt;
    &lt;li&gt;최소의 명확한 의존성&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;최소의!!&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;마이클 페더스(Michale Feathers) - Working Effectively with Legacy Code 저자&lt;/em&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;주의깊게 짠 코드&lt;/strong&gt;(고치려 해봐도 결국 제자리로 귀결)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;론 제프리스(Rone Jeffries) - Extreme Programming Installed 저자&lt;/em&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;모슨 테스트를 통과&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;중복이 없다.&lt;/strong&gt;(여러 기능을 수행하는 객체 혹은 메소드는 여러 객체 혹은 메소드로 나누기)&lt;/li&gt;
    &lt;li&gt;명확하게 표현하라.(클래스 이름, 메소드 이름, 변수 이름)&lt;/li&gt;
    &lt;li&gt;클래스, 메소드, 함수를 최대한 줄인다.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;워드 커닝햄(Ward Cunningham) - Wiki 창시자&lt;/em&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;코드를 읽으며 짐작한 기능을 각 루틴이 그대로 수행&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;쓰레기가 생기지 않게 작은 것에도 신경써 세심하게 주의를 기울여 코드를 짜라. 코드는 최소한의 단위로 쪼개고 쪼개 각 메소드나 객체는 한 가지 일을 제대로 수행하도록 만든다. 그리고 어떤일을 하는지 클래스, 메소드 이름으로 충분히 나타내줘라. 그렇게 하면 어떤 모듈이 정확히 어떤 기능을 수행하는지 명쾌해지고 읽는사람이 쉽게 내용을 파악할 수 있다. 여러 메소드에 비슷한 코드가 있으면 중복이다. 메소드 추출을 해서 하나의 기능을 하는 모듈로 만들어라.&lt;/p&gt;

&lt;h3 id=&quot;보이스카우트-규칙&quot;&gt;보이스카우트 규칙&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;미국의 보이스카우트가 따르는 간단한 규칙은 개발자들에게 유용하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;캠프장에 들어올때보다 나갈 때 깨끗하게 해놓고 떠나라.&lt;/li&gt;
  &lt;li&gt;코드를 체크아웃할 때 보다 수정하여 체크인 할때 조금이라도 깨끗해야한다.&lt;/li&gt;
  &lt;li&gt;한꺼번에 많이 할 필요도 없다. -&amp;gt; 변수 이름 하나를 바꾸거나 조금 긴 함수를 분할하거나 약간의 중복만 제거해도 충분하다. 이것만 지키면 절대 더 나빠질일이 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
이제부터 이러한 일들을 구체적으로 어떻게 하는지 한가지씩 알아보자!&lt;/p&gt;</content><author><name>nobbaggu</name></author><category term="깨끗한코드" /><category term="클린코드" /><category term="보이스카우트규칙" /><summary type="html">목차 나쁜코드 깨끗한코드 결론 나쁜코드 나쁜코드가 만들어지는 과정 출시 압박에 마구짠 코드 기능을 추가할수록 엉망이 되고 결국 감당 불가능한 수준에 이름 상사한테 욕먹을까봐 서둘러 짠 코드 다른 업무가 밀려 후딱 해치우려고 세심한 주의를 기울이지 않은 코드 나중에 손보겠다고 일단 돌아가게만 짠 코드 -&amp;gt; 르블랑의 법칙 : 나중은 결코 오지 않는다. 나쁜 코드로 치르는 대가 코드가 엉망이라 프로젝트 진도가 나가지 못함 코드를 고칠때마다 문제가 생기고 더욱 엉킨 코드가 됨 시간이 지날수록 쓰레기더미는 점점 높아지고 청소를 할 수 없을 지경에 이르름 팀 생산성이 저하하다가 마침내 0으로 수렴 원대한 재설계의 꿈 마침내 기존 프로젝트를 버리고 재설계를 시작(인력, 돈, 시간 소모) 기존 프로젝트보다 괜찮은 결과를 내야한다는 압박에 서둘러 쓰레기를 생산 위의 과정 반복 원초적 난제 누구나 나쁜 코드가 업무속도를 늦춘다는 사실을 안다. 그럼에도 기한을 맞추려 나쁜 코드를 양산할 수 밖에 없는 원초적인 난제가 존재한다. 과연 기한을 맞추려 서두르는 것이 더 빠른 결과를 내는가? 초기에는 그럴지도 모른다. 하지만 시간이 지날수록 코드가 나빠지고 결국은 느리다는 사실! 결론은 빨리가기 위해 시간을 들여라. -&amp;gt; 생각하고 신중히 고민하여 설계하기 위한 시간을 충분히 가지면서 깨끗한 코드를 유지하면서 진행해라. 깨끗한 코드 깨끗한 코드의 정의는 전문가마다 다르다. 비야네 스트롭스트룹(Bjarne Stroustrup) - C++ 창시자 우아하고 효율적인 코드 논리가 간단한 코드 최소의 의존성으로 쉬운 유지보수가 가능한 코드 한 가지를 제대로 하는 깨끗한 코드 그래디 부치(Grady Booch) - Objected Oriented Analysis and Design with Application 저자 단순하고 직접적인 코드 잘 읽히는 코드(가독성) 숨겨진 설계자의 의도가 없는 코드 명쾌한 추상화와 단순한 제어문 빅 데이브 토마스(Big Dave Thomas) - OTI 창립자 작성자가 아닌 사람이 읽기 쉽고 고치기 쉬운 코드 단위 테스트와 인수 테스트케이스가 존재하는 코드 의미있는 이름 하나의 기능당 하나의 방법 최소의 명확한 의존성 최소의!! 마이클 페더스(Michale Feathers) - Working Effectively with Legacy Code 저자 주의깊게 짠 코드(고치려 해봐도 결국 제자리로 귀결) 론 제프리스(Rone Jeffries) - Extreme Programming Installed 저자 모슨 테스트를 통과 중복이 없다.(여러 기능을 수행하는 객체 혹은 메소드는 여러 객체 혹은 메소드로 나누기) 명확하게 표현하라.(클래스 이름, 메소드 이름, 변수 이름) 클래스, 메소드, 함수를 최대한 줄인다. 워드 커닝햄(Ward Cunningham) - Wiki 창시자 코드를 읽으며 짐작한 기능을 각 루틴이 그대로 수행 결론 쓰레기가 생기지 않게 작은 것에도 신경써 세심하게 주의를 기울여 코드를 짜라. 코드는 최소한의 단위로 쪼개고 쪼개 각 메소드나 객체는 한 가지 일을 제대로 수행하도록 만든다. 그리고 어떤일을 하는지 클래스, 메소드 이름으로 충분히 나타내줘라. 그렇게 하면 어떤 모듈이 정확히 어떤 기능을 수행하는지 명쾌해지고 읽는사람이 쉽게 내용을 파악할 수 있다. 여러 메소드에 비슷한 코드가 있으면 중복이다. 메소드 추출을 해서 하나의 기능을 하는 모듈로 만들어라. 보이스카우트 규칙 미국의 보이스카우트가 따르는 간단한 규칙은 개발자들에게 유용하다. 캠프장에 들어올때보다 나갈 때 깨끗하게 해놓고 떠나라. 코드를 체크아웃할 때 보다 수정하여 체크인 할때 조금이라도 깨끗해야한다. 한꺼번에 많이 할 필요도 없다. -&amp;gt; 변수 이름 하나를 바꾸거나 조금 긴 함수를 분할하거나 약간의 중복만 제거해도 충분하다. 이것만 지키면 절대 더 나빠질일이 없다. 이제부터 이러한 일들을 구체적으로 어떻게 하는지 한가지씩 알아보자!</summary></entry><entry><title type="html">(컴퓨터구조) 7. 시스템 버스, I/O 및 인터럽트</title><link href="http://localhost:4000/2020/03/06/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4-IO-%EB%B0%8F-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8/" rel="alternate" type="text/html" title="(컴퓨터구조) 7. 시스템 버스, I/O 및 인터럽트" /><published>2020-03-06T13:37:19+09:00</published><updated>2020-03-06T13:37:19+09:00</updated><id>http://localhost:4000/2020/03/06/%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EB%B2%84%EC%8A%A4%20IO%20%EB%B0%8F%20%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/2020/03/06/%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B2%84%EC%8A%A4-IO-%EB%B0%8F-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;시스템 버스&lt;/li&gt;
  &lt;li&gt;버스 중재&lt;/li&gt;
  &lt;li&gt;I/O장치의 접속&lt;/li&gt;
  &lt;li&gt;인터럽트를 이용한 I/O&lt;/li&gt;
  &lt;li&gt;DMA를 이용한 I/O&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-intro&quot;&gt;0. Intro&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;이번 챕터에서는 CPU, 메모리, 보조저장장치 및 I/O장치들을 서로 접속할 수 있게 해주는 시스템 버스와 그 매커니즘, 그리고 시스템 버스의 성능 향상을 위해 사용되는 직접 메모리 액세스(DMA)에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-시스템-버스&quot;&gt;1. 시스템 버스&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;시스템 버스는 컴퓨터를 구성하는 요소들 사이에 데이터 전송을 할 수 있는 통로이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(1) 시스템 버스 조직&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/computer_system_bus.png&quot; alt=&quot;computer_system_bus&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컴퓨터를 구성하는 요소들은 시스템 버스를 통해 프로그램 코드, 데이터, 제어명령 등을 교환하며 CPU가 클록 신호를 여기로 내보낸다. 물리적으로 전기신호를 전송하므로 도체로 된 선들로 만들어진다. 선들의 수는 CPU가 발생시키는 주소 비트 수, 워드, 제어 신호의 수에 따라 결정된다. 2챕터에서 말했듯이 시스템 버스는 크게 세 가지로 구분된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 데이터 버스(data bus)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;시스템 사이의 데이터 전송을 위한 버스이다. 워드(word), 즉 CPU가 한 번에 처리하는 비트 수만큼의 버스선이 필요하다. 데이터는 CPU와 메모리, I/O장치들 사이 양방향으로 발생하므로 데이터 버스는 양방향(bidirectional) 전송을 지원할 수 있어야한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) 주소 버스(address bus)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU가 메모리, 기타 I/O 장치들에 쓰기/읽기를 할 때 메모리의 주소지정을 위한 버스이다. 주소는 CPU가 발생시키기 때문에 주소 버스는 단방향(unidirectional) 전송통로이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(c) 제어 버스(control bus)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;기억장치 및 I/O장치에 대한 쓰기/읽기 신호들을 내보내는 버스이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
시스템 버스의 사용 주체가 되는 요소를 &lt;strong&gt;버스 마스터(bus master)&lt;/strong&gt;라고 한다. CPU 및 I/O장치의 제어기등이 버스 마스터가 될 수 있다. 동기식 버스(synchronous)에서는 메모리 역시 버스 마스터가 될 수 있다. 시스템 버스는 모든 요소들이 공유하는 자원이며 한 번에 하나의 버스 마스터만 버스를 점유할 수 있다. 여러 마스터들이 동시에 버스를 사용하고자 하면 순서를 지정해주는 &lt;strong&gt;버스 중재(bus arbitration)&lt;/strong&gt;가 일어난다.&lt;/p&gt;

&lt;p&gt;버스 중재를 위해서는 아래의 제어 신호들이 필요하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 버스 요구(bus request) : 버스 마스터의 버스 사용 요구
(b) 버스 승인(bus grant) : 버스 마스터에게 버스 사용 허가
(c) 버스 사용중(bus busy) : 다른 마스터에 의해 버스 사용중
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;버스 중재를 위한 신호선들의 집합을 버스 중재 버스라고 따로 구분하기도 한다. 버스 중재에 대해서는 잠시 후에 자세히 설명한다.&lt;/p&gt;

&lt;p&gt;키보드, 마우스등은 비동기식으로 인터럽트를 통해 동작한다. 명령어 인출-실행 단계가 끝나면 I/O장치 제어기들의 인터럽트 비트 레지스터를 확인하여 인터럽트 요구가 있으면 이를 처리한다. 이처럼 인터럽트 메커니즘에는 아래의 두 신호가 필요하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 인터럽트 요구(interrupt request) : I/O 디바이스의 인터럽트 요구를 나타낸다.
(b) 인터럽트 확인(interrupt aknowledge) : CPU가 I/O 디바이스의 인터럽트 요구를 인식했다는 것을 나타낸다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 신호들을 위한 버스들을 별도로 인터럽트 버스라고 부르기도 한다.&lt;/p&gt;

&lt;p&gt;이외에도 제어신호에는 동기식 버스에서 버스 동작 시간을 일치시키기 위한 공통 클록 신호, 모든 시스템 요소들을 초기화시키는 리셋(reset) 신호가 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(2) 시스템 버스의 기본 동작&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;버스 상의 모든 동작은 쓰기 동작 혹은 읽기 동작 중 하나로 구분된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 쓰기 : 버스 마스터 사용권한 획득 -&amp;gt; 주소, 데이터, 쓰기신호 전송
(b) 읽기 : 버스 마스터 사용권환 획득 -&amp;gt; 주소, 읽기 신호 전송 -&amp;gt; 데이터가 올 때 까지 대기
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 동기식 버스(synchronous bus)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;시간이 버스 클록을 기준으로 모든 버스 동작이 발생한다. 아래는 동기식 버스에서 CPU가 메모리로부터 데이터를 읽어오는 과정을 나타낸 타이밍도이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/synchronous_bus_timing.png&quot; alt=&quot;synchronous_bus_timing&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버스 동작의 시작 신호를 기준으로 동작이 발생한다. 첫 번째 주기에서 읽기신호와 주소를 내보낸다. 두 번째 주기동안에는 데이터가 인출되어 세 번재 주기에 인출된 데이터가 전송된다. 메모리는 데이터와 함께 확인 신호를 보낸다. CPU는 확인신호를 보고 버스에 요청한 데이터가 실려있다는 것을 알고 데이터를 받는다.&lt;/p&gt;

&lt;p&gt;동기식 버스는 회로가 간단하다. 그러나 동시에 발생하는 동작들 중 가장 오래 걸리는 동작이 끝날 때까지 기다려야 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) 비동기식 버스(asynchronous bus)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;버스 동작 발생이 다른 버스 동작의 발생 여부에 따라 결정된다. 아래는 비동기식 버스의 경우 CPU가 메모리로부터 데이터를 읽어오는 과정을 나타낸 타이밍도이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/asynchronous_bus_timing.png&quot; alt=&quot;asynchronous_bus_timing&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기에는 클록 신호를 사용하지 않는다. 먼저 CPU가 버스로 주소와 읽기 신호를 보낸다. 신호가 안정될 때 까지 기다린 후 주소와 제어 신호를 보냈음을 알리기 위한 마스터 동기 신호(Master Synch Signal : MSYN)를 보낸다. 메모리는 MYSN을 보고 주소 버스와 제어 버스를 확인 후 메모리의 해당 주소에서 데이터를 인출하여 버스에 싣는다. 이후 슬레이브 동기 신호(Slave Synch Signal : SSYN)를 보낸다. 그럼 CPU가 SSYN을 확인하고 데이터 버스로부터 데이터를 가져간다. 데이터를 다 가져가고 난 후 MSYN와 읽기신호, 주소신호를 제거한다. 이후 메모리는 MYSN가 제거된 것을 보고 SSYN 신호를 제거한다.&lt;/p&gt;

&lt;p&gt;비동기식 버스에서는 동작이 완료되고 나면 바로 다음 동작이 발생되므로 시간낭비가 없다. 그러나 위와같은 동작에 필요한 인터페이스 회로가 복잡하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-버스-중재&quot;&gt;2. 버스 중재&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;여러 버스마스터들이 버스 사용을 요구하는 경우 &lt;strong&gt;버스 경합(bus contention)&lt;/strong&gt;이 발생한다. 버스 경합이 발생하면 이들의 순서를 결정해주는 &lt;strong&gt;버스 중재(bus arbitration)&lt;/strong&gt;을 해주어야 한다. 버스 중재를 해주는 모듈을 버스 중재기라고 한다.&lt;/p&gt;

&lt;p&gt;버스 중재 방식은 시스템 성능에 큰 영향을 미치기 때문에 버스 시스템의 특성에 따라 알맞게 설계해야한다. 여러 버스마스터 중 중요도가 높은 마스터에게 우선적으로 권한을 부여해야한다. 또한 중요한 것은 어떤 버스 마스터가 오랫동안 버스를 사용하지 못하는 버스 기근(bus starvation)이 발생하지 않도록 해야한다.&lt;/p&gt;

&lt;p&gt;버스 중재 방식은 제어 신호들의 연결구조에 따라 두 가지로 분류될 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 병렬 중재 방식
(b) 직렬 중재 방식
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;병렬 중재 방식에서는 각각의 버스 마스터의 버스 요구 신호 및 버스 승인 신호가 버스 중재기와 연결되어 있다. 즉 각각의 버스 카스터가 독립적으로 신호를 발생시킨다.&lt;/p&gt;

&lt;p&gt;직렬 중재 방식에서는 버스 요구 신호 및 버스 승인 신호 선이 한 개씩만 있고 각각 버스 마스터들과 직렬로 연결된다. 접속되는 순서에 따라 우선순위가 결정된다.&lt;/p&gt;

&lt;p&gt;버스 중재기의 위치에 따른 분류도 존재한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 중앙집중식 중재 방식
(b) 분산식 중재 방식
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;중앙집중식 방식에서는 버스 중재기가 시스탬에 단 한 개만 존재하며 모든 버스 중재가 이 중재기에 의해 이루어진다. 여러 버스 마스터들이 버스 요구 신호를 보내면 중재기가 규칙에 따라 하나의 버스 마스터에게만 버스 승인 신호를 보낸다.&lt;/p&gt;

&lt;p&gt;분산식 중재 방식에서는 여러개의 중재기가 존재하며 일반적으로 각각의 버스 마스터가 하나의 중재기를 가진다. 각 마스터는 각각의 중재기에 의해 중재된다.&lt;/p&gt;

&lt;p&gt;위의 중재 방식들을 적절히 조합하면 다양한 중재 방식을 구성할 수 있다. 이제 여러 대표적인 중재 방식의 구성을 살펴본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(1) 병렬 중재 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 중앙집중식 고정 우선순위 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;고정 우선순위는 각 버스 마스터에 지정된 우선순위가 변하지 않는 방식이다. 아래 그림은 중앙집중식 고정 우선순위 방식의 회로 구성도이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/centralized_fixed_priority_arbitration.png&quot; alt=&quot;centralized_fixed_priority_arbitration&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;버스마스터 1부터 4까지 차례로 높은 우선순위를 가진다고 가정한다.&lt;/p&gt;

&lt;p&gt;병렬 중재방식이므로 각각의 버스 마스터가 버스 요구선(BREQ)과 버스 승인선(BGNT)을 가지고 있다. 또한 중앙집중식이기 때문에 버스 중재기 하나가 모든 마스터에 대해 버스중재를 한다.&lt;/p&gt;

&lt;p&gt;여러 버스요구가 동시에 중재기로 들어오면 고정된 우선순위가 가장 높은 마스터에게 버스 승인 신호를 보낸다.&lt;/p&gt;

&lt;p&gt;BBUSY 신호는 active-low 신호로 0이면 버스가 사용중임을 나타낸다. 버스 승인 권한을 받은 제어기는 BBUSY 신호가 0이면 기다렸다가 1이 되면 사용을 시작한다. 버스 마스터는 버스를 사용하기 전에 BBUSY신호를 0으로 만들어 다른 버스가 사용하지 못하도록 막는다.&lt;/p&gt;

&lt;p&gt;아래 그림은 버스마스터 1이 버스를 사용하고있는 중에 버스마스터 3이 버스 요구신호를 보내는 예시이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/centralized_fixed_priority_arbitration_example.png&quot; alt=&quot;centralized_fixed_priority_arbitration_example&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;버스마스터3이 BREQ3 신호를 1로 세트
			↓
중재기가 BGNT3을 1로 세트하여 버스 사용 허가
			↓
버스마스터1의 사용이 끝나 BBUSY 신호를 1로 해제
			↓
버스마스터3이 BBUSY신호가 1인걸 확인하고 다시 0으로 활성화시킨 후 버스 사용 시작
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 그림에서 우선순위를 설정하기 위한 중재기의 회로는 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/cfp_bus_arbitrator_diagram.png&quot; alt=&quot;cfp_bus_arbitrator_diagram&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선순위가 낮은 마스터의 요구신호는 더 높은 마스터들의 요구신호들의 반전(NOT) 신호와함께 AND 게이트로 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) 분산식 고정 우선순위 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 방식에서는 버스 마스터들이 각각 중재기를 하나씩 가진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/dfp_bus_arbitrator_diagram.png&quot; alt=&quot;dfp_bus_arbitrator_diagram&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마스터1,2,3,4가 차례대로 높은 우선순위를 가진다. 각 중재기는 자신보다 높은 우선순위를 가진 마스터들의 버스 요구신호의 반전(NOT)을 입력으로 받기 때문에 더 높은 우선순위인 어떤 마스터의 요구신호도 없을 경우만 자신의 승인 신호를 1로 세트한다.&lt;/p&gt;

&lt;p&gt;버스 승인을 받은 마스터는 BBUSY 신호를 검사하여 다른 마스터가 사용중이지 않을 경우에만 버스 사용을 시작한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;분산식 방식은 중앙집중식 방식에 비해 중재 회로가 간단하고 속도가 빠르다는 장점이 있다. 그러나 고장이 났을 경우 시스템 동작에 영향을 줄 수 있다. 가령 버스 승인 신호를 잘못 발생시켜 두 버스마스터가 동시에 버스를 사용하는 일이 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(c) 가변 우선순위 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;가변 우선순위 방식에서는 시스템의 상태나 조건에 따라 버스 마스터들에 지정된 우선순위가 계속해서 변하는 방식이다. 우선순위가 높은 마스터의 버스 독점이나 우선순위가 낮은 마스터의 버스 기근을 방지하기 용이하다.&lt;/p&gt;

&lt;p&gt;가변적인 우선순위를 부여하는 알고리즘에는 여러 종류가 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 회전 우선순위
	
	- 중재 동작이 끝나면 모든 마스터들의 우선순위가 1단계씩 낮아지며 가장 낮은 우선순위였던 마스터가 최상위 우선순위를 가지게 하는 방법
		혹은
	
	- 버스 사용 승인을 받은 마스터를 최하위 우선순위로 보내고 다음 위치의 마스터부터 차례로 상위 우선순위를 부여하는 방법

(b) 임의 우선순위
	
	버스 중재가 끝나면 말 그대로 랜덤으로 우선순위를 부여한다.

(c) 동등 우선순위
	
	비동기식 버스에서 사용될 수 있는 방식으로 모든 버스마스터들이 동등한 우선순위를 가진다. 만약 두 개 이상의 버스 요구 신호가 도착하면 중재기는 충돌이 일어나지 않게 중재하는데, 일반적으로 먼저 도착한 요구부터 승인하는 FIFO 방식을 사용한다.
	
(d) 최소-최근 사용
	
	더 오랫동안 버스를 사용하지 않은 마스터부터 최상위 우선순위를 부여한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(2) 직렬 중재 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 중앙집중식 직렬 중재 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;직렬 중재방식에서는 모든 버스마스터의 요구신호선과 승인신호선이 각각 하나의 공통신호선을 통하여 중재기로 들어간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/serial_centralized_arbitration.png&quot; alt=&quot;serial_centralized_arbitration&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;중앙집중식 직렬중재에서는 중재기에 가까운 버스마스터의 우선순위가 높아진다. 위 그림에서는 중재기로 어떤 요구신호가 들어오더라도 가장 가까운 버스마스터에 버스 승인 신호를 보낸다. 그 마스터가 버스 요구신호를 발생시키지 않았다면 다음 마스터로 버스 승인 신호를 보낸다. 이렇게 버스 요구 신호가 세트되어있는 마스터들 중 최상위 우선순위의 마스터에게 승인신호가 전달되면 해당 마스터에 의해 버스 사용이 시작된다.&lt;/p&gt;

&lt;p&gt;이 방식에서도 BBUSY 신호가 해제될 때 까지 기다렸다가 버스사용이 시작된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) 분산식 직렬 중재 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분산식 직렬 중재방식에서는 아래 그림과 같이 데이지체인 버스 승인 신호(daisy-chain bus grant signal : DBGNT)선이 버스 중재기들을 순환형으로 접속해있도록 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/serial_distributed_arbitration.png&quot; alt=&quot;serial_distributed_arbitration&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;어떤 버스마스터가 사용을 시작하는 순간 DBGNT신호를 우측 마스터로 넘긴다. 해당 마스터의 버스요구신호가 세트되어있으면 중재기가 버스 승인 신호를 해당 마스터로 보낸다. 그러나 버스 요구신호가 없다면 오른쪽 버스 마스터로 DBGNT 신호를 넘겨준다.&lt;/p&gt;

&lt;p&gt;이 방식에서는 우선순위가 계속 변한다. 현재 버스를 사용주인 버스 마스터의 오른쪽으로 가장 가까이 위치한 버스마스터들 중 버스 요구신호를 발생시킨 마스터가 최상위 우선순위를 가지게 된다.&lt;/p&gt;

&lt;p&gt;중재기가 버스 승인신호를 버스 마스터로 보내더라도 버스 마스터는 BBUSY 비트가 해제된 후 버스 사용을 시작하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(3) 폴링 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;폴링 방식은 버스 중재기가 버스 마스터들의 요구신호를 주기적으로 검사하여 버스 사용 승인 여부를 결정한다.&lt;/p&gt;

&lt;p&gt;폴링 순서와 중재 동작이 모두 회로로 구현되어있는 하드웨어 폴링 방식과 소프트웨어를 활용하여 코드로 구현한 소프트웨어 폴링 방식이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 하드웨어 폴링&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;버스 중재기와 마스터들 사이에 폴링을 위한 폴링선들이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/polling_arbitration.png&quot; alt=&quot;polling_arbitration&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;중재기가 폴링 주소를 발생하여 검사할 마스터를 지정한 후 버스 사용을 원하는지 검사한다
							↓
지정된 마스터가 버스 사용을 원하는 경우 BREQ 신호를 세트한다
							↓
BREQ 신호를 세트한 버스마스터에게 버스 사용을 승인한다. 그렇지 않으면 다음 마스터를 검사한다
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
이 방식에서 우선순위는 중재기가 버스마스터들을 검사하는 순서이다. 마스터가 버스 사용을 시작하면 BBUSY 신호가 세트되고 폴링 동작이 중지된다. 이후 버스 사용이 완료되고 BBUSY 신호가 해제되면 다시 폴링을 시작한다. 이 때 사용이 완료된 마스터의 다음 마스터부터 검사하도록 하는 회전 우선순위 방식을 사용할 수도 있고 다시 처음 마스터부터 폴링을 시작하는 고정 우선순위 방식을 사용할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) 소프트웨어 폴링&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;소프트웨어 폴링 방식을 위한 회로는 하드웨어 폴링 방식과 동일하다. 그러나 버스 중재기가 프로그램을 실행할 수 있는 프로세서를 가지고 있다. 따라서 하드웨어 폴링방식처럼 하드웨어로 인한 일률적인 중재가 아닌 융통성있는 중재가 가능하다. 중재기의 프로그램은 다음 폴링 순서를 유연하게 결정하는데 사용되거나 혹은 고장이 발생한 버스 마스터를 폴링에서 제외시킬 수도 있다. 다만 하드웨어 폴링방식에 비해 속도가 느리다는 단점이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-io-장치의-접속&quot;&gt;3. I/O 장치의 접속&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;I/O 장치는 CPU와 메모리(주기억장치) 이외의 모든 장치이다. 여기서는 I/O 장치들의 제어방법 및 주소지정 방법에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(1) I/O 제어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I/O 장치들은 종류가 매우 다양하며 일일이 모든 제어 회로를 CPU내부에 포함시키지 못한다. 이외에도 데이터 전송속도 차이의 문제나 데이터 형식의 차이로 인해 시스템 버스에 직접 접속되지 못한다. 이를 위해 CPU와 I/O 장치 사이에서 인터페이스 역할을 수행해주는 제어기가 필요하다. 이를 I/O 제어기라 한다.&lt;/p&gt;

&lt;p&gt;I/O 제어기는 I/O장치 제어, CPU 혹은 메모리와 I/O 사이의 통신, 데이터 버퍼링, 오류 검출 등의 기능을 수행한다. 일반적으로 각 I/O장치를 위한 별도의 제어기가 시스템 버스와 I/O장치 사이의 인터페이스를 담당하도록 되어있다.&lt;/p&gt;

&lt;p&gt;예시를 위해 프린터 출력의 경우를 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/printer_controller_diagram.png&quot; alt=&quot;printer_controller_diagram&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) CPU가 프린터 제어기의 상태 레지스터의 출력준비 비트(RDY bit)가 세트 되어있는지 검사한다.
(b) 프린터 제어기가 CPU에 검사결과를 전송한다.
(c) 준비가 되어있다면 출력할 데이터와 출력 명령 신호를 프린터 제어기로 전송한다.
(d) 프린터 제어기가 출력할 데이터와 제어신호를 프린터로 보낸다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 CPU는 I/O 장치의 프로세서와 통신하며 I/O장치는 I/O 제어기에 의해 동작된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(2) I/O 주소지정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서 설명한 내용의 요점은 CPU는 I/O 장치를 직접 제어할 필요 없이 I/O 제어기의 레지스터 값을 읽거나 레지스터에 명령할 내용을 쓰기만 하면된다. 나머지는 I/O 제어기가 알아서 한다.&lt;/p&gt;

&lt;p&gt;CPU가 I/O장치를 사용하려면 데이터를 주고받을 주소를 지정해야한다. I/O 장치별로 두 개씩의 주소가 지정된다. 하나는 상태/제어 레지스터 주소이고 하나는 데이터 레지스터 주소이다. 사실 상태레지스터와 제어 레지스터로 분리되어있지만 상태 레지스터의 값은 읽기만 하면되고 제어 레지스터에는 쓰기만 하면 되기때문에 하나의 주소로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;그리고 I/O 레지스터들에 주소를 지정하는 방식에는 크게 두 가지가 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 기억장치 사상 I/O&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 방식에서는 메모리와 I/O 레지스터들을 동일하게 취급하고 I/O 레지스터들에 메모리의 주소영역 일부를 할당한다. 이후부터는 I/O 레지스터들에 메모리와 동일한 방식으로 액세스 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/memory_mapped_io.png&quot; alt=&quot;memory_mapped_io&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 주소 비트가 10비트라면 1024개의 주소를 지정할 수 있다. 따라서 0번지부터 511번지까지는 메모리에 할당되고 512번지부터 1023번지까지는 I/O장치에 할당된다. 따라서 메모리에 할당할 수 있는 주소 번지의 수가 절반으로 줄어든다는 단점이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b)분리형 I/O&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I/O 레지스터들의 주소가 메모리와는 별도로 할당된다. 그리고 I/O 레지스터들에 액세스 할 때는 메모리와 별도의 명령어(어셈블리어)를 사용한다. 그리고 이러한 명령어들이 수행될 때는 메모리에 대한 것인지 I/O 장치에 대한 것인지를 구분하기 위한 신호(I/O읽기, I/O쓰기)가 CPU로부터 발생되어야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/isolated_io.png&quot; alt=&quot;isolated_io&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 방식은 메모리와 I/O의 주소를 별도로 지정하므로 10비트를 가지고 메모리와 I/O 레지스터들 각각에 1024개의 주소를 할당할 수 있다. 그러나 명령어를 별도로 사용해야 하기때문에 프로그래밍이 불편해지는 단점이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-인터럽트를-이용한-io&quot;&gt;4. 인터럽트를 이용한 I/O&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;앞에서 설명한 I/O장치 제어 방식은 폴링(polling)이라 부른다. CPU가 주기적으로 I/O 상태 레지스터의 값을 확인하고 동작에 계속 관여해야한다. 따라서 CPU 시간이 낭비된다. 특히 속도가 느린 I/O 장치일수록 대기시간이 길어져 낭비가 더욱 심해진다.&lt;/p&gt;

&lt;p&gt;그러나 인터럽트(interrupt) 방식을 사용하면 I/O 동작이 수행되는 동안 CPU는 다른 일을 처리할 수 있다. 아래는 인터럽트에 의한 프린터 I/O 동작 순서이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/printer_interrupt_example.png&quot; alt=&quot;printer_interrupt_example&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU가 I/O제어기로 인터럽트 요구를 보내놓고 다른일을 처리하면 I/O동작이 수행되고 완료가 되면 다시 CPU로 인터럽트 신호를 보낸다. CPU는 인터럽트 신호를 보고 동작 수행의 완료를 알 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
컴퓨터 시스템에는 여러개의 I/O 장치가 접속되어있다. 만약 여러개의 I/O 동작이 완료되고 CPU로 동시에 인터럽트 신호를 통해 완료보고를 보낼경우 어떤 서비스부터 처리할 것인지 결정해야 한다. 여기에는 여러가지 방법이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 다중 인터럽트 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각각의 I/O 제어기마다 CPU와의 사이에 인터럽트 요구신호선(INTR)과 인터럽트 확인 신호선(INTA)이 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/multi_interrupt_io.png&quot; alt=&quot;multi_interrupt_io&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두개 이상의 I/O장치들이 동시에 인터럽트 요구 신호를 보내면 우선순위에 따라 인터럽트 확인 신호를 보내고 서비스 루틴을 수행한다.&lt;/p&gt;

&lt;p&gt;만약 인터럽트 플래그(interrupt flag)가 disable 상태라면 인터럽트 서비스 루틴을 처리하는 도중에는 다른 인터럽트 요구를 무시하지만 enable 상태라면 더 높은 우선순위를 가진 인터럽트가 들어오면 현재 실행중인 루틴을 중지하고 높은 우선순위의 인터럽트 서비스 루틴으로 이동한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) 데이지 체인 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 방식에서는 INTR 신호선이 하나만 있다. 또한 INTA 출력선은 CPU와 가장 가까운 제어기로만 입력된다. INTA 신호는 계속해서 다음 제어기들로 직렬로 연결된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/daisy_chain_interrupt_io.png&quot; alt=&quot;daisy_chain_interrupt_io&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 때 하나 이상의 INTR 신호가 세트되면 CPU는 INTA 신호를 가장 가까운 제어기로 보낸다. 만약 이 제어기가 INTR 신호를 세트한 상태라면 데이터 버스를 통해 자신의 ID를 CPU로 보낸다. 이 ID를 인터럽트 벡터(interrupt vector)라고 부르는데 CPU가 해당 I/O장치를 위한 인터럽트 서비스 루틴의 시작 주소를 찾는데 사용된다.&lt;/p&gt;

&lt;p&gt;첫 번째 제어기가 INTR을 세트한 상태가 아니라면 INTA 신호는 바로 다음 제어기로 넘어간다. 이 과정은 INTR을 세트시킨 제어기를 찾을 때 까지 반복된다.&lt;/p&gt;

&lt;p&gt;이 과정으로 인터럽트를 하나 처리하고 남아있는 인터럽트가 있다면 여전히 INTR 신호선의 상태는 세트일 것이기 때문에 CPU는 곧바로 INTA 신호를 다시 내보낸다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(c) 소프트웨어 폴링 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 방식에서는 공동의 INTR 신호 하나만 사용한다. 그리고 TEST I/O선이 CPU와 모든 제어기 사이에 연결되어 있다. 모든 제어기는 인터럽트 플래그가 있는데, TEST I/O 선은 제어기의 인터럽트 플래그가 세트 되었는지 검사하기위해 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/software_polling_interrupt_io.png&quot; alt=&quot;software_polling_interrupt_io&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 개 이상의 제어기가 인터럽트 플래그를 세트시키면 INTR 신호선의 상태가 세트 된다. 그러면 CPU는 TEST I/O선을 통해 순서대로 제어기들의 인터럽트 플래그를 검사한다. 인터럽트 플래그가 세트된 제어기를 발견하면 해당 인터럽트 서비스 루틴을 수행한다.&lt;/p&gt;

&lt;p&gt;인터럽트 플래그를 검사하는 과정에서 마이크로프로그램을 사용하기 때문에 소프트웨어 폴링 방식이라 부른다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-dma를-이용한-io&quot;&gt;5. DMA를 이용한 I/O&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;인터럽트 I/O 방식은 폴링 I/O 방식보다 효율적이지만 여전히 읽기/쓰기 과정에서 I/O 장치와 메모리 사이에서 데이터가 이동할 때 CPU를 경유해야 하는 문제점이 존재한다. 특히 이동해야 할 데이터 블록이 크다면 CPU의 시간 소요가 더 길어진다.&lt;/p&gt;

&lt;p&gt;직접 기억장치 액세스(Direct Memory Access : DMA)는 이러한 문제점을 해결하기 위해 개발되었다. DMA 방식을 사용하면 메모리와 I/O장치 사이에 직접 데이터 전송이 이루어질 수 있다.&lt;/p&gt;

&lt;p&gt;DMA를 사용하기 위해서는 내부 시스템버스에 DMA 제어기가 포함되어야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/systembus_with_dma_controller.png&quot; alt=&quot;systembus_with_dma_controller&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메모리와 I/O장치 사이에 데이터 전송이 필요한 경우 CPU는 DMA 제어기에 아래의 정보가 포함된 명령을 보낸다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) I/O장치 주소
(b) 쓰기 혹은 읽기 지정자
(c) 데이터가 읽혀지거나 쓰여질 메모리의 시작 주소
(d) 전송될 데이터 단어들의 개수
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CPU는 명령을 DMA 제어기에 보낸 후 다른일을 한다.&lt;/p&gt;

&lt;p&gt;DMA는 한 번에 데이터를 한 개씩 보낸다. 워드가 1바이트이고 총 보내야할 데이터가 1kB라면 1024개의 데이터 전송이 필요하다. 그런데 하나의 데이터를 전송할 때 I/O장치와 한 번 액세스, 메모리와 한 번 액세스 해야하기 때문에 총 1kB 전송을 위해 총 2048번의 버스 점유가 필요하다. 이때문에 성능 이슈가 발생할 수 있다. 이러한 문제를 개선하기 위해 아래와 같은 방식을 고려할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/systembus_with_dma_controller2.png&quot; alt=&quot;systembus_with_dma_controller2&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 하면 메모리 액세스를 할 때만 버스를 점유하므로 점유시간이 절반으로 줄어든다. 그러나 이런 방식을 사용하면 DMA 제어기에 접속할 수 있는 I/O제어기가 한계가 있기때문에 여러개의 DMA 제어기가 필요하다. 이를 개선하기 위한 시스템이 아래 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/systembus_with_dma_controller3.png&quot; alt=&quot;systembus_with_dma_controller3&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DMA 제어기와 I/O 장치들 간에 별도의 버스를 두었다. 하지만 이렇게 해도 매우 다양한 종류의 I/O 장치들을 지원하기에는 한계가 있다. 또한 디스크의 경우 블록 단위가 크므로(ex. 512바이트) 이 데이터를 임시저장하기 위한 버퍼까지 필요하게 된다.&lt;/p&gt;

&lt;p&gt;이러한 이슈를 해결하기 위해 최근 고성능 컴퓨터들은 DMA 제어기를 확장시킨 I/O 프로세서 라는것을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/7/systembus_with_io_processor.png&quot; alt=&quot;systembus_with_io_processor&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I/O 프로세서는 I/O를 제어하기 위한 프로그램을 실행하며 큰 크기의 데이터 블록 저장을 위한 버퍼를 가지고 있다. 또한 시스템 버스 사용을 위한 버스 마스터 회로와 I/O 버스 인터페이스를 가지고 있으며 I/O장치들간의 중재를 위한 기능을 한다.&lt;/p&gt;

&lt;p&gt;I/O 프로세스가 개발됨으로써 CPU가 I/O 동작 수행의 부담에서 벗어날 수 있었다.&lt;/p&gt;</content><author><name>nobbaggu</name></author><category term="버스" /><category term="버스 중재" /><category term="인터럽트" /><category term="DMA" /><summary type="html">목차 시스템 버스 버스 중재 I/O장치의 접속 인터럽트를 이용한 I/O DMA를 이용한 I/O 0. Intro 이번 챕터에서는 CPU, 메모리, 보조저장장치 및 I/O장치들을 서로 접속할 수 있게 해주는 시스템 버스와 그 매커니즘, 그리고 시스템 버스의 성능 향상을 위해 사용되는 직접 메모리 액세스(DMA)에 대해 알아본다. 1. 시스템 버스 시스템 버스는 컴퓨터를 구성하는 요소들 사이에 데이터 전송을 할 수 있는 통로이다. (1) 시스템 버스 조직 컴퓨터를 구성하는 요소들은 시스템 버스를 통해 프로그램 코드, 데이터, 제어명령 등을 교환하며 CPU가 클록 신호를 여기로 내보낸다. 물리적으로 전기신호를 전송하므로 도체로 된 선들로 만들어진다. 선들의 수는 CPU가 발생시키는 주소 비트 수, 워드, 제어 신호의 수에 따라 결정된다. 2챕터에서 말했듯이 시스템 버스는 크게 세 가지로 구분된다. (a) 데이터 버스(data bus) 시스템 사이의 데이터 전송을 위한 버스이다. 워드(word), 즉 CPU가 한 번에 처리하는 비트 수만큼의 버스선이 필요하다. 데이터는 CPU와 메모리, I/O장치들 사이 양방향으로 발생하므로 데이터 버스는 양방향(bidirectional) 전송을 지원할 수 있어야한다. (b) 주소 버스(address bus) CPU가 메모리, 기타 I/O 장치들에 쓰기/읽기를 할 때 메모리의 주소지정을 위한 버스이다. 주소는 CPU가 발생시키기 때문에 주소 버스는 단방향(unidirectional) 전송통로이다. (c) 제어 버스(control bus) 기억장치 및 I/O장치에 대한 쓰기/읽기 신호들을 내보내는 버스이다. 시스템 버스의 사용 주체가 되는 요소를 버스 마스터(bus master)라고 한다. CPU 및 I/O장치의 제어기등이 버스 마스터가 될 수 있다. 동기식 버스(synchronous)에서는 메모리 역시 버스 마스터가 될 수 있다. 시스템 버스는 모든 요소들이 공유하는 자원이며 한 번에 하나의 버스 마스터만 버스를 점유할 수 있다. 여러 마스터들이 동시에 버스를 사용하고자 하면 순서를 지정해주는 버스 중재(bus arbitration)가 일어난다. 버스 중재를 위해서는 아래의 제어 신호들이 필요하다. (a) 버스 요구(bus request) : 버스 마스터의 버스 사용 요구 (b) 버스 승인(bus grant) : 버스 마스터에게 버스 사용 허가 (c) 버스 사용중(bus busy) : 다른 마스터에 의해 버스 사용중 버스 중재를 위한 신호선들의 집합을 버스 중재 버스라고 따로 구분하기도 한다. 버스 중재에 대해서는 잠시 후에 자세히 설명한다. 키보드, 마우스등은 비동기식으로 인터럽트를 통해 동작한다. 명령어 인출-실행 단계가 끝나면 I/O장치 제어기들의 인터럽트 비트 레지스터를 확인하여 인터럽트 요구가 있으면 이를 처리한다. 이처럼 인터럽트 메커니즘에는 아래의 두 신호가 필요하다. (a) 인터럽트 요구(interrupt request) : I/O 디바이스의 인터럽트 요구를 나타낸다. (b) 인터럽트 확인(interrupt aknowledge) : CPU가 I/O 디바이스의 인터럽트 요구를 인식했다는 것을 나타낸다. 이 신호들을 위한 버스들을 별도로 인터럽트 버스라고 부르기도 한다. 이외에도 제어신호에는 동기식 버스에서 버스 동작 시간을 일치시키기 위한 공통 클록 신호, 모든 시스템 요소들을 초기화시키는 리셋(reset) 신호가 있다. (2) 시스템 버스의 기본 동작 버스 상의 모든 동작은 쓰기 동작 혹은 읽기 동작 중 하나로 구분된다. (a) 쓰기 : 버스 마스터 사용권한 획득 -&amp;gt; 주소, 데이터, 쓰기신호 전송 (b) 읽기 : 버스 마스터 사용권환 획득 -&amp;gt; 주소, 읽기 신호 전송 -&amp;gt; 데이터가 올 때 까지 대기 (a) 동기식 버스(synchronous bus) 시간이 버스 클록을 기준으로 모든 버스 동작이 발생한다. 아래는 동기식 버스에서 CPU가 메모리로부터 데이터를 읽어오는 과정을 나타낸 타이밍도이다. 버스 동작의 시작 신호를 기준으로 동작이 발생한다. 첫 번째 주기에서 읽기신호와 주소를 내보낸다. 두 번째 주기동안에는 데이터가 인출되어 세 번재 주기에 인출된 데이터가 전송된다. 메모리는 데이터와 함께 확인 신호를 보낸다. CPU는 확인신호를 보고 버스에 요청한 데이터가 실려있다는 것을 알고 데이터를 받는다. 동기식 버스는 회로가 간단하다. 그러나 동시에 발생하는 동작들 중 가장 오래 걸리는 동작이 끝날 때까지 기다려야 한다. (b) 비동기식 버스(asynchronous bus) 버스 동작 발생이 다른 버스 동작의 발생 여부에 따라 결정된다. 아래는 비동기식 버스의 경우 CPU가 메모리로부터 데이터를 읽어오는 과정을 나타낸 타이밍도이다. 여기에는 클록 신호를 사용하지 않는다. 먼저 CPU가 버스로 주소와 읽기 신호를 보낸다. 신호가 안정될 때 까지 기다린 후 주소와 제어 신호를 보냈음을 알리기 위한 마스터 동기 신호(Master Synch Signal : MSYN)를 보낸다. 메모리는 MYSN을 보고 주소 버스와 제어 버스를 확인 후 메모리의 해당 주소에서 데이터를 인출하여 버스에 싣는다. 이후 슬레이브 동기 신호(Slave Synch Signal : SSYN)를 보낸다. 그럼 CPU가 SSYN을 확인하고 데이터 버스로부터 데이터를 가져간다. 데이터를 다 가져가고 난 후 MSYN와 읽기신호, 주소신호를 제거한다. 이후 메모리는 MYSN가 제거된 것을 보고 SSYN 신호를 제거한다. 비동기식 버스에서는 동작이 완료되고 나면 바로 다음 동작이 발생되므로 시간낭비가 없다. 그러나 위와같은 동작에 필요한 인터페이스 회로가 복잡하다. 2. 버스 중재 여러 버스마스터들이 버스 사용을 요구하는 경우 버스 경합(bus contention)이 발생한다. 버스 경합이 발생하면 이들의 순서를 결정해주는 버스 중재(bus arbitration)을 해주어야 한다. 버스 중재를 해주는 모듈을 버스 중재기라고 한다. 버스 중재 방식은 시스템 성능에 큰 영향을 미치기 때문에 버스 시스템의 특성에 따라 알맞게 설계해야한다. 여러 버스마스터 중 중요도가 높은 마스터에게 우선적으로 권한을 부여해야한다. 또한 중요한 것은 어떤 버스 마스터가 오랫동안 버스를 사용하지 못하는 버스 기근(bus starvation)이 발생하지 않도록 해야한다. 버스 중재 방식은 제어 신호들의 연결구조에 따라 두 가지로 분류될 수 있다. (a) 병렬 중재 방식 (b) 직렬 중재 방식 병렬 중재 방식에서는 각각의 버스 마스터의 버스 요구 신호 및 버스 승인 신호가 버스 중재기와 연결되어 있다. 즉 각각의 버스 카스터가 독립적으로 신호를 발생시킨다. 직렬 중재 방식에서는 버스 요구 신호 및 버스 승인 신호 선이 한 개씩만 있고 각각 버스 마스터들과 직렬로 연결된다. 접속되는 순서에 따라 우선순위가 결정된다. 버스 중재기의 위치에 따른 분류도 존재한다. (a) 중앙집중식 중재 방식 (b) 분산식 중재 방식 중앙집중식 방식에서는 버스 중재기가 시스탬에 단 한 개만 존재하며 모든 버스 중재가 이 중재기에 의해 이루어진다. 여러 버스 마스터들이 버스 요구 신호를 보내면 중재기가 규칙에 따라 하나의 버스 마스터에게만 버스 승인 신호를 보낸다. 분산식 중재 방식에서는 여러개의 중재기가 존재하며 일반적으로 각각의 버스 마스터가 하나의 중재기를 가진다. 각 마스터는 각각의 중재기에 의해 중재된다. 위의 중재 방식들을 적절히 조합하면 다양한 중재 방식을 구성할 수 있다. 이제 여러 대표적인 중재 방식의 구성을 살펴본다. (1) 병렬 중재 방식 (a) 중앙집중식 고정 우선순위 방식 고정 우선순위는 각 버스 마스터에 지정된 우선순위가 변하지 않는 방식이다. 아래 그림은 중앙집중식 고정 우선순위 방식의 회로 구성도이다. 버스마스터 1부터 4까지 차례로 높은 우선순위를 가진다고 가정한다. 병렬 중재방식이므로 각각의 버스 마스터가 버스 요구선(BREQ)과 버스 승인선(BGNT)을 가지고 있다. 또한 중앙집중식이기 때문에 버스 중재기 하나가 모든 마스터에 대해 버스중재를 한다. 여러 버스요구가 동시에 중재기로 들어오면 고정된 우선순위가 가장 높은 마스터에게 버스 승인 신호를 보낸다. BBUSY 신호는 active-low 신호로 0이면 버스가 사용중임을 나타낸다. 버스 승인 권한을 받은 제어기는 BBUSY 신호가 0이면 기다렸다가 1이 되면 사용을 시작한다. 버스 마스터는 버스를 사용하기 전에 BBUSY신호를 0으로 만들어 다른 버스가 사용하지 못하도록 막는다. 아래 그림은 버스마스터 1이 버스를 사용하고있는 중에 버스마스터 3이 버스 요구신호를 보내는 예시이다. 버스마스터3이 BREQ3 신호를 1로 세트 ↓ 중재기가 BGNT3을 1로 세트하여 버스 사용 허가 ↓ 버스마스터1의 사용이 끝나 BBUSY 신호를 1로 해제 ↓ 버스마스터3이 BBUSY신호가 1인걸 확인하고 다시 0으로 활성화시킨 후 버스 사용 시작 위 그림에서 우선순위를 설정하기 위한 중재기의 회로는 아래 그림과 같다. 우선순위가 낮은 마스터의 요구신호는 더 높은 마스터들의 요구신호들의 반전(NOT) 신호와함께 AND 게이트로 들어간다. (b) 분산식 고정 우선순위 방식 이 방식에서는 버스 마스터들이 각각 중재기를 하나씩 가진다. 마스터1,2,3,4가 차례대로 높은 우선순위를 가진다. 각 중재기는 자신보다 높은 우선순위를 가진 마스터들의 버스 요구신호의 반전(NOT)을 입력으로 받기 때문에 더 높은 우선순위인 어떤 마스터의 요구신호도 없을 경우만 자신의 승인 신호를 1로 세트한다. 버스 승인을 받은 마스터는 BBUSY 신호를 검사하여 다른 마스터가 사용중이지 않을 경우에만 버스 사용을 시작한다. 분산식 방식은 중앙집중식 방식에 비해 중재 회로가 간단하고 속도가 빠르다는 장점이 있다. 그러나 고장이 났을 경우 시스템 동작에 영향을 줄 수 있다. 가령 버스 승인 신호를 잘못 발생시켜 두 버스마스터가 동시에 버스를 사용하는 일이 발생할 수 있다. (c) 가변 우선순위 방식 가변 우선순위 방식에서는 시스템의 상태나 조건에 따라 버스 마스터들에 지정된 우선순위가 계속해서 변하는 방식이다. 우선순위가 높은 마스터의 버스 독점이나 우선순위가 낮은 마스터의 버스 기근을 방지하기 용이하다. 가변적인 우선순위를 부여하는 알고리즘에는 여러 종류가 있다. (a) 회전 우선순위 - 중재 동작이 끝나면 모든 마스터들의 우선순위가 1단계씩 낮아지며 가장 낮은 우선순위였던 마스터가 최상위 우선순위를 가지게 하는 방법 혹은 - 버스 사용 승인을 받은 마스터를 최하위 우선순위로 보내고 다음 위치의 마스터부터 차례로 상위 우선순위를 부여하는 방법 (b) 임의 우선순위 버스 중재가 끝나면 말 그대로 랜덤으로 우선순위를 부여한다. (c) 동등 우선순위 비동기식 버스에서 사용될 수 있는 방식으로 모든 버스마스터들이 동등한 우선순위를 가진다. 만약 두 개 이상의 버스 요구 신호가 도착하면 중재기는 충돌이 일어나지 않게 중재하는데, 일반적으로 먼저 도착한 요구부터 승인하는 FIFO 방식을 사용한다. (d) 최소-최근 사용 더 오랫동안 버스를 사용하지 않은 마스터부터 최상위 우선순위를 부여한다. (2) 직렬 중재 방식 (a) 중앙집중식 직렬 중재 방식 직렬 중재방식에서는 모든 버스마스터의 요구신호선과 승인신호선이 각각 하나의 공통신호선을 통하여 중재기로 들어간다. 중앙집중식 직렬중재에서는 중재기에 가까운 버스마스터의 우선순위가 높아진다. 위 그림에서는 중재기로 어떤 요구신호가 들어오더라도 가장 가까운 버스마스터에 버스 승인 신호를 보낸다. 그 마스터가 버스 요구신호를 발생시키지 않았다면 다음 마스터로 버스 승인 신호를 보낸다. 이렇게 버스 요구 신호가 세트되어있는 마스터들 중 최상위 우선순위의 마스터에게 승인신호가 전달되면 해당 마스터에 의해 버스 사용이 시작된다. 이 방식에서도 BBUSY 신호가 해제될 때 까지 기다렸다가 버스사용이 시작된다. (b) 분산식 직렬 중재 방식 분산식 직렬 중재방식에서는 아래 그림과 같이 데이지체인 버스 승인 신호(daisy-chain bus grant signal : DBGNT)선이 버스 중재기들을 순환형으로 접속해있도록 구성된다. 어떤 버스마스터가 사용을 시작하는 순간 DBGNT신호를 우측 마스터로 넘긴다. 해당 마스터의 버스요구신호가 세트되어있으면 중재기가 버스 승인 신호를 해당 마스터로 보낸다. 그러나 버스 요구신호가 없다면 오른쪽 버스 마스터로 DBGNT 신호를 넘겨준다. 이 방식에서는 우선순위가 계속 변한다. 현재 버스를 사용주인 버스 마스터의 오른쪽으로 가장 가까이 위치한 버스마스터들 중 버스 요구신호를 발생시킨 마스터가 최상위 우선순위를 가지게 된다. 중재기가 버스 승인신호를 버스 마스터로 보내더라도 버스 마스터는 BBUSY 비트가 해제된 후 버스 사용을 시작하게 된다. (3) 폴링 방식 폴링 방식은 버스 중재기가 버스 마스터들의 요구신호를 주기적으로 검사하여 버스 사용 승인 여부를 결정한다. 폴링 순서와 중재 동작이 모두 회로로 구현되어있는 하드웨어 폴링 방식과 소프트웨어를 활용하여 코드로 구현한 소프트웨어 폴링 방식이 존재한다. (a) 하드웨어 폴링 버스 중재기와 마스터들 사이에 폴링을 위한 폴링선들이 존재한다. 중재기가 폴링 주소를 발생하여 검사할 마스터를 지정한 후 버스 사용을 원하는지 검사한다 ↓ 지정된 마스터가 버스 사용을 원하는 경우 BREQ 신호를 세트한다 ↓ BREQ 신호를 세트한 버스마스터에게 버스 사용을 승인한다. 그렇지 않으면 다음 마스터를 검사한다 이 방식에서 우선순위는 중재기가 버스마스터들을 검사하는 순서이다. 마스터가 버스 사용을 시작하면 BBUSY 신호가 세트되고 폴링 동작이 중지된다. 이후 버스 사용이 완료되고 BBUSY 신호가 해제되면 다시 폴링을 시작한다. 이 때 사용이 완료된 마스터의 다음 마스터부터 검사하도록 하는 회전 우선순위 방식을 사용할 수도 있고 다시 처음 마스터부터 폴링을 시작하는 고정 우선순위 방식을 사용할 수도 있다. (b) 소프트웨어 폴링 소프트웨어 폴링 방식을 위한 회로는 하드웨어 폴링 방식과 동일하다. 그러나 버스 중재기가 프로그램을 실행할 수 있는 프로세서를 가지고 있다. 따라서 하드웨어 폴링방식처럼 하드웨어로 인한 일률적인 중재가 아닌 융통성있는 중재가 가능하다. 중재기의 프로그램은 다음 폴링 순서를 유연하게 결정하는데 사용되거나 혹은 고장이 발생한 버스 마스터를 폴링에서 제외시킬 수도 있다. 다만 하드웨어 폴링방식에 비해 속도가 느리다는 단점이 존재한다. 3. I/O 장치의 접속 I/O 장치는 CPU와 메모리(주기억장치) 이외의 모든 장치이다. 여기서는 I/O 장치들의 제어방법 및 주소지정 방법에 대해 알아본다. (1) I/O 제어 I/O 장치들은 종류가 매우 다양하며 일일이 모든 제어 회로를 CPU내부에 포함시키지 못한다. 이외에도 데이터 전송속도 차이의 문제나 데이터 형식의 차이로 인해 시스템 버스에 직접 접속되지 못한다. 이를 위해 CPU와 I/O 장치 사이에서 인터페이스 역할을 수행해주는 제어기가 필요하다. 이를 I/O 제어기라 한다. I/O 제어기는 I/O장치 제어, CPU 혹은 메모리와 I/O 사이의 통신, 데이터 버퍼링, 오류 검출 등의 기능을 수행한다. 일반적으로 각 I/O장치를 위한 별도의 제어기가 시스템 버스와 I/O장치 사이의 인터페이스를 담당하도록 되어있다. 예시를 위해 프린터 출력의 경우를 보자. (a) CPU가 프린터 제어기의 상태 레지스터의 출력준비 비트(RDY bit)가 세트 되어있는지 검사한다. (b) 프린터 제어기가 CPU에 검사결과를 전송한다. (c) 준비가 되어있다면 출력할 데이터와 출력 명령 신호를 프린터 제어기로 전송한다. (d) 프린터 제어기가 출력할 데이터와 제어신호를 프린터로 보낸다. 위와 같이 CPU는 I/O 장치의 프로세서와 통신하며 I/O장치는 I/O 제어기에 의해 동작된다. (2) I/O 주소지정 위에서 설명한 내용의 요점은 CPU는 I/O 장치를 직접 제어할 필요 없이 I/O 제어기의 레지스터 값을 읽거나 레지스터에 명령할 내용을 쓰기만 하면된다. 나머지는 I/O 제어기가 알아서 한다. CPU가 I/O장치를 사용하려면 데이터를 주고받을 주소를 지정해야한다. I/O 장치별로 두 개씩의 주소가 지정된다. 하나는 상태/제어 레지스터 주소이고 하나는 데이터 레지스터 주소이다. 사실 상태레지스터와 제어 레지스터로 분리되어있지만 상태 레지스터의 값은 읽기만 하면되고 제어 레지스터에는 쓰기만 하면 되기때문에 하나의 주소로 사용할 수 있다. 그리고 I/O 레지스터들에 주소를 지정하는 방식에는 크게 두 가지가 있다. (a) 기억장치 사상 I/O 이 방식에서는 메모리와 I/O 레지스터들을 동일하게 취급하고 I/O 레지스터들에 메모리의 주소영역 일부를 할당한다. 이후부터는 I/O 레지스터들에 메모리와 동일한 방식으로 액세스 할 수 있다. 만약 주소 비트가 10비트라면 1024개의 주소를 지정할 수 있다. 따라서 0번지부터 511번지까지는 메모리에 할당되고 512번지부터 1023번지까지는 I/O장치에 할당된다. 따라서 메모리에 할당할 수 있는 주소 번지의 수가 절반으로 줄어든다는 단점이 존재한다. (b)분리형 I/O I/O 레지스터들의 주소가 메모리와는 별도로 할당된다. 그리고 I/O 레지스터들에 액세스 할 때는 메모리와 별도의 명령어(어셈블리어)를 사용한다. 그리고 이러한 명령어들이 수행될 때는 메모리에 대한 것인지 I/O 장치에 대한 것인지를 구분하기 위한 신호(I/O읽기, I/O쓰기)가 CPU로부터 발생되어야한다. 이 방식은 메모리와 I/O의 주소를 별도로 지정하므로 10비트를 가지고 메모리와 I/O 레지스터들 각각에 1024개의 주소를 할당할 수 있다. 그러나 명령어를 별도로 사용해야 하기때문에 프로그래밍이 불편해지는 단점이 존재한다. 4. 인터럽트를 이용한 I/O 앞에서 설명한 I/O장치 제어 방식은 폴링(polling)이라 부른다. CPU가 주기적으로 I/O 상태 레지스터의 값을 확인하고 동작에 계속 관여해야한다. 따라서 CPU 시간이 낭비된다. 특히 속도가 느린 I/O 장치일수록 대기시간이 길어져 낭비가 더욱 심해진다. 그러나 인터럽트(interrupt) 방식을 사용하면 I/O 동작이 수행되는 동안 CPU는 다른 일을 처리할 수 있다. 아래는 인터럽트에 의한 프린터 I/O 동작 순서이다. CPU가 I/O제어기로 인터럽트 요구를 보내놓고 다른일을 처리하면 I/O동작이 수행되고 완료가 되면 다시 CPU로 인터럽트 신호를 보낸다. CPU는 인터럽트 신호를 보고 동작 수행의 완료를 알 수 있다. 컴퓨터 시스템에는 여러개의 I/O 장치가 접속되어있다. 만약 여러개의 I/O 동작이 완료되고 CPU로 동시에 인터럽트 신호를 통해 완료보고를 보낼경우 어떤 서비스부터 처리할 것인지 결정해야 한다. 여기에는 여러가지 방법이 있다. (a) 다중 인터럽트 방식 각각의 I/O 제어기마다 CPU와의 사이에 인터럽트 요구신호선(INTR)과 인터럽트 확인 신호선(INTA)이 있다. 두개 이상의 I/O장치들이 동시에 인터럽트 요구 신호를 보내면 우선순위에 따라 인터럽트 확인 신호를 보내고 서비스 루틴을 수행한다. 만약 인터럽트 플래그(interrupt flag)가 disable 상태라면 인터럽트 서비스 루틴을 처리하는 도중에는 다른 인터럽트 요구를 무시하지만 enable 상태라면 더 높은 우선순위를 가진 인터럽트가 들어오면 현재 실행중인 루틴을 중지하고 높은 우선순위의 인터럽트 서비스 루틴으로 이동한다. (b) 데이지 체인 방식 이 방식에서는 INTR 신호선이 하나만 있다. 또한 INTA 출력선은 CPU와 가장 가까운 제어기로만 입력된다. INTA 신호는 계속해서 다음 제어기들로 직렬로 연결된다. 이 때 하나 이상의 INTR 신호가 세트되면 CPU는 INTA 신호를 가장 가까운 제어기로 보낸다. 만약 이 제어기가 INTR 신호를 세트한 상태라면 데이터 버스를 통해 자신의 ID를 CPU로 보낸다. 이 ID를 인터럽트 벡터(interrupt vector)라고 부르는데 CPU가 해당 I/O장치를 위한 인터럽트 서비스 루틴의 시작 주소를 찾는데 사용된다. 첫 번째 제어기가 INTR을 세트한 상태가 아니라면 INTA 신호는 바로 다음 제어기로 넘어간다. 이 과정은 INTR을 세트시킨 제어기를 찾을 때 까지 반복된다. 이 과정으로 인터럽트를 하나 처리하고 남아있는 인터럽트가 있다면 여전히 INTR 신호선의 상태는 세트일 것이기 때문에 CPU는 곧바로 INTA 신호를 다시 내보낸다. (c) 소프트웨어 폴링 방식 이 방식에서는 공동의 INTR 신호 하나만 사용한다. 그리고 TEST I/O선이 CPU와 모든 제어기 사이에 연결되어 있다. 모든 제어기는 인터럽트 플래그가 있는데, TEST I/O 선은 제어기의 인터럽트 플래그가 세트 되었는지 검사하기위해 사용된다. 한 개 이상의 제어기가 인터럽트 플래그를 세트시키면 INTR 신호선의 상태가 세트 된다. 그러면 CPU는 TEST I/O선을 통해 순서대로 제어기들의 인터럽트 플래그를 검사한다. 인터럽트 플래그가 세트된 제어기를 발견하면 해당 인터럽트 서비스 루틴을 수행한다. 인터럽트 플래그를 검사하는 과정에서 마이크로프로그램을 사용하기 때문에 소프트웨어 폴링 방식이라 부른다. 5. DMA를 이용한 I/O 인터럽트 I/O 방식은 폴링 I/O 방식보다 효율적이지만 여전히 읽기/쓰기 과정에서 I/O 장치와 메모리 사이에서 데이터가 이동할 때 CPU를 경유해야 하는 문제점이 존재한다. 특히 이동해야 할 데이터 블록이 크다면 CPU의 시간 소요가 더 길어진다. 직접 기억장치 액세스(Direct Memory Access : DMA)는 이러한 문제점을 해결하기 위해 개발되었다. DMA 방식을 사용하면 메모리와 I/O장치 사이에 직접 데이터 전송이 이루어질 수 있다. DMA를 사용하기 위해서는 내부 시스템버스에 DMA 제어기가 포함되어야한다. 메모리와 I/O장치 사이에 데이터 전송이 필요한 경우 CPU는 DMA 제어기에 아래의 정보가 포함된 명령을 보낸다. (a) I/O장치 주소 (b) 쓰기 혹은 읽기 지정자 (c) 데이터가 읽혀지거나 쓰여질 메모리의 시작 주소 (d) 전송될 데이터 단어들의 개수 CPU는 명령을 DMA 제어기에 보낸 후 다른일을 한다. DMA는 한 번에 데이터를 한 개씩 보낸다. 워드가 1바이트이고 총 보내야할 데이터가 1kB라면 1024개의 데이터 전송이 필요하다. 그런데 하나의 데이터를 전송할 때 I/O장치와 한 번 액세스, 메모리와 한 번 액세스 해야하기 때문에 총 1kB 전송을 위해 총 2048번의 버스 점유가 필요하다. 이때문에 성능 이슈가 발생할 수 있다. 이러한 문제를 개선하기 위해 아래와 같은 방식을 고려할 수 있다. 이렇게 하면 메모리 액세스를 할 때만 버스를 점유하므로 점유시간이 절반으로 줄어든다. 그러나 이런 방식을 사용하면 DMA 제어기에 접속할 수 있는 I/O제어기가 한계가 있기때문에 여러개의 DMA 제어기가 필요하다. 이를 개선하기 위한 시스템이 아래 그림이다. DMA 제어기와 I/O 장치들 간에 별도의 버스를 두었다. 하지만 이렇게 해도 매우 다양한 종류의 I/O 장치들을 지원하기에는 한계가 있다. 또한 디스크의 경우 블록 단위가 크므로(ex. 512바이트) 이 데이터를 임시저장하기 위한 버퍼까지 필요하게 된다. 이러한 이슈를 해결하기 위해 최근 고성능 컴퓨터들은 DMA 제어기를 확장시킨 I/O 프로세서 라는것을 사용한다. I/O 프로세서는 I/O를 제어하기 위한 프로그램을 실행하며 큰 크기의 데이터 블록 저장을 위한 버퍼를 가지고 있다. 또한 시스템 버스 사용을 위한 버스 마스터 회로와 I/O 버스 인터페이스를 가지고 있으며 I/O장치들간의 중재를 위한 기능을 한다. I/O 프로세스가 개발됨으로써 CPU가 I/O 동작 수행의 부담에서 벗어날 수 있었다.</summary></entry><entry><title type="html">(컴퓨터구조) 6. 보조저장장치</title><link href="http://localhost:4000/2020/03/04/%EB%B3%B4%EC%A1%B0%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98/" rel="alternate" type="text/html" title="(컴퓨터구조) 6. 보조저장장치" /><published>2020-03-04T13:37:19+09:00</published><updated>2020-03-04T13:37:19+09:00</updated><id>http://localhost:4000/2020/03/04/%EB%B3%B4%EC%A1%B0%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98</id><content type="html" xml:base="http://localhost:4000/2020/03/04/%EB%B3%B4%EC%A1%B0%EC%A0%80%EC%9E%A5%EC%9E%A5%EC%B9%98/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;하드 디스크&lt;/li&gt;
  &lt;li&gt;RAID&lt;/li&gt;
  &lt;li&gt;플레시 메모리와 SSD&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-intro&quot;&gt;0. Intro&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;여기에서는 가장 범용적인 하드디스크(HDD)와 RAID 디스크 배열 및 최근 사용이 확대되고있는 플래시 메모리(flash memory)와 SSD(solid-state drive)에 대해 살펴본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-하드-디스크&quot;&gt;1. 하드 디스크&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;하드 디스크의 원래 명칭은 자기적 하드 디스크(magnetic hard disk)이다. 디스크는 자화가 가능한 물질로 코팅된 원형 평판 모양이다. 평판위에 전류가 흐를 수 있는 &lt;strong&gt;트랙(track)&lt;/strong&gt;(동심원 모양)이 여러개 존재하며 데이터들이 여기에 저장된다. &lt;strong&gt;헤드(head)&lt;/strong&gt;라는 전도성 코일을 통해 트랙위에 전류를 흘려 디스크 표면을 자화시킴으로써 데이터를 저장하고 인출 한다. 아래 그림은 디스크의 구조를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/hard_disk_structure.png&quot; alt=&quot;hard_disk_structure&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디스크 쓰기 동작에서는 헤드의 코일에 전류를 흘릴때 나오는 자기장을 통해 자성 패턴을 디스크 표면에 기록한다. 1은 양(+)전류로, 0은 음(-)전류로 변환되어 헤드로 보내진다. 반면 읽기 동작에서는 코일이 트랙위를 지나가면 자기 패턴에서 발생되는 유도전류가 양(+)이면 1, 음(-)이면 0이 인출된다. 단일-헤드 디스크에서는 디스크팔의 길이를 제어해 헤드를 움직여 트랙을 선택하게되는데 이를 위한 디스크 팔과 디스크팔을 구동시키는 구동장치(actuator)가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1) 디스크의 구조&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;디스크의 트랙 동심원들은 물리적으로는 연속적으로 연결되어있지만 논리적으로는 여러개의 섹터(sector)로 구분된다. 디스크에 데이터를 저장하거나 읽는 동작은 블록(block)단위로 이루어지며, 한 섹터의 용량이 블록하나이다. 다시말해 섹터는 디스크에 한 번 액세스동안 읽거나 쓸 수 있는 최소 단위이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/hard_disk_surface.png&quot; alt=&quot;hard_disk_surface&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;트랙 사이의 간격을 트랙간 갭(gap)이라 하며 이는 트랙간의 자기장 간섭을 방지할만큼 충분한 간격이어야한다. 또한 트랙위의 섹터와 섹터 사이를 구분하기 위한 섹터간 갭이 존재한다.&lt;/p&gt;

&lt;p&gt;최근에 개발되는 대용량 디스크들은 약 2천개 이상의 트랙과 64개 이상의 섹터들로 이루어져있다.&lt;/p&gt;

&lt;p&gt;디스크에는 데이터 저장 밀도라는 이슈와 관련하여 크게 두 가지 방식이 존재한다. 아래 그림은 각각의 디스크 표면 구조를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/hard_disk_cav_mzr.png&quot; alt=&quot;hard_disk_cav_mzr&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(a) CAV(Constant Angular Velocity) 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;트랙의 길이는 바깥쪽 동심원일수록 길어진다. CAV 방식에서는 편리성을 위해 트랙당 저장되는 데이터 비트수는 모든 트랙이 같도록 한다. 따라서 안쪽 트랙일수록 데이터 저장 밀도가 높아진다.&lt;/p&gt;

&lt;p&gt;CAV방식에서는 중심부에 가까운 트랙이든 멀리 있는 트랙이든 데이터 액세스를 위한 회전 속도가 일정하다. 그러나 바깥쪽 트랙들의 저장밀도를 가장 안쪽 트랙에 맞추려면 저장밀도를 낮추어야하므로 저장공간이 낭비된다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(b) MZR(Multiple Zone Recording) 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MZR 방식은 CAV 방식의 저장공간 낭비를 줄여 전체 용량을 증가시키는 다중 영역 기록 방식이라는 기술을 사용한다. 여기에서는 디스크 표면이 여러개의 동심원 영역으로 나누어지며 같은 영역의 트랙들은 같은 수의 비트를 저장한다. 결과적으로 바깥 영억의 트랙들이 더 많은 비트들을 저장할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;헤드를 통해 트랙의 데이터에 액세스할때는 각 섹터들을 구분할 방법이 필요하다. 아래 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/track_sector_data_format.png&quot; alt=&quot;track_sector_data_format&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 섹터 용량이 600바이트인 트랙의 데이터 포맷을 나타낸다. 한 섹터에는 섹터를 식별하기 위한 ID필드, 데이터가 저장되는 데이터필드가 있다. 갭1은 섹터의 시작을 나타내며 갭2는 ID필드와 데이터필드 사이를 구분하기 위한 것이다. 또한 갭3은 섹터의 마지막을 나타낸다.&lt;/p&gt;

&lt;p&gt;ID필드는 어떤 트랙의 어떤 섹터인지를 위한 섹터 식별자이다. 여러개의 디스크 평판이 존재하기때문에 평판을 나타내는 헤드번호, 평판위에서 어떤 트랙인지를 결정하는 트랙번호, 그리고 트랙위의 섹터 번호가 존재한다. SYNCH바이트는 ID필드의 시작점을 나타내기 위한 것이고 CRC는 오류검출을 위한 체크섬(checksum)이다.&lt;/p&gt;

&lt;p&gt;515바이트의 데이터 필드에는 필드의 시작을 위한 SYNCH바이트, 그리고 데이터가 포함된다. ID필드와 같이 CRC도 포함하고 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
지금까지 하나의 디스크 평판 구조에 대해 설명했다. 대부분의 디스크는 평판의 양쪽이 모두 자화 물질로 코팅되어 양면을 사용하는 양면 디스크이다. 하드 디스크 드라이브(HDD)는 이러한 평판을 여러개 포함하는 다중 평판 디스크 드라이브이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/hard_disk_drive.png&quot; alt=&quot;hard_disk_drive&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;디스크 드라이브의 각 디스크 표면마다 하나의 헤드가 존재한다. 디스크 팔을 움직임으로써 여러 디스크평판의 같은 위치에 있는 트랙의 데이터에 동시에 접근할 수 있다. 서로 다른 표면에 있지만 동시에 액세스할 수 있는 같은 반경의 트랙들의 집합을 실린더(cylinder)라 부른다. 위 그림의 경우 한 실린더 안에 8개의 트랙이 존재한다. 여기에서 특정 트랙을 선택하기 위해 발생되는 주소에는 실린더 번호, 헤드 번호, 섹터 번호로 이루어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(2) 디스크 액세스 시간&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;디스크의 특정 데이터블록에 액세스하는 과정은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a)헤드를 해당 트랙으로 이동 : 탐색시간
(b)데이터블록이 저장된 섹터가 헤드 아래로 올 때 까지 회전 : 회전 지연시간
(c)데이터 전송 시간
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;데이터에 대한 액세스 시간은 위의 시간들을 모두 합친것이다.&lt;/p&gt;

&lt;p&gt;탐색시간은 기계적인 이동으로 시동시간이 포함된다. 액세스할 데이터들이 가까운 트랙들에 위치하고 있으면 이 시간이 단축된다. 회전 지연시간은 디스크의 회전속도에 좌우된다. 대부분의 HDD는 5400rpm이나 7200rpm의 회전속도를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-raid&quot;&gt;2. RAID&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;디스크의 속도는 주기억장치(메모리)에 비해 10만분의 1 정도밖에 되지않는다. 특히 디스크 입출력이 많이 발생하는 프로그램의 경우 CPU, 메모리와 보조저장장치 사이의 속도 불균형에 의해 성능이 크게 제한될 수 밖에 없다. 또한 CPU와 주기억장치의 발전속도를 따라가지 못하여 그 차이는 더 커질 것으로 예상된다.&lt;/p&gt;

&lt;p&gt;RAID(Redundant Array of Independent Disks)는 작은 디스크 여러개를 배열구조로 연결하여 패키징한 유닛으로 디스크의 액세스 속도를 크게 향상시키면서 신뢰도 또한 높이는 기술이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(1) RAID의 출현 배경&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;디스크의 저장 밀도가 높아짐에따라 비트당 가격이 계속해서 떨어지고 용량이 증가하고있다. 이에따라 하나의 대형디스크보다는 여러개의 소형 디스크를 연결하는것이 저렴한 가격으로 더 큰 용량의 디스크를 구성할 수 있게 해준다. 이렇게하면 용량뿐아니라 프로그램 실행에 직접적인 영향을 주는 속도 문제또한 개선이된다. 속도개선을 위해서는 액세스 시간 단축과 전송시간 단축이 필요하다. 데이터를 다수의 디스크에 분산하여 저장하게되면 여러 디스크들에 대한 동시 액세스와 데이터 병렬 전송이 가능해진다.&lt;/p&gt;

&lt;p&gt;하나의 파일을 구성하는 데이터 블록들을 여러 디스크에 분산 저장하는 기술을 &lt;strong&gt;디스크 인터리빙(disk interleaving)&lt;/strong&gt;이라고 한다. 아래 그림은 16개의 데이터 블록들이 4개의 디스크에 균등하게 분산 저장된 모습을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/disk_interleaving.png&quot; alt=&quot;disk_interleaving&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림과 같이 데이터를 분산저장하면 여러개의 블록에대한 동시 액세스가 가능해지고 하나의 디스크에 집중되는 현상을 줄임으로써 병목현상도 줄일 수 있다. 그러나 디스크들 중 1개만 고장이나도 데이터 파일이 손상된다는 문제점이 있다.&lt;/p&gt;

&lt;p&gt;아래 표는 IBM3390의 대형 디스크와 IBM0061 소형 디스크, 그리고 IBM0061을 배열구조로 연결하여 IBM3390과 동일한 용량을 가지도록한 RAID방식 디스크를 비교한 표이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/disk_comparison.png&quot; alt=&quot;disk_comparison&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;크기, 전력소모, 데이터 전송률, 시간당 입출력 처리, 가격 모든 면에서 RAID 방식이 우수하다. 그러나 RAID방식의 주요 단점은 MTTF(Mean Time To Failure)가 낮다는 것이다. MTTF는 고장이 발생하는 시간 주기의 평균값이다. IBM 3390의 MTTF가 25만 시간이란 것은 평균적으로 25만 시간당 한 번 고장이 발생한다는 의미이다. RAID 방식은 여러 디스크를 연결한 것이므로 여러개 중 한 개만 고장이 나도 전체 디스크의 사용이 불가능해지므로 MTTF가 낮은 것이다.&lt;/p&gt;

&lt;p&gt;디스크 배열의 결함 허용(fault-tolerance)를 높이기 위해 많은 노력들이 있었다. 그 중 하나는 여분의 디스크를 추가해 오류검출 및 데이터 백업을 하는 것이다. 즉, 배열내 하나의 디스크에 결함이 생기면 해당 디스크의 사용이 중지되고 여분의 검사 디스크에 저장된 변경 히스토리를 기반으로 원래의 정보를 재구성하여 여분의 디스크에 저장하게 된다. 복구되는데 소요되는 평균 시간을 MTTR(Mean Time To Repair)라고 한다. 이러한 복구작업은 시스템에 의해 자동으로 일어난다.&lt;/p&gt;

&lt;p&gt;오류검출 및 정정(error detection and correction) 방법에 따라 여러종류의 RAID 조직이 제안되어왔다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(2) RAID의 종류&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) RAID-1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/raid1.png&quot; alt=&quot;raid1&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터를 중복 저장하는 미러 디스크가 존재한다. 디스크 미러링 이라고 한다.&lt;/p&gt;

&lt;p&gt;하나의 디스크에 결함이 발생하면 그 디스크의 모든 데이터가 미러 디스크에 존재하므로 데이터를 잃어버릴 염려가 없게된다. 또한 결함복구 시간이 필요하지 않다.&lt;/p&gt;

&lt;p&gt;데이터 쓰기 동작은 데이터 디스크와 미러 디스크 모두에 대해 수행되어야 한다. 헤드의 위치 차이에 따른 탐색 시간차가 존재할 경우 더 오랜 탐색시간을 요구하는 디스크의 쓰기가 완료되어야 쓰기가 끝난다. 읽기 동작에서는 두 디스크 중 더 짧은 탐색시간과 회전 지연시간을 요구하는 디스크에서 수행하면 된다.&lt;/p&gt;

&lt;p&gt;데이터 디스크를 통체로 미러링하기 위해서 두 배의 디스크가 필요하므로 가격이 높다. 따라서 RAID-1은 높은 신뢰도를 요구하는 시스템에 주로 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) RAID-2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이 구조는 데이터를 비트 단위로 인터리빙 시킨다. 한 단어를 이루는 비트들을 여러 디스크에 분산시켜 저장하는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/raid2.png&quot; alt=&quot;raid2&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;검사 디스크들은 오류검출 및 정정을 위한 패리티 비트들을 저장한다. 즉, 검사디스크들을 추가하고 해밍 코드(Hamming Code)를 사용하면 에러를 검출할 수 있고 심지어 어떤 비트에서 에러가 났는지를 알 수 있다.&lt;/p&gt;

&lt;p&gt;여담이지만 위성신호나 TV와 같은 실시간 디지털 신호에서는 데이터를 받고 에러가 있으면 즉시 정정을 해야하므로 해밍 코드가 유용하다. 다만 필요한 검사 디스크의 수가 데이터 디스크 수의 로그에 비례하므로 가격이 높다. 이러한 이유로 많은 오류가 발생하거나 높은 신뢰도를 요구하는 시스템에서 주로 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) RAID-3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RAID-3은 RAID-2에서 오류 비트의 위치검출을 위한 많은 수의 디스크 사용에 따르는 낭비를 보완하기 위한 것이다. 1개의 패리티 디스크만 추가한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/raid3.png&quot; alt=&quot;raid3&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터 디스크들의 동일한 위치에 있는 비트들에 대한 패리티 비트가 패리티 디스크의 동일한 위치에 저장된다.&lt;/p&gt;

&lt;p&gt;만약 한 디스크에 결함이 발생한다면 해당 비트는 다른 디스크의 비트들과 패리티비트 간의 XOR 연산을 통해 구할 수 있다. 만약 위 그림에서 b1b2b3b4 = 1001이라면 짝수 패리티에서 패리티비트 p=0이 저장된다. 그리고 2번째 디스크가 고장난다면 b2=p XOR b1 XOR b2 XOR b3 = 0 XOR 1 XOR 0 XOR 1 = 0이 된다.&lt;/p&gt;

&lt;p&gt;RAID-3에서는 모든 데이터가 비트단위로 분산 저장되기때문에 데이터 액세스 과정에서 모든 디스크에 병렬적으로 액세스하게된다. 따라서 액세스 시간이 단축되며 병렬 전송에 의해 데이터 전송률도 올라간다. 단점으로는 쓰기 동작마다 패리티비트를 업데이트 해주어야 하기때문에 쓰기 시간이 오래 걸린다. 또한 하나의 데이터 액세스에서 모든 디스크가 사용되므로 한 번에 하나의 요청만 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) RAID-4&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RAID-4에서는 아래 그림과 같이 데이터 블록 단위 디스크 인터리빙을 사용한다. 여기서 패리티 디스크를 하나 추가하여 패리티 블록을 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/raid4.png&quot; alt=&quot;raid4&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;패리티 블록은 각 디스크의 블록을 XOR 연산하여 구할 수 있다.&lt;/p&gt;

&lt;p&gt;그런데 어느 한 디스크의 내용이 변경되면 패리티 블록의 내용이 변경되어야하고 패리티블록의 계산을 위해서는 변경되지않은 나머지 디스크들에 있는 데이터 블록들도 필요하다. 그리고 디스크의 수가 증가될수록 필요한 읽기/쓰기 동작의 수가 증가한다.&lt;/p&gt;

&lt;p&gt;만약 B2의 내용이 B2’로 변경되었다면 패리티블록은 P’ = B1 XOR B2’ XOR B3 XOR B4가 된다. 여기에 조금의 수학적 테크닉을 추가해보자.&lt;/p&gt;

&lt;p&gt;P’ = B1 XOR B2’ XOR B3 XOR B4 XOR (B2 XOR B2) (B2 XOR B2는 0이므로 원래의 식에 영향을 주지않는다.)&lt;/p&gt;

&lt;p&gt;위 식을 정리하면 P’ = B1 XOR B2 XOR B3 XOR B4 XOR (B2 XOR B2’) = P XOR B2 XOR B2’&lt;/p&gt;

&lt;p&gt;새로운 패리티블록의 계산을 위해서는 기존의 P와 B2를 가져오는 2번의 읽기와 B2’와 P’를 쓰는 두 번의 쓰기만 필요로하며 디스크의 수가 늘어나도 일정하다.&lt;/p&gt;

&lt;p&gt;그러나 어떤 디스크에 데이터를 쓸 때마다 패리티 디스크에 두 번씩 액세스 되어야하므로 액세스가 집중되고 이에따른 병목현상이 발생하여 성능저하가 일어난다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) RAID-5&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RAID-5는 RAID-4의 패리티 디스크에 대한 병목현상을 해결하기 위해 고안된 구조이다. 따라서 설계개념은 RAID-4와 동일하고 패리티 블록을 여러 디스크에 분산 저장한다는 점만 다르다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/raid5.png&quot; alt=&quot;raid5&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림처럼 패리티 블록을 분산시켜 RAID-4에서 하나의 패리티 디스크에 몰리던 액세스 요청을 여러 디스크로 분산시켰다. 또한 쓰기 동작이 여러 디스크에 대해 동시에 수행 가능하다는 점이다. B1에 쓰기 위해서는 1, 5번째 디스크에대한 액세스가 필요하고 B7에 쓰기 위해서는 3, 4번째 디스크에 대한 액세스가 필요하다. 따라서 겹치는 부분이 없는 경우 동시 쓰기가 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
현실에서는 주로 RAID-1과 RAID-5가 사용된다. 큰 데이터를 쓰는 경우에는 RAID-1이 미러 디스크까지 2배로 써야하기때문에 성능이 좋지 않지만 작은 데이터를 여러 번 쓰는경우 RAID-5는 매 쓰기마다 4번의 액세스가 필요하여 오버헤드가 증가하게 된다. 또한 가격대비 성능 측면에서는 RAID-5가 더 우수하다. 결론적으로 구성하려는 시스템의 목적에 맞는 방식의 디스크 배열을 선택하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-플래시-메모리와-ssd&quot;&gt;3. 플래시 메모리와 SSD&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;기계적 장치를 많이 포함하는 하드디스크의 속도 한계때문에 새로운 유형의 보조저장장치가 출현하였다. SSD(Solid State Drive)는 반도체로 만들어진 보조저장장치이다. SSD는 EEPROM의 한 종류인 플래시메모리를 사용해서 만든다.&lt;/p&gt;

&lt;p&gt;플래시 메모리(flash memory) 칩들을 배열구조로 패키징하여 만든것이 SSD이다. SSD는 하드디스크에 비하여 속도가 훨씬 빠르다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(1) 플래시 메모리&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;전기적 삭제가 가능한 EEPROM이 개발된 초기에는 1bit를 저장하는 하나의 셀(cell)이 두 개의 트랜지스터로 만들어져 부피가 컸다. 따라서 가격과 저장밀도 면에서 디스크를 대체할 정도로는 부각되지 못했었다.&lt;/p&gt;

&lt;p&gt;그러나 최근 한 개의 트랜지스터를 사용하여 1bit를 저장하면서 전력소모가 낮고 신뢰성도 높은 플래시 메모리가 개발되었다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 동작 원리&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;플래시 메모리에서 하나의 셀(cell)은 NMOS 트랜지스터가 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/flash_memory_cell.png&quot; alt=&quot;flash_memory_cell&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일반적인 NMOS와 다른점은 게이트가 2개라는 것이다. 여기서 부동게이트가 데이터를 저장하는 핵심적인 역할을 수행한다. 부동 게이트는 산화막(이산화규소-SiO2)으로 둘러싸여있어 전자들이 쉽게 통과할 수 없도록 되어있다.&lt;/p&gt;

&lt;p&gt;제어게이트에 5V를 걸어주면 소스와 드레인 사이에 전자가 통과할 수 있는 채널이 형성된다. 그런데 일정수준 이상의 전압(12V)을 걸어주면 채널은 통과하는 전자가 강한 전기장에 의해 산화막을 뚫고 부동게이트로 들어오게 된다. 이를 전자의 터널 주입이라 한다. 인가되었던 전압이 사라지면 부동게이트 안의 전자들은 그대로 갇히게 된다. 이것이 플래시 메모리의 ‘쓰기’ 동작으로 0을 저장한 것이다.&lt;/p&gt;

&lt;p&gt;반대로 정공으로 차있는 p-well쪽에서 강한 전압을 인가하면 부동게이트에 갇혀있던 전자들이 산화막을 통과하여 N채널로 빠져나오게 되어 부동게이트는 비게 된다. 이것이 플레시 메모리의 ‘삭제’ 동작이며 셀을 논리적 1 상태로 만든 것이다.&lt;/p&gt;

&lt;p&gt;읽기 동작을 이해하기 위해 아래 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/flash_memory_read.png&quot; alt=&quot;flash_memory_read&quot; width=&quot;40%&quot; height=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;게이트에 5V전압을 인가하여 N채널을 형성해주고 소스를 접지시키고 드레인에 5V전압을 인가하면 전류가 흐르게된다. 이 때 셀의 부동게이트가 비어있으면(1) 게이트의 5V전압이 p-well의 정공들을 밀어내게되고 채널이 충분히 넓어져 충분한 양의 전류가 흐르게된다. 만약 셀의 부동게이트가 전자로 채워져있으면(0) 게이트 전압이 형성하는 전기장이 이 전자들에의해 차단되고 N채널이 전자가 흐를만큼 넓어지지 못하게되고 전류가 흐를 수 없게 된다.(사실 미약한 누설전류가 흐른다.)&lt;/p&gt;

&lt;p&gt;결론적으로 소스와 드레인 사이에 전압을 걸어주었을 때 전류가 흐르면 1, 흐르지 않으면 0인 것이다. NMOS 셀들로 이루어진 플레시 메모리는 비휘발성 보조장치 역할을 할 수 있는것을 알았다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) NOR형 플래시와 NAND형 플래시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;NMOS셀의 연결방식에 따라 플래시 메모리의 종류가 결정된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/nor_nand.png&quot; alt=&quot;nor_nand&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;NOR형에서는 모든 셀이 5V가 인가되는 비트선(BL - Bit Line)과 접지선 사이에 병렬연결이 되어있다. 이 중 어느하나라도 1이면(부동게이트가 비어있으면) 게이트 전압이 걸렸을 때 전류가 흘러 비트선(BL)이 0V로 떨어지게 된다. 이는 NOR 연산에 해당하므로 NOR형 플래시라 불린다. 참고로 제어게이트에는 단어 선(WL - Word Line)이 연결되어있어 단어선에 의해 전압이 인가된다. NOR형 플래시에서는 셀 별로 선택신호를 인가하여 저장된 값을 읽을 수 있다. 비트선의 선은 출력단에서 감지 증폭기(sense amplifier)에 의해 반전되어 출력되므로 0V가 1로, 1V가 0으로 반전되어 출력된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
반면 NAND형에서는 NMOS 셀들이 BL과 GND 사이에 직렬로 연결되어있다. NAND 플래시에서는 각 셀에 전류가 흐르기 위한 문턱 전압(threshold voltage)이 저장된 정보에 따라 다르다. 부동게이트가 비어있는 ‘1’ 상태에서는 문턱전압이 -3V이고 전자로 채워진 ‘0’ 상태에서는 문턱전압이 +1V가 된다.&lt;/p&gt;

&lt;p&gt;초기 상태에서 모든 게이트로 5V를 인가하면 저장상태에 상관없이 모든 셀이 ON되고 전류가 흘러 BL이 0V로 떨어진다. 이후 셀을 하나씩 선택하면서 0V를 인가해본다. ‘1’ 상태에서는 그대로 BL이 0V일것이고 ‘0’상태라면 문턱전압보다 낮아져 전류가 끊기게 되어 BL이 5V로 유지된다. 이런 식으로 모든 셀의 정보를 읽을 수 있다. 0V가 인가된 셀의 저장상태가 ‘0’이라면 다른 셀의 상태에 상관없이 전류가 흐르지 못해 5V가 된다. 이는 NAND 연산에 해당되므로 NAND 플래시라 불린다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
NOR 플래시에서는 각 셀 단위의 읽기/쓰기가 가능하나 셀별로 BL과 GND 접속선을 따로 두어야하므로 부피가 커진다. 반면 NAND 플래시는 BL은 최상단 트랜지스터의 드레인으로, GND는 최하단 트랜지스터의 소스로만 접속되어 연결선의 수가 대폭 줄어 부피가 작다.&lt;/p&gt;

&lt;p&gt;NOR 플래시는 비트 혹은 바이트 단위의 읽기 쓰기가 가능하기 때문에 고정된 프로그램 코드를 순차적으로 가져오거나 작은 크기의 데이터를 수시로 읽고 쓰는데 적합하다. 따라서 BIOS 저장, 스마트폰OS 저장 등에 쓰인다. 그러나 부피문제로 대용량 보조저장장치로는 적합하지 않다. SSD 이외의 보조저장장치로는 가격이 싸고 칩 당 용량이 큰 NAND 플래시가 더 적합하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(c) 내부 구조&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;여기서는 보조저장장치의 용도에 맞는 NAND플래시에 집중한다.&lt;/p&gt;

&lt;p&gt;NAND플래시는 블록(block)들로 구분되고 각 블록은 페이지(page)들로 이루어져있다. 아래 그림은 1Gbit = 128MByte NAND플래시 구조의 예시를 보여주고 있다.&lt;/p&gt;

&lt;p&gt;이 그림에서 오른쪽의 그림은 화면에 수직하는 방향으로 8개가 겹쳐있다고 가정한다. 2048×8bit = 2KByte의 페이지들이 64개 모여 하나의 블록을 구성한다. 읽기/쓰기 동작에서는 페이지 선택 해독기에 의해 페이지 전체가 액세스 된다. 따라서 NAND플래시의 읽기/쓰기 동작은 페이지 단위로 이루어진다. 반면 삭제 동작은 블록 단위로만 이루어진다.&lt;/p&gt;

&lt;p&gt;플래시 메모리의 유형으로는 블록당 페이지수가 32, 64, 128개 등 다양하고 페이지 크기도 2, 4, 16, 64KByte로 다양하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(3) SLC, MLC, TLC&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SLC(Single Level Cell)는 기존의 셀을 나타낸다. SLC에서는 부동게이트에 전자가 채워졌는지 비었는지에 따라 0과 1로 구분했다. 그런데 차있는 양에따라 구분하는 기술이 개발되었다.&lt;/p&gt;

&lt;p&gt;MLC(Multi Level Cell)은 전차가 차있는 양을 4단계로 구분하기 때문에 4가지 상태(00 01 10 11)를 나타낼 수 있어 총 2bit를 저장할 수 있다. 아래 그림은 SLC와 MLC의 전자수에 의한 상태구분을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/slc_mlc.png&quot; alt=&quot;slc_mlc&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TLC는 부동게이트에 차있는 전자의 양을 8단계로 구분하여 총 3bit를 저장할 수 있도록 한 것이다.&lt;/p&gt;

&lt;p&gt;그러나 MLC나 TLC에서는 쓰기 과정에서 부동게이트에 주입되는 전자수의 조정을 위한 세밀한 작업이 요구되고 읽기 과정에서 상태 사이의 구분이 쉽지 않아 오차가 존재할 수 있다. 또한 액세스 및 삭제시간이 길어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(4) 3D NAND 플래시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;반도체 제조공정이 미세화됨에 따라 기존의 셀 구조를 변형시킨 후 이를 위로 쌓아올린 3차원 NAND 플래시 구조가 가능해졌다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/3d_nand_cell.png&quot; alt=&quot;3d_nand_cell&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;기존의 셀과 다르게 원통형 모양으로 셀을 만들어 이를 수직으로 여러 겹 쌓아올린다. 위 그림에서는 24개의 셀을 적층했다. 이 때 셀 사이에 간격을 줌으로써 2D에서 집적도를 올리는데 방해가 되었던 셀 간의 데이터 간섭 현상도 해결된다. 또한 부동게이트의 크기가 커짐에따라 전자 수의 구분이 용이해져 오류가 줄어들고 심지어 4bit를 저장할 수 있는 QLC(Quadruple Level Cell)을 제조하는것도 가능해졌다. 이로인해 테라 비트(tera bit)급의 칩들도 출현하고 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(2) SSD&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SSD(Solid State Driver)는 여러개의 NAND 플래시 메모리를 배열로 구성한 패키지이다. 따라서 RAID구조처럼 여러개의 칩에 동시 액세스 및 병렬 데이터 전송이 가능하여 성능을 더욱 높여준다.&lt;/p&gt;

&lt;p&gt;앞에서 말했듯이 플래시 메모리는 블록과 페이지 단위로 이루어져 있으며 크기 또한 하드디스크(HDD)의 트랙 및 섹터와 다르다. 따라서 기존의 운영체제 파일시스템은 SSD를 HDD와 같은 방식으료  사용할 수 없다는 문제가 있다. 이를 해결하기 위해 SSD 제어기에서는 플래시 변환 계층(FTL - Flash Translation Layer)라는 미들웨어를 제공한다. FTL은 운영체제가 SSD의 블록과 페이지를 논리적으로 HDD의 트랙 및 섹터구조로 변환해준다. 아래 그림은 이 관계를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/6/ftl.png&quot; alt=&quot;ftl&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;FTL은 페이지와 섹터 사이의 매핑(mapping) 이외에도 중요한 기능들을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 마모 평준화(wear leveling)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;플래시 메모리의 셀은 재기록 반복횟수 제한이 있고 MLC, TLC, QLC는 그 횟수가 더욱 줄어든다. 그런데 만약 재기록이 특정 블록이나 페이지에 집중된다면 그 부분이 일찍 마모되어 칩 전체 수명이 짧아진다. FTL은 모든 페이지들이 고르게 사용되게 하는 마모 평준화를 수행한다.&lt;/p&gt;

&lt;p&gt;SSD 제어기는 재기록 레지스터에 페이지별로 재기록 횟수를 카운트하고 이를 참고하여 더 적게 사용된 페이지가 선택되도록 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) 쓰레기 수집(garbage collection)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SSD를 구성하는 플래시 메모리에서 삭제 작업은 블록(block) 단위로만 일어난다. 따라서 특정 페이지의 내용을 수정하는 경우에 그 페이지를 즉시 지우지는 않고 그대로 둔다. 일단 수정된 내용들과 다른 유효 페이지들만 다른 블록에 기록한다. 이 결과로 해당 블록에는 수정되었지만 지우지 않은 무효 페이지들이 점점 쌓이게 된다. 이런 과정이 반복된 이후 무효 페이지들이 많이 축적된 블럭이 있으면 한꺼번에 삭제동작을 수행한다.&lt;/p&gt;

&lt;p&gt;운영체제는 TRIM 명령어를 통해 SSD 제어기에게 무효 페이지가 생길때마다 알려주어 쓰레기 수집의 효율을 높인다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(c) 초과 대비공간(over-provisioning)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마모 평준화나 쓰레기 수집은 여유공간이 어느정도 남아있을 때 효율적으로 이루어질 수 있다. 따라서 SSD 제품들은 출시될 때 부터 일부를 이 작업에 대비한 공간으로 사용하도록 지원한다. 예를들어 삼성의 MZ-7TD250B는 256GB의 용량 중 6GB를 초과 대비공간으로 남겨둔다.&lt;/p&gt;</content><author><name>nobbaggu</name></author><category term="디스크" /><category term="트랙" /><category term="섹터" /><category term="플래시메모리" /><category term="hdd" /><category term="ssd" /><category term="flashmemory" /><category term="하드디스크" /><category term="보조저장장치" /><category term="raid" /><category term="레이드" /><category term="nand" /><category term="nor" /><category term="nmos" /><summary type="html">목차 하드 디스크 RAID 플레시 메모리와 SSD 0. Intro 여기에서는 가장 범용적인 하드디스크(HDD)와 RAID 디스크 배열 및 최근 사용이 확대되고있는 플래시 메모리(flash memory)와 SSD(solid-state drive)에 대해 살펴본다. 1. 하드 디스크 하드 디스크의 원래 명칭은 자기적 하드 디스크(magnetic hard disk)이다. 디스크는 자화가 가능한 물질로 코팅된 원형 평판 모양이다. 평판위에 전류가 흐를 수 있는 트랙(track)(동심원 모양)이 여러개 존재하며 데이터들이 여기에 저장된다. 헤드(head)라는 전도성 코일을 통해 트랙위에 전류를 흘려 디스크 표면을 자화시킴으로써 데이터를 저장하고 인출 한다. 아래 그림은 디스크의 구조를 보여준다. 디스크 쓰기 동작에서는 헤드의 코일에 전류를 흘릴때 나오는 자기장을 통해 자성 패턴을 디스크 표면에 기록한다. 1은 양(+)전류로, 0은 음(-)전류로 변환되어 헤드로 보내진다. 반면 읽기 동작에서는 코일이 트랙위를 지나가면 자기 패턴에서 발생되는 유도전류가 양(+)이면 1, 음(-)이면 0이 인출된다. 단일-헤드 디스크에서는 디스크팔의 길이를 제어해 헤드를 움직여 트랙을 선택하게되는데 이를 위한 디스크 팔과 디스크팔을 구동시키는 구동장치(actuator)가 있다. (1) 디스크의 구조 디스크의 트랙 동심원들은 물리적으로는 연속적으로 연결되어있지만 논리적으로는 여러개의 섹터(sector)로 구분된다. 디스크에 데이터를 저장하거나 읽는 동작은 블록(block)단위로 이루어지며, 한 섹터의 용량이 블록하나이다. 다시말해 섹터는 디스크에 한 번 액세스동안 읽거나 쓸 수 있는 최소 단위이다. 트랙 사이의 간격을 트랙간 갭(gap)이라 하며 이는 트랙간의 자기장 간섭을 방지할만큼 충분한 간격이어야한다. 또한 트랙위의 섹터와 섹터 사이를 구분하기 위한 섹터간 갭이 존재한다. 최근에 개발되는 대용량 디스크들은 약 2천개 이상의 트랙과 64개 이상의 섹터들로 이루어져있다. 디스크에는 데이터 저장 밀도라는 이슈와 관련하여 크게 두 가지 방식이 존재한다. 아래 그림은 각각의 디스크 표면 구조를 보여준다. (a) CAV(Constant Angular Velocity) 방식 트랙의 길이는 바깥쪽 동심원일수록 길어진다. CAV 방식에서는 편리성을 위해 트랙당 저장되는 데이터 비트수는 모든 트랙이 같도록 한다. 따라서 안쪽 트랙일수록 데이터 저장 밀도가 높아진다. CAV방식에서는 중심부에 가까운 트랙이든 멀리 있는 트랙이든 데이터 액세스를 위한 회전 속도가 일정하다. 그러나 바깥쪽 트랙들의 저장밀도를 가장 안쪽 트랙에 맞추려면 저장밀도를 낮추어야하므로 저장공간이 낭비된다는 단점이 있다. (b) MZR(Multiple Zone Recording) 방식 MZR 방식은 CAV 방식의 저장공간 낭비를 줄여 전체 용량을 증가시키는 다중 영역 기록 방식이라는 기술을 사용한다. 여기에서는 디스크 표면이 여러개의 동심원 영역으로 나누어지며 같은 영역의 트랙들은 같은 수의 비트를 저장한다. 결과적으로 바깥 영억의 트랙들이 더 많은 비트들을 저장할 수 있다. 헤드를 통해 트랙의 데이터에 액세스할때는 각 섹터들을 구분할 방법이 필요하다. 아래 그림을 보자. 위 그림은 섹터 용량이 600바이트인 트랙의 데이터 포맷을 나타낸다. 한 섹터에는 섹터를 식별하기 위한 ID필드, 데이터가 저장되는 데이터필드가 있다. 갭1은 섹터의 시작을 나타내며 갭2는 ID필드와 데이터필드 사이를 구분하기 위한 것이다. 또한 갭3은 섹터의 마지막을 나타낸다. ID필드는 어떤 트랙의 어떤 섹터인지를 위한 섹터 식별자이다. 여러개의 디스크 평판이 존재하기때문에 평판을 나타내는 헤드번호, 평판위에서 어떤 트랙인지를 결정하는 트랙번호, 그리고 트랙위의 섹터 번호가 존재한다. SYNCH바이트는 ID필드의 시작점을 나타내기 위한 것이고 CRC는 오류검출을 위한 체크섬(checksum)이다. 515바이트의 데이터 필드에는 필드의 시작을 위한 SYNCH바이트, 그리고 데이터가 포함된다. ID필드와 같이 CRC도 포함하고 있다. 지금까지 하나의 디스크 평판 구조에 대해 설명했다. 대부분의 디스크는 평판의 양쪽이 모두 자화 물질로 코팅되어 양면을 사용하는 양면 디스크이다. 하드 디스크 드라이브(HDD)는 이러한 평판을 여러개 포함하는 다중 평판 디스크 드라이브이다. 디스크 드라이브의 각 디스크 표면마다 하나의 헤드가 존재한다. 디스크 팔을 움직임으로써 여러 디스크평판의 같은 위치에 있는 트랙의 데이터에 동시에 접근할 수 있다. 서로 다른 표면에 있지만 동시에 액세스할 수 있는 같은 반경의 트랙들의 집합을 실린더(cylinder)라 부른다. 위 그림의 경우 한 실린더 안에 8개의 트랙이 존재한다. 여기에서 특정 트랙을 선택하기 위해 발생되는 주소에는 실린더 번호, 헤드 번호, 섹터 번호로 이루어진다. (2) 디스크 액세스 시간 디스크의 특정 데이터블록에 액세스하는 과정은 아래와 같다. (a)헤드를 해당 트랙으로 이동 : 탐색시간 (b)데이터블록이 저장된 섹터가 헤드 아래로 올 때 까지 회전 : 회전 지연시간 (c)데이터 전송 시간 데이터에 대한 액세스 시간은 위의 시간들을 모두 합친것이다. 탐색시간은 기계적인 이동으로 시동시간이 포함된다. 액세스할 데이터들이 가까운 트랙들에 위치하고 있으면 이 시간이 단축된다. 회전 지연시간은 디스크의 회전속도에 좌우된다. 대부분의 HDD는 5400rpm이나 7200rpm의 회전속도를 가진다. 2. RAID 디스크의 속도는 주기억장치(메모리)에 비해 10만분의 1 정도밖에 되지않는다. 특히 디스크 입출력이 많이 발생하는 프로그램의 경우 CPU, 메모리와 보조저장장치 사이의 속도 불균형에 의해 성능이 크게 제한될 수 밖에 없다. 또한 CPU와 주기억장치의 발전속도를 따라가지 못하여 그 차이는 더 커질 것으로 예상된다. RAID(Redundant Array of Independent Disks)는 작은 디스크 여러개를 배열구조로 연결하여 패키징한 유닛으로 디스크의 액세스 속도를 크게 향상시키면서 신뢰도 또한 높이는 기술이다. (1) RAID의 출현 배경 디스크의 저장 밀도가 높아짐에따라 비트당 가격이 계속해서 떨어지고 용량이 증가하고있다. 이에따라 하나의 대형디스크보다는 여러개의 소형 디스크를 연결하는것이 저렴한 가격으로 더 큰 용량의 디스크를 구성할 수 있게 해준다. 이렇게하면 용량뿐아니라 프로그램 실행에 직접적인 영향을 주는 속도 문제또한 개선이된다. 속도개선을 위해서는 액세스 시간 단축과 전송시간 단축이 필요하다. 데이터를 다수의 디스크에 분산하여 저장하게되면 여러 디스크들에 대한 동시 액세스와 데이터 병렬 전송이 가능해진다. 하나의 파일을 구성하는 데이터 블록들을 여러 디스크에 분산 저장하는 기술을 디스크 인터리빙(disk interleaving)이라고 한다. 아래 그림은 16개의 데이터 블록들이 4개의 디스크에 균등하게 분산 저장된 모습을 보여준다. 위 그림과 같이 데이터를 분산저장하면 여러개의 블록에대한 동시 액세스가 가능해지고 하나의 디스크에 집중되는 현상을 줄임으로써 병목현상도 줄일 수 있다. 그러나 디스크들 중 1개만 고장이나도 데이터 파일이 손상된다는 문제점이 있다. 아래 표는 IBM3390의 대형 디스크와 IBM0061 소형 디스크, 그리고 IBM0061을 배열구조로 연결하여 IBM3390과 동일한 용량을 가지도록한 RAID방식 디스크를 비교한 표이다. 크기, 전력소모, 데이터 전송률, 시간당 입출력 처리, 가격 모든 면에서 RAID 방식이 우수하다. 그러나 RAID방식의 주요 단점은 MTTF(Mean Time To Failure)가 낮다는 것이다. MTTF는 고장이 발생하는 시간 주기의 평균값이다. IBM 3390의 MTTF가 25만 시간이란 것은 평균적으로 25만 시간당 한 번 고장이 발생한다는 의미이다. RAID 방식은 여러 디스크를 연결한 것이므로 여러개 중 한 개만 고장이 나도 전체 디스크의 사용이 불가능해지므로 MTTF가 낮은 것이다. 디스크 배열의 결함 허용(fault-tolerance)를 높이기 위해 많은 노력들이 있었다. 그 중 하나는 여분의 디스크를 추가해 오류검출 및 데이터 백업을 하는 것이다. 즉, 배열내 하나의 디스크에 결함이 생기면 해당 디스크의 사용이 중지되고 여분의 검사 디스크에 저장된 변경 히스토리를 기반으로 원래의 정보를 재구성하여 여분의 디스크에 저장하게 된다. 복구되는데 소요되는 평균 시간을 MTTR(Mean Time To Repair)라고 한다. 이러한 복구작업은 시스템에 의해 자동으로 일어난다. 오류검출 및 정정(error detection and correction) 방법에 따라 여러종류의 RAID 조직이 제안되어왔다. (2) RAID의 종류 (a) RAID-1 데이터를 중복 저장하는 미러 디스크가 존재한다. 디스크 미러링 이라고 한다. 하나의 디스크에 결함이 발생하면 그 디스크의 모든 데이터가 미러 디스크에 존재하므로 데이터를 잃어버릴 염려가 없게된다. 또한 결함복구 시간이 필요하지 않다. 데이터 쓰기 동작은 데이터 디스크와 미러 디스크 모두에 대해 수행되어야 한다. 헤드의 위치 차이에 따른 탐색 시간차가 존재할 경우 더 오랜 탐색시간을 요구하는 디스크의 쓰기가 완료되어야 쓰기가 끝난다. 읽기 동작에서는 두 디스크 중 더 짧은 탐색시간과 회전 지연시간을 요구하는 디스크에서 수행하면 된다. 데이터 디스크를 통체로 미러링하기 위해서 두 배의 디스크가 필요하므로 가격이 높다. 따라서 RAID-1은 높은 신뢰도를 요구하는 시스템에 주로 사용된다. (a) RAID-2 이 구조는 데이터를 비트 단위로 인터리빙 시킨다. 한 단어를 이루는 비트들을 여러 디스크에 분산시켜 저장하는 것이다. 검사 디스크들은 오류검출 및 정정을 위한 패리티 비트들을 저장한다. 즉, 검사디스크들을 추가하고 해밍 코드(Hamming Code)를 사용하면 에러를 검출할 수 있고 심지어 어떤 비트에서 에러가 났는지를 알 수 있다. 여담이지만 위성신호나 TV와 같은 실시간 디지털 신호에서는 데이터를 받고 에러가 있으면 즉시 정정을 해야하므로 해밍 코드가 유용하다. 다만 필요한 검사 디스크의 수가 데이터 디스크 수의 로그에 비례하므로 가격이 높다. 이러한 이유로 많은 오류가 발생하거나 높은 신뢰도를 요구하는 시스템에서 주로 사용한다. (a) RAID-3 RAID-3은 RAID-2에서 오류 비트의 위치검출을 위한 많은 수의 디스크 사용에 따르는 낭비를 보완하기 위한 것이다. 1개의 패리티 디스크만 추가한다. 데이터 디스크들의 동일한 위치에 있는 비트들에 대한 패리티 비트가 패리티 디스크의 동일한 위치에 저장된다. 만약 한 디스크에 결함이 발생한다면 해당 비트는 다른 디스크의 비트들과 패리티비트 간의 XOR 연산을 통해 구할 수 있다. 만약 위 그림에서 b1b2b3b4 = 1001이라면 짝수 패리티에서 패리티비트 p=0이 저장된다. 그리고 2번째 디스크가 고장난다면 b2=p XOR b1 XOR b2 XOR b3 = 0 XOR 1 XOR 0 XOR 1 = 0이 된다. RAID-3에서는 모든 데이터가 비트단위로 분산 저장되기때문에 데이터 액세스 과정에서 모든 디스크에 병렬적으로 액세스하게된다. 따라서 액세스 시간이 단축되며 병렬 전송에 의해 데이터 전송률도 올라간다. 단점으로는 쓰기 동작마다 패리티비트를 업데이트 해주어야 하기때문에 쓰기 시간이 오래 걸린다. 또한 하나의 데이터 액세스에서 모든 디스크가 사용되므로 한 번에 하나의 요청만 처리할 수 있다. (a) RAID-4 RAID-4에서는 아래 그림과 같이 데이터 블록 단위 디스크 인터리빙을 사용한다. 여기서 패리티 디스크를 하나 추가하여 패리티 블록을 저장한다. 패리티 블록은 각 디스크의 블록을 XOR 연산하여 구할 수 있다. 그런데 어느 한 디스크의 내용이 변경되면 패리티 블록의 내용이 변경되어야하고 패리티블록의 계산을 위해서는 변경되지않은 나머지 디스크들에 있는 데이터 블록들도 필요하다. 그리고 디스크의 수가 증가될수록 필요한 읽기/쓰기 동작의 수가 증가한다. 만약 B2의 내용이 B2’로 변경되었다면 패리티블록은 P’ = B1 XOR B2’ XOR B3 XOR B4가 된다. 여기에 조금의 수학적 테크닉을 추가해보자. P’ = B1 XOR B2’ XOR B3 XOR B4 XOR (B2 XOR B2) (B2 XOR B2는 0이므로 원래의 식에 영향을 주지않는다.) 위 식을 정리하면 P’ = B1 XOR B2 XOR B3 XOR B4 XOR (B2 XOR B2’) = P XOR B2 XOR B2’ 새로운 패리티블록의 계산을 위해서는 기존의 P와 B2를 가져오는 2번의 읽기와 B2’와 P’를 쓰는 두 번의 쓰기만 필요로하며 디스크의 수가 늘어나도 일정하다. 그러나 어떤 디스크에 데이터를 쓸 때마다 패리티 디스크에 두 번씩 액세스 되어야하므로 액세스가 집중되고 이에따른 병목현상이 발생하여 성능저하가 일어난다. (a) RAID-5 RAID-5는 RAID-4의 패리티 디스크에 대한 병목현상을 해결하기 위해 고안된 구조이다. 따라서 설계개념은 RAID-4와 동일하고 패리티 블록을 여러 디스크에 분산 저장한다는 점만 다르다. 위 그림처럼 패리티 블록을 분산시켜 RAID-4에서 하나의 패리티 디스크에 몰리던 액세스 요청을 여러 디스크로 분산시켰다. 또한 쓰기 동작이 여러 디스크에 대해 동시에 수행 가능하다는 점이다. B1에 쓰기 위해서는 1, 5번째 디스크에대한 액세스가 필요하고 B7에 쓰기 위해서는 3, 4번째 디스크에 대한 액세스가 필요하다. 따라서 겹치는 부분이 없는 경우 동시 쓰기가 가능하다. 현실에서는 주로 RAID-1과 RAID-5가 사용된다. 큰 데이터를 쓰는 경우에는 RAID-1이 미러 디스크까지 2배로 써야하기때문에 성능이 좋지 않지만 작은 데이터를 여러 번 쓰는경우 RAID-5는 매 쓰기마다 4번의 액세스가 필요하여 오버헤드가 증가하게 된다. 또한 가격대비 성능 측면에서는 RAID-5가 더 우수하다. 결론적으로 구성하려는 시스템의 목적에 맞는 방식의 디스크 배열을 선택하면 된다. 3. 플래시 메모리와 SSD 기계적 장치를 많이 포함하는 하드디스크의 속도 한계때문에 새로운 유형의 보조저장장치가 출현하였다. SSD(Solid State Drive)는 반도체로 만들어진 보조저장장치이다. SSD는 EEPROM의 한 종류인 플래시메모리를 사용해서 만든다. 플래시 메모리(flash memory) 칩들을 배열구조로 패키징하여 만든것이 SSD이다. SSD는 하드디스크에 비하여 속도가 훨씬 빠르다. (1) 플래시 메모리 전기적 삭제가 가능한 EEPROM이 개발된 초기에는 1bit를 저장하는 하나의 셀(cell)이 두 개의 트랜지스터로 만들어져 부피가 컸다. 따라서 가격과 저장밀도 면에서 디스크를 대체할 정도로는 부각되지 못했었다. 그러나 최근 한 개의 트랜지스터를 사용하여 1bit를 저장하면서 전력소모가 낮고 신뢰성도 높은 플래시 메모리가 개발되었다. (a) 동작 원리 플래시 메모리에서 하나의 셀(cell)은 NMOS 트랜지스터가 사용된다. 일반적인 NMOS와 다른점은 게이트가 2개라는 것이다. 여기서 부동게이트가 데이터를 저장하는 핵심적인 역할을 수행한다. 부동 게이트는 산화막(이산화규소-SiO2)으로 둘러싸여있어 전자들이 쉽게 통과할 수 없도록 되어있다. 제어게이트에 5V를 걸어주면 소스와 드레인 사이에 전자가 통과할 수 있는 채널이 형성된다. 그런데 일정수준 이상의 전압(12V)을 걸어주면 채널은 통과하는 전자가 강한 전기장에 의해 산화막을 뚫고 부동게이트로 들어오게 된다. 이를 전자의 터널 주입이라 한다. 인가되었던 전압이 사라지면 부동게이트 안의 전자들은 그대로 갇히게 된다. 이것이 플래시 메모리의 ‘쓰기’ 동작으로 0을 저장한 것이다. 반대로 정공으로 차있는 p-well쪽에서 강한 전압을 인가하면 부동게이트에 갇혀있던 전자들이 산화막을 통과하여 N채널로 빠져나오게 되어 부동게이트는 비게 된다. 이것이 플레시 메모리의 ‘삭제’ 동작이며 셀을 논리적 1 상태로 만든 것이다. 읽기 동작을 이해하기 위해 아래 그림을 보자. 게이트에 5V전압을 인가하여 N채널을 형성해주고 소스를 접지시키고 드레인에 5V전압을 인가하면 전류가 흐르게된다. 이 때 셀의 부동게이트가 비어있으면(1) 게이트의 5V전압이 p-well의 정공들을 밀어내게되고 채널이 충분히 넓어져 충분한 양의 전류가 흐르게된다. 만약 셀의 부동게이트가 전자로 채워져있으면(0) 게이트 전압이 형성하는 전기장이 이 전자들에의해 차단되고 N채널이 전자가 흐를만큼 넓어지지 못하게되고 전류가 흐를 수 없게 된다.(사실 미약한 누설전류가 흐른다.) 결론적으로 소스와 드레인 사이에 전압을 걸어주었을 때 전류가 흐르면 1, 흐르지 않으면 0인 것이다. NMOS 셀들로 이루어진 플레시 메모리는 비휘발성 보조장치 역할을 할 수 있는것을 알았다. (b) NOR형 플래시와 NAND형 플래시 NMOS셀의 연결방식에 따라 플래시 메모리의 종류가 결정된다. NOR형에서는 모든 셀이 5V가 인가되는 비트선(BL - Bit Line)과 접지선 사이에 병렬연결이 되어있다. 이 중 어느하나라도 1이면(부동게이트가 비어있으면) 게이트 전압이 걸렸을 때 전류가 흘러 비트선(BL)이 0V로 떨어지게 된다. 이는 NOR 연산에 해당하므로 NOR형 플래시라 불린다. 참고로 제어게이트에는 단어 선(WL - Word Line)이 연결되어있어 단어선에 의해 전압이 인가된다. NOR형 플래시에서는 셀 별로 선택신호를 인가하여 저장된 값을 읽을 수 있다. 비트선의 선은 출력단에서 감지 증폭기(sense amplifier)에 의해 반전되어 출력되므로 0V가 1로, 1V가 0으로 반전되어 출력된다. 반면 NAND형에서는 NMOS 셀들이 BL과 GND 사이에 직렬로 연결되어있다. NAND 플래시에서는 각 셀에 전류가 흐르기 위한 문턱 전압(threshold voltage)이 저장된 정보에 따라 다르다. 부동게이트가 비어있는 ‘1’ 상태에서는 문턱전압이 -3V이고 전자로 채워진 ‘0’ 상태에서는 문턱전압이 +1V가 된다. 초기 상태에서 모든 게이트로 5V를 인가하면 저장상태에 상관없이 모든 셀이 ON되고 전류가 흘러 BL이 0V로 떨어진다. 이후 셀을 하나씩 선택하면서 0V를 인가해본다. ‘1’ 상태에서는 그대로 BL이 0V일것이고 ‘0’상태라면 문턱전압보다 낮아져 전류가 끊기게 되어 BL이 5V로 유지된다. 이런 식으로 모든 셀의 정보를 읽을 수 있다. 0V가 인가된 셀의 저장상태가 ‘0’이라면 다른 셀의 상태에 상관없이 전류가 흐르지 못해 5V가 된다. 이는 NAND 연산에 해당되므로 NAND 플래시라 불린다. NOR 플래시에서는 각 셀 단위의 읽기/쓰기가 가능하나 셀별로 BL과 GND 접속선을 따로 두어야하므로 부피가 커진다. 반면 NAND 플래시는 BL은 최상단 트랜지스터의 드레인으로, GND는 최하단 트랜지스터의 소스로만 접속되어 연결선의 수가 대폭 줄어 부피가 작다. NOR 플래시는 비트 혹은 바이트 단위의 읽기 쓰기가 가능하기 때문에 고정된 프로그램 코드를 순차적으로 가져오거나 작은 크기의 데이터를 수시로 읽고 쓰는데 적합하다. 따라서 BIOS 저장, 스마트폰OS 저장 등에 쓰인다. 그러나 부피문제로 대용량 보조저장장치로는 적합하지 않다. SSD 이외의 보조저장장치로는 가격이 싸고 칩 당 용량이 큰 NAND 플래시가 더 적합하다. (c) 내부 구조 여기서는 보조저장장치의 용도에 맞는 NAND플래시에 집중한다. NAND플래시는 블록(block)들로 구분되고 각 블록은 페이지(page)들로 이루어져있다. 아래 그림은 1Gbit = 128MByte NAND플래시 구조의 예시를 보여주고 있다. 이 그림에서 오른쪽의 그림은 화면에 수직하는 방향으로 8개가 겹쳐있다고 가정한다. 2048×8bit = 2KByte의 페이지들이 64개 모여 하나의 블록을 구성한다. 읽기/쓰기 동작에서는 페이지 선택 해독기에 의해 페이지 전체가 액세스 된다. 따라서 NAND플래시의 읽기/쓰기 동작은 페이지 단위로 이루어진다. 반면 삭제 동작은 블록 단위로만 이루어진다. 플래시 메모리의 유형으로는 블록당 페이지수가 32, 64, 128개 등 다양하고 페이지 크기도 2, 4, 16, 64KByte로 다양하다. (3) SLC, MLC, TLC SLC(Single Level Cell)는 기존의 셀을 나타낸다. SLC에서는 부동게이트에 전자가 채워졌는지 비었는지에 따라 0과 1로 구분했다. 그런데 차있는 양에따라 구분하는 기술이 개발되었다. MLC(Multi Level Cell)은 전차가 차있는 양을 4단계로 구분하기 때문에 4가지 상태(00 01 10 11)를 나타낼 수 있어 총 2bit를 저장할 수 있다. 아래 그림은 SLC와 MLC의 전자수에 의한 상태구분을 보여준다. TLC는 부동게이트에 차있는 전자의 양을 8단계로 구분하여 총 3bit를 저장할 수 있도록 한 것이다. 그러나 MLC나 TLC에서는 쓰기 과정에서 부동게이트에 주입되는 전자수의 조정을 위한 세밀한 작업이 요구되고 읽기 과정에서 상태 사이의 구분이 쉽지 않아 오차가 존재할 수 있다. 또한 액세스 및 삭제시간이 길어진다. (4) 3D NAND 플래시 반도체 제조공정이 미세화됨에 따라 기존의 셀 구조를 변형시킨 후 이를 위로 쌓아올린 3차원 NAND 플래시 구조가 가능해졌다. 기존의 셀과 다르게 원통형 모양으로 셀을 만들어 이를 수직으로 여러 겹 쌓아올린다. 위 그림에서는 24개의 셀을 적층했다. 이 때 셀 사이에 간격을 줌으로써 2D에서 집적도를 올리는데 방해가 되었던 셀 간의 데이터 간섭 현상도 해결된다. 또한 부동게이트의 크기가 커짐에따라 전자 수의 구분이 용이해져 오류가 줄어들고 심지어 4bit를 저장할 수 있는 QLC(Quadruple Level Cell)을 제조하는것도 가능해졌다. 이로인해 테라 비트(tera bit)급의 칩들도 출현하고 있다. (2) SSD SSD(Solid State Driver)는 여러개의 NAND 플래시 메모리를 배열로 구성한 패키지이다. 따라서 RAID구조처럼 여러개의 칩에 동시 액세스 및 병렬 데이터 전송이 가능하여 성능을 더욱 높여준다. 앞에서 말했듯이 플래시 메모리는 블록과 페이지 단위로 이루어져 있으며 크기 또한 하드디스크(HDD)의 트랙 및 섹터와 다르다. 따라서 기존의 운영체제 파일시스템은 SSD를 HDD와 같은 방식으료 사용할 수 없다는 문제가 있다. 이를 해결하기 위해 SSD 제어기에서는 플래시 변환 계층(FTL - Flash Translation Layer)라는 미들웨어를 제공한다. FTL은 운영체제가 SSD의 블록과 페이지를 논리적으로 HDD의 트랙 및 섹터구조로 변환해준다. 아래 그림은 이 관계를 보여준다. FTL은 페이지와 섹터 사이의 매핑(mapping) 이외에도 중요한 기능들을 수행한다. (a) 마모 평준화(wear leveling) 플래시 메모리의 셀은 재기록 반복횟수 제한이 있고 MLC, TLC, QLC는 그 횟수가 더욱 줄어든다. 그런데 만약 재기록이 특정 블록이나 페이지에 집중된다면 그 부분이 일찍 마모되어 칩 전체 수명이 짧아진다. FTL은 모든 페이지들이 고르게 사용되게 하는 마모 평준화를 수행한다. SSD 제어기는 재기록 레지스터에 페이지별로 재기록 횟수를 카운트하고 이를 참고하여 더 적게 사용된 페이지가 선택되도록 한다. (b) 쓰레기 수집(garbage collection) SSD를 구성하는 플래시 메모리에서 삭제 작업은 블록(block) 단위로만 일어난다. 따라서 특정 페이지의 내용을 수정하는 경우에 그 페이지를 즉시 지우지는 않고 그대로 둔다. 일단 수정된 내용들과 다른 유효 페이지들만 다른 블록에 기록한다. 이 결과로 해당 블록에는 수정되었지만 지우지 않은 무효 페이지들이 점점 쌓이게 된다. 이런 과정이 반복된 이후 무효 페이지들이 많이 축적된 블럭이 있으면 한꺼번에 삭제동작을 수행한다. 운영체제는 TRIM 명령어를 통해 SSD 제어기에게 무효 페이지가 생길때마다 알려주어 쓰레기 수집의 효율을 높인다. (c) 초과 대비공간(over-provisioning) 마모 평준화나 쓰레기 수집은 여유공간이 어느정도 남아있을 때 효율적으로 이루어질 수 있다. 따라서 SSD 제품들은 출시될 때 부터 일부를 이 작업에 대비한 공간으로 사용하도록 지원한다. 예를들어 삼성의 MZ-7TD250B는 256GB의 용량 중 6GB를 초과 대비공간으로 남겨둔다.</summary></entry><entry><title type="html">(컴퓨터구조) 5. 기억장치(메모리)</title><link href="http://localhost:4000/2020/02/24/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98/" rel="alternate" type="text/html" title="(컴퓨터구조) 5. 기억장치(메모리)" /><published>2020-02-24T13:37:19+09:00</published><updated>2020-02-24T13:37:19+09:00</updated><id>http://localhost:4000/2020/02/24/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98</id><content type="html" xml:base="http://localhost:4000/2020/02/24/%EA%B8%B0%EC%96%B5%EC%9E%A5%EC%B9%98/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;기억장치의 분류와 특성&lt;/li&gt;
  &lt;li&gt;계층적 기억장치시스템&lt;/li&gt;
  &lt;li&gt;반도체 기억장치&lt;/li&gt;
  &lt;li&gt;기억장치 모듈의 설계&lt;/li&gt;
  &lt;li&gt;캐시 메모리&lt;/li&gt;
  &lt;li&gt;DDR SDRAM&lt;/li&gt;
  &lt;li&gt;차세대 비휘발성 기억장치&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-intro&quot;&gt;0. Intro&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;기억장치는 말그대로 데이터를 저장하기 위한 하드웨어를 말한다. 기억장치는 크게 내부 기억장치와 외부 기억장치로 나뉜다. 내부 기억장치는 흔히 알고있는 메모리로서 CPU가 직접 액세스할 수 있다. 외부 기억장치는 디스크나 외장하드, CD-ROM과 같은 보조 저장장치의 용도로 사용되며 CPU가 직접 액세스 할 수 없다.&lt;/p&gt;

&lt;p&gt;이번 챕터에서는 일반적으로 메모리라고 부르는 내부 기억장치에 대해 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-기억장치의-분류와-특성&quot;&gt;1. 기억장치의 분류와 특성&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;기억장치의 데이터를 읽거나 쓰기 동작을 액세스(access)라고 한다. 기억장치는 제조 공정과 구조에 따라 액세스 방법이 달라지는데 그 유형은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) 순차적 액세스(sequential access)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;처음부터 순차적으로 액세스한다. 이 방식의 예시로는 자기 테이프(magnetic tape)이 있다. 데이터는 레코드(record)라 불리는 단위로 구분되며 각 레코드별로 주소가 할당되어있다. 한 쪽으로 감겨있는 자기테이프의 특정 위치에 데이터를 쓰기 위해서는 그 위치까지 재생시켜 통과시켜야한다. 즉, 특정 위치에 액세스하기 위해서는 시간이 걸린다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) 직접 액세스(direct access)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;데이터가 레코드 혹은 블록으로 구분지어져있다. 특정 블록 내의 특정 위치에 액세스를 하기위해서는 해당 블록의 처음 위치로 이동한 후 그 위치까지 순차적 액세스를 실행해야한다. 직접 액세스를 사용하는 장치로는 CD-ROM, DVD등이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3) 임의 액세스(random access)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;별도의 일기/쓰기 회로가 존재한다. 따라서 어떤 위치로든 바로 액세스할 수 있다. 특정 위치까지 이동하는 시간이 필요없고 어느 위치로 액세스하던지 같은 시간이 걸린다. 반도체 기억장치들이 임의 액세스 방식을 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4) 연관 액세스(associative access)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;임의 액세스를 응용한 방식이다. 다른점은 키(key)와 값(value)이 같이 저장되어있다. 임의 액세스가 주소를 통하여 액세스 하는것과 다르게 키를 이용하여 액세스한다. 즉 액세스 요구에는 주소가 아닌 키의 비트 패턴이 포함되고 이를 데이터의 각 키와 비교하여 일치하는 곳으로 액세스한다. 중요한 점은 키 값을 하나씩 순차적으로 비교하는 방식이 아닌 동시에 모든 키들과 비교하므로 액세스 시간이 소요되지 않는다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;기억장치 시스템에서는 저장할 수 있는 용량(capacity)와 액세스 속도(access speed)가 중요하다. 이와 관련된 기억장치의 개념을 몇 가지 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 전송 단위(unit of transfer)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU가 한 번에 액세스할 수 있는 메모리의 비트 수이다. 다시말해 CPU와 메모리 사이에 연결된 데이터 선의 수와 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) 주소지정 단위(address unit)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;하나의 주소에 할당된 메모리 용량이다. 일반적으로 바이트(byte)가 주소지정 단위이다. 때로는 워드(word)를 사용하기도 한다. 만약 CPU가 주소지정을 위해 사용하는 비트수가 A라면 2^A개의 주소가 지정될 수 있다. 이 때 주소지정단위가 BYTE라면 사용할 수 있는 메모리 크기는 2^A 바이트가 된다. 혹은 주소지정단위가 워드(word)이고 1워드가 4바이트라면 4*2^A 바이트만큼의 메모리를 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
프로그램의 성능에 직접적인 영향을 끼치는 메모리의 액세스 속도와 관련된 몇 가지 파라미터들에 대해 알아보자.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) 액세스 시간(access time)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;읽기/쓰기 신호가 메모리에 도착한 순간부터 읽기/쓰기가 완료되는데 걸리는 시간이다. 순차적 액세스 방식이나 직접 액세스에서는 데이터가 저장된 위치별로 다르지만 랜덤 액세스 방식을 사용하는 메모리에서는 데이터가 저장된 위치, 즉 주소에 상관없이 액세스 시간이 동일하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) 기억장치 사이클 시간(memory cycle time)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최근에 개발되고 있는 FRAM같은 경우는 데이터를 읽은 후에는 데이터가 소멸되고 다시 자동적으로 복원된다. 기억장치 사이클 시간은 액세스 시간과 데이터 복원시간을 합친 것이다. 우리가 흔히 알고있는 반도체 메모리같은 경우는 액세스시간과 기억장치 사이클시간이 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3) 데이터 전송률(data transfer rate)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1초당 읽거나 쓸 수 있는 비트 수를 말한다. 예를들어 액세스 시간이 100ns이고, 전송단위가 1바이트라면 데이터 전송률은 1byte/100ns = 10MByte/s가 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
추가적으로 메모리 제조에 사용되는 재료에 의한 구분도 있다. 크게 반도체 메모리, 자기표면 메모리, 광 메모리 등이 있다. 자기표면 기억장치나 광학 메모리는 비휘발성인데 반해 반도체 메모리는 휘발성, 비휘발성 두 종류가 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-계층적-기억장치시스템&quot;&gt;2. 계층적 기억장치시스템&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;컴퓨터 성능에서 가장 큰 부분을 차지하는 CPU의 속도는 매우 향상되었다. 그러나 기억장치의 처리속도가 느리다면 CPU가 아무리 빠르더라도 메모리에서 병목현상이 일어난다. 대기시간만큼 컴퓨터는 느려질 수 밖에 없다. 따라서 메모리 액세스 시간 또한 컴퓨터 성능에서 매우 중요한 부분을 차지한다.&lt;/p&gt;

&lt;p&gt;이번 평균 액세스 속도는 높이면서 성능대비 가격도 적절히 유지할 수 있도록 적절한 계층적 기억장치 시스템(hierarchical memory system)을 구성하는 방법과 효과에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1) 필요성 및 효과&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;주기억장치와 CPU 사이의 속도차이도 문제지만 대용량 저장을 위한 일반적인 보조저장장치(디스크)는 일반적으로 메모리보다 액세스 속도가 10만배 가량 느리다. 따라서 메모리의 크기가 작으면 한 번에 올릴 수 있는 데이터량이 작으므로 필요할 때 마다 디스크 입/출력이 발생하므로 그만큼 성능저하는 더욱 심각해진다. 즉, 메모리의 용량이 클수록 더 많은 데이터를 CPU 가까이 위치시킬 수 있기 때문에 액세스 시간은 짧아진다. 그러나 부피 문제와 가격 문제로 인해 메모리 크기를 무한정 키울 수 없다.&lt;/p&gt;

&lt;p&gt;메모리를 구성할 때는 속도뿐만 아니라 기능, 용량 및 가격까지 고려해야한다. 이러한 여러 조건들을 충족시키기 위해 여러개의 다른 종류의 기억장치들을 분리하여 계층적으로 구성한다. 캐시 메모리, 레지스터, 범용 메모리 등으로 나누는 이유가 이 때문이다. 즉, 컴퓨터 시스템에서 기억장치를 구성할 때는 속도, 용량, 가격 사이의 trade-off가 필요하다.&lt;/p&gt;

&lt;p&gt;기억장치의 속도, 용량, 가격 사이에는 아래와 같은 관계들이 성립한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 액세스 속도가 높아질수록 비트당 가격이 높다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) 용량이 커질수록 비트당 가격은 낮다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c) 용량이 커질수록 액세스 속도는 낮다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;따라서 컴퓨터의 사용 목적에 따라 더 크고 싸지만 속도는 느린 메모리를 구성할지, 가격은 비싸지만 액세스 속도가 빠른 메모리 종류를 추가할지를 결정하면 된다.&lt;/p&gt;

&lt;p&gt;아래 그림은 계층적 기억장치 시스템을 구성함으로써 얻을 수 있는 이점을 설명하기 위한 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/hierarchical_memory_model.png&quot; alt=&quot;hierarchical_memory_model&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 L1 메모리의 액세스 시간이 10ns, L2 메모리의 액세스 시간이 100ns라고 가정하고, 두 메모리만을 사용한다고 해보자.&lt;/p&gt;

&lt;p&gt;프로그램 실행 과정에서 필요한 데이터의 50%가 L1, 나머지 50%가 L2에 있다고 가정했을 때 평균 액세스 시간은 0.5*10ns + 0.5*100ns = 55ns이다. 만약 8:2 비율로 있다면 28ns이다. 모든 데이터가 L1에 있다면 평균 액세스시간은 10ns가 된다.&lt;/p&gt;

&lt;p&gt;일반적인 프로그램이 실행되는 동안에 액세스하는 메모리의 위치를 조사해보면 특정 구역에 집중되는 경향이 있다. 그 이유는 대부분의 프로그램이 특정 반복문이나 서브루틴 함수를 여러번 반복해서 호출하기 때문이다. 만약 프로그램 실행이후 얼마간의 시간이 지나고 자주 사용되는 데이터를 L1에 올리고 나머지는 L2에 두고 사용하면 평균 액세스 시간이 단축되어 더욱 신속하게 데이터를 읽어올 수 있다.&lt;/p&gt;

&lt;p&gt;위와 같은 현상을 &lt;strong&gt;지역성의 원리(principle of locality)&lt;/strong&gt;라고 한다. 대부분의 프로그램에는 이 원리가 적용되기 때문에 L1계층의 메모리에 대한 액세스가 L2계층에 비해 많다. 다시말해 계층적 기억장치 구성은 프로그램의 성능을 끌어올려준다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 기억장치 계층&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래 그림은 요즘의 컴퓨터에 적용된 계층적 기억장치 시스템을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/hierarchical_memory.png&quot; alt=&quot;hierarchical_memory&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 상위 계층으로 갈수록 아래의 특징이 뚜렷해진다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(a) 가격 상승&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(b) 용량 감소&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(c) 액세스 시간 단축&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(d) CPU에 의한 액세스 빈도 상승&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
특히 특징 (d)는 지역성의 원리를 활용하기 위한 계층적 기억장치의 특징을 가장 잘 나타낸다. 일반적으로 CPU 내부에는 일반목적, 특수목적 레지스터들이 수십개 정도(비싼 CPU의 경우 수백개) 있는데 레지스터의 경우에는 CPU 1클럭 주기 내에 데이터 액세스가 가능할 만큼 빠르다.&lt;/p&gt;

&lt;p&gt;CPU만큼 빠르거나 주기억장치만큼 크지는 않은 &lt;strong&gt;캐시 메모리(cache memory)&lt;/strong&gt;가 있다. 캐시는 프로그래머가 직접 다룰 수 없고 운영체제에 의해 자주 사용하는 데이터가 캐시 히트(cache hit)되어 캐시 메모리에 적재된다. 캐시는 CPU와 메모리 사이의 속도차이를 보완하기 위해 사용된다.&lt;/p&gt;

&lt;p&gt;레지스터, 캐시, 메모리 사이의 액세스 시간에는 아래와 같은 관계가 성립된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;레지스터(~1ns) &amp;lt; 캐시(2~10ns) &amp;lt; 메모리(~100ns)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
지금까지 설명한 이유들로 인해 계층적으로 기억장치를 구성하면 평균 액세스 시간은 단축시키고 전체적인 용량은 향상시키면서도 적절한 가격을 유지할 수 있다.&lt;/p&gt;

&lt;p&gt;레지스터, 캐시, 주기억장치는 CPU가 주소를 지정하고 직접 액세스를 할 수 있는 내부 기억장치였다. 외부 기억장치(ex. SSD, CD-ROM, 하드디스크)는 장치의 제어기를 통하여서만 데이터 교환이 가능하다.&lt;/p&gt;

&lt;p&gt;지금부터는 내부 기억장치에 초점을 맞춰 반도체 메모리와 캐시의 동작 및 원리에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-반도체-기억장치&quot;&gt;3. 반도체 기억장치&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;아주 오래전에는 자기 코어로 만들어진 자화의 원리를 사용한 기억장치를 사용했지만, 전자공학의 발전 이후 메모리는 거의 반도체로 만들어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1) RAM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;RAM(Random Access Memorey)은 이름대로 임의 액세스를 하는 기억장치를 말한다. ROM(Read Only Memory)와 다르게 읽기와 쓰기가 모두 가능하다.&lt;/p&gt;

&lt;p&gt;아래 그림과 같은 1K×8비트 용량의 RAM이 있다고 하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/RAM_block_diagram.png&quot; alt=&quot;RAM_block_diagram&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RAM의 워드(word)는 8bit이고, 1K(1024)개의 주소 지정이 가능하다. 따라서 사용할 수 있는 메모리 용량은 1KByte이다.&lt;/p&gt;

&lt;p&gt;1024=2^10개의 주소지정을 위해서 주소 버스의 폭은 10비트가 필요하다. 또한 워드는 8bit이므로 데이터 교환을 위한 데이터 버스의 폭은 8bit이다.&lt;/p&gt;

&lt;p&gt;위에서 CS(chip select) 비트는 여러개의 칩을 사용하는 기억장치 시스템에서 사용하는 칩 선택 신호이다. RD는 읽기 신호, WR는 쓰기 신호이다.&lt;/p&gt;

&lt;p&gt;위 도표에서는 1이 될 때 해당 신호가 활성화(active-high) 된 것으로 가정하였다.실제 대부분의 칩에서는 0이 될 때 활성화되는 active-low 신호를 사용한다.)&lt;/p&gt;

&lt;p&gt;RAM의 특징중 하나는 &lt;strong&gt;휘발성(volatile)&lt;/strong&gt;이다. 전원 공급이 중단되면 데이터가 소멸된다. 즉, RAM은 일시적 기억장치로만 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;※DRAM vs SRAM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) DRAM(Dynamic RAM)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;DRAM은 데이터 저장을 위해 커패시터(capacitor)를 사용한다. 커패시터에 전하가 충전(charge)되어있으면 1, 아니면 0이다. 커패시터는 시간이 지남에따라 방전되는 성질로 인해 재충전이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) SRAM(Static RAM)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SRAM은 데이터 저장을 위해 플립플롭(flip-flop)을 사용한다. 따라서 데이터가 안정된 상태로 유지될 수 있으므로 재충전이 필요하지 않다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
DRAM과 SRAM은 모두 전원공급이 중단되면 데이터를 잃는 휘발성이다. DRAM에 비해 SRAM은 소자 하나의 부피가 크고 가격이 비싸다. 따라서 같은 면적에 더 많은 셀을 얹을 수 있는 DRAM이 SRAM에비해 가격이 싸다. 그러나 SRAM은 반도체 소자인만큼 속도가 DRAM보다 빠르다. 이러한 특성으로 인해 DRAM은 일반적인 메모리로 사용되고 SRAM은 캐시로 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
RAM의 주소지정 원리를 보기 전 실제는 존재하지 않는 간단한 8×8비트 메모리의 주소지정에 대해 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/8by8_ram.png&quot; alt=&quot;8by8_ram&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8×8은 8개의 주소가 있고 각 주소당 8bit의 기억장소가 할당되는 메모리를 의미한다. 즉 총 용량은 64bit가 된다.&lt;/p&gt;

&lt;p&gt;8개의 주소지정을 위해서는 3개의 주소선이 필요하다.(2^3=8) 해독기를 통하여 주소 비트가 해독되어 8개의 출력선들 중의 하나를 활성화시킨다. 이 메모리의 워드는 8비트이므로 데이터 교환을 위해서는 8비트 폭의 데이터 버스가 필요하다. 만약 이와같은 구조를 가지는 RAM의 전체 용량이 1Mbit(128K×8bit)라면 128K(128×2^10 = 2^17)개의 주소지정을 위해 17개의 주소선이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
이제는 더 큰 용량의 메모리에 위 원리를 적용해보자. 다만 위에서는 기억장소들이 한 방향으로 선형적으로 나열되어있는 1차원 메모리를 가정하였으나 여기서는 2차원 메모리를 보여준다. 따라서 메모리의 주소지정을 위해서는 행(row) 주소와 열(column)주소를 따로 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/16Mby4_ram.png&quot; alt=&quot;16Mby4_ram&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서는 행주소와 열주소가 각각 행주소 버퍼와 열주소 버퍼로 들어간다. 이후 각각이 행 주소 해독기와 열 주소 해독기에 의해 해독되어 기억장소를 선택한다.&lt;/p&gt;

&lt;p&gt;그림에서는 기억소자가 총 16M(=2^24)개 존재한다. 따라서 주소지정을 위해서는 24비트의 주소선이 필요하다. 그러나 실제로는 12비트의 주소선만 있어도 된다. 그 이유는 아래의 타이밍도를 통해 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/dram_timing_flow.png&quot; alt=&quot;dram_timing_flow&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일단 CPU는 24비트의 메모리 주소를 생성한다. 그들 중 상위 12비트는 행주소로, 하위 12비트는 열주소로 사용된다.&lt;/p&gt;

&lt;p&gt;RAS(Row Address Signal)과 CAS(Column Address Signal)는 메모리 제어기에 의해 발생되는 신호이다. 메모리 제어기는 먼저 RAS를 1(SET)로 만들어 행 주소부터 행주소버퍼에 래치시키고 그 다음 마찬가지로 CAS를 SET시켜 열주소를  열주소 버퍼에 래치시킨다. 이처한 동작으로 행주소와 열주소가 순차적으로 DRAM으로 보내지며 각각의 해독기에 의해 해독된다.&lt;/p&gt;

&lt;p&gt;위 타이밍도에서 RD신호를 보면 행 주소가 래치되기 시작하는 순간부터 들어온다. 그러나 실제 데이터가 읽히는 시간은 열 주소가 래치되기 시작하는 순간부터 액세스 시간을 지난 이후부터이다. 그 결과가 유효 데이터가 되어 데이터 버스에 실리게 된다.&lt;/p&gt;

&lt;p&gt;또한 위 기억장치는 DRAM을 나타내기 때문에 재충전 장치가 존재한다. 메모리 액세스가 없는 사이클 동안 재충전 계수기는 0부터 4095까지의 주소를 순서대로 발생시키며 해당 행에있는 모든 기억소자를 재충전시킨다.&lt;/p&gt;

&lt;p&gt;아래 그림은 위에서 설명한 16M×4 DRAM의 실제 칩 패키징 구조를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/16Mby4_ram_package.png&quot; alt=&quot;16Mby4_ram_package&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) ROM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ROM(Read Only Memory)는 이름이 말해주듯이 읽기만 가능한 메모리이다. 대부분의 컴퓨터에서 메모리의 RAM 이외 일부는 ROM으로 구성된다.&lt;/p&gt;

&lt;p&gt;또한 ROM은 비휘발성이다. 이러한 특성에 의해 ROM에는 아래와 같은 데이터가 주로 저장된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 시스템 초기화 및 진단 프로그램
b) 자주 사용되는 서브루틴
c) 제어 유닛의 마이크로 프로그램
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ROM에 저장될 데이터는 메모리 제조과정에서 미리 쓰여진다.&lt;/p&gt;

&lt;p&gt;ROM은 한 번 쓰게되면 이후 수정이 불가능하다는 제한을 완화하기 위하여 이후 아래와 같은 ROM들이 추가적으로 개발되었다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a)PROM(Programmable ROM)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;제조 과정에서는 내용을 비워두며 사용자가 구입후에 필요한 데이터를 쓴다. ROM에 비해서는 융통성이 높지만 결국 한 번만 쓰기 가능하다는 점은 ROM과 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) EPROM(Erasable Programmable ROM)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;내용 삭제가 가능하다. 하지만 삭제를 위해서는 자외선이 필요하다. 따라서 내용 삭제를 위해서는 메모리를 컴퓨터에서 분리해야한다. 또한 일부 삭제는 불가능하고 ROM의 전체 내용 삭제만 가능하다. 삭제하는데 수십분의 오랜 시간이 소요된다. 여러 번 삭제가 가능하다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c) EEPROM(Electrically Erasable PROM)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;EPROM과 다르게 전기적인 신호를 통해 내용을 삭제할 수 있으므로 메모리를 분리할 필요가 없다. 한 번에 바이트 단위의 수정이 가능하며 일반적으로 쓰기 횟수는 수만번 정도 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;d) 플래시 메모리(Flash Memory)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;EEPROM과 마찬가지로 전기적인 신호를 통해 내용 수정이 가능하다. 그러나 내용 삭제 속도가 EEPROM에 비해 현저히 빠르다는 장점이 있다. 그러나 바이트 단위의 쓰기가 가능한 EEPROM과 달리 쓰기 동작이 페이지 단위(보통 4K 바이트)로만 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-기억장치-모듈의-설계&quot;&gt;4. 기억장치 모듈의 설계&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;기억장치 칩 하나는 제한된 주소 갯수와 용량을 가지고 있다. 일반적인 메모리들은 이러한 칩 여러개를 물리적으로 접속시켜 사용한다. 물론 사용자가 보기에는 논리적으로 하나의 메모리처럼 보인다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1) 병렬 접속&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;주소비트가 4개(0000~1111번지로 15개의 주소 지정)이고 주소 하나당 4bit를 저장하는 간단한 칩이 있다고 해보자. 그런데 CPU의 워드(word)가 8bit이다. 이런 경우 아래 그림과 같이 칩을 병렬로 접속해서 논리적으로 8bit인 메모리를 만들 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/chip_parallel_joint.png&quot; alt=&quot;chip_parallel_joint&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4bit의 주소버스를 두 칩 주소버스에 공통적으로 연결한다. 그리고 8bit의 데이터를 4bit 나누어 칩의 데이터 버스와 연결했다. 이렇게 하면 두 메모리의 같은 위치에는 같은 번지가 배정되고 8bit의 데이터가 두개의 4bit로 쪼개져 각 칩의 기억장소에 저장된다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 16×4bit칩 2개로 16×8bit의 메모리를 구성할 수 있다.&lt;/p&gt;

&lt;p&gt;좀 더 현실적인 예로 워드가 32bit(4byte)인 CPU를 사용하기 위해서 1K×8bit 칩으로 메모리를 구성한다면 아래 그림과 같이 4개를 병렬연결하면 된다. 이렇게 하면 1024개의 주소를 가지며 각 주소마다 32bit 크기의 기억장소를 가지는 메모리가 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/chip_parallel_joint2.png&quot; alt=&quot;chip_parallel_joint2&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 직렬 접속&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;직렬접속을 사용하면 병렬접속과 달리 기억장소의 수를 확장시킬 수 있다. 아래 그림은 16×4bit 칩 2개를 직렬 연결하여 32×4bit의 메모리를 구성한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/chip_serial_joint.png&quot; alt=&quot;chip_serial_joint&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;32개(2^5)의 주소를 위해서는 5bit의 주소버스가 필요하다. 이 중 최상위 1bit는 각 칩의 선택 신호(CS-bar)에 인가되었다. CS-bar신호의 bar(CS신호 기호 위에있는 직선)는 active-low를 나타낸다. 즉, 이 신호는 0이 들어올 때 활성화가 된다는 뜻이다. 다시말해 0이 들어오면 칩이 선택되었단 것이다. 또한 데이터버스는 각각의 칩에 공통적으로 인가되었다.&lt;/p&gt;

&lt;p&gt;이 때 주소의 최상위비트(A4)가 0이면 RAM1이 선택되고, 1이면 RAM2가 선택된다. 따라서 총 32개의 주소를 사용할 수 있는 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RAM1 : 00000~01111번지
RAM2 : 10000~11111번지
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
아래 그림은 1K×8bit chip 4개를 직렬 연결하여 4K×8bit의 메모리를 구성한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/chip_serial_joint2.png&quot; alt=&quot;chip_serial_joint2&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1K(2^10)이 4K(2^12)이 되기 위해서는 2개의 주소bit가 추가적으로 필요하다. 상위 2비트는 칩 선택 신호로 사용하고 나머지 10비트는 각 칩에 공통적으로 인가한다.&lt;/p&gt;

&lt;p&gt;2개의 추가 주소비트를 2×4 해독기의 입력으로 넣어주면 4개의 신호로 구분될 수 있다. 그리고 각 신호가 4개 칩의 CS비트로 인가된다. 두 비트가 00, 01, 10, 11일 경우 각각 RAM1, RAM2, RAM3, RAM4가 선택된다.&lt;/p&gt;

&lt;p&gt;예를들어 RAM3에는 1000 0000 0000 번지부터 1011 1111 1111번지까지 주소가 할당된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;직렬접속과 병렬접속을 조합하면 우리가 원하는 주소폭과 데이터폭을 가지는 메모리를 설계할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-캐시-메모리&quot;&gt;5. 캐시 메모리&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;앞에서 언급했지만 캐시(cache) 메모리는 CPU와 메모리 사이의 속도차이로인한 성능 저하를 방지하기 위해 사용하는 반도체 메모리이다. 캐시는 메모리보다 CPU에 인접하거나 CPU 내부에 포함시키기도 한다.&lt;/p&gt;

&lt;p&gt;프로그램 실행동안 메모리에서 자주 인출되는 명령어나 데이터가 캐시에 올라가게 된다. 캐시는 메모리보다 비싼 고속 기억장치이기도 하며 물리적으로 CPU와 더 가깝기 때문에 메모리보다 액세스 시간이 짧다. 비싸면서 설치 공간의 제한때문에 주기억장치의 용량에 비해 매우 작다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/cache_memory_position.png&quot; alt=&quot;cache_memory_position&quot; width=&quot;20%&quot; height=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;일단 CPU가 메모리로부터 인출한 명령어나 데이터는 캐시에 적재(load)된다. 따라서 일정시간 경과 후에는 CPU가 한 번 이상 액세스한 내용은 캐시에 복사되어있는 상태가 된다. 그러나 캐시는 용량이 작기 때문에 계속 캐시에 남아있지는 못한다.&lt;/p&gt;

&lt;p&gt;일단 캐시에 데이터가 적재되면 메모리에 비해 액세스 시간이 매우 짧아진다. CPU가 데이터에 엑세스 할 때는 캐시부터 검사 후 없으면 메모리로 이동한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;CPU가 데이터를 캐시에서 찾는것을 성공했을 경우를 &lt;strong&gt;캐시 적중(cache hit)&lt;/strong&gt;라고 한다.(보통 캐시 히트라고 한다.) 반대로 캐시에서 찾지 못한 경우를 &lt;strong&gt;캐시 미스(cache miss)&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;캐시 적중률(cache hit ratio)&lt;/strong&gt;는 CPU가 캐시히트를 할 확률이다. 풀어말하면 CPU가 데이터에 액세스 했을 때 그 데이터를 캐시로부터 찾았을 확률이며 아래와 같은 수식으로 나타낸다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{H} = \mathbf{캐시 히트 횟수} \over \mathbf{전체 기억장치 액세스 횟수}&lt;/script&gt;

&lt;p&gt;이를 응용하면 CPU의 기억장치 평균 액세스 시간(&lt;script type=&quot;math/tex&quot;&gt;{T}_a&lt;/script&gt;)도 계산할 수 있다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf{T}_a = \mathbf{H} \times \p \mathbf{1-H} \times \mathbf{T}_m&lt;/script&gt;

&lt;p&gt;사실은 캐시미스의 경우 메모리에서 데이터를 인출하여 캐시에 올린 후 다시 빼내어 쓰기때문에 추가적인 시간이 소모되며 캐시히트를 검사하는 시간도 고려해야하나 이들은 상대적으로 매우 작기 때문에 수식을 간략히 적은 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;캐시 히트가 높다는 것은 그만큼 캐시 사용 효과가 커진다는 것이다. 앞에서도 말했지만 캐시히트는 &lt;strong&gt;데이터 지역성&lt;/strong&gt;에 크게 의존한다. 다시 말해 프로그램의 특정 부분에 위치한 코드나 데이터를 집중적으로 액세스하는 현상이다.&lt;/p&gt;

&lt;p&gt;데이터 지역성은 특성에 따라 아래와 같이 분류될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 시간적 지역성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최근 액세스된 코드나 데이터가 가까운 시간안에 다시 엑세스 될 가능성이 높아지는 특성이다. 반복문이나 서브루틴(함수), 공통 변수들은 반복적으로 빈번히 액세스된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) 공간적 지역성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리 내에서 인접하여 저장된 데이터들은 연속적으로 액세스 될 가능성이 높아지는 특성이다. 배열이나 리스트같은 자료구조가 대표적이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c) 순차적 지역성&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분기(branch)가 일어나지 않는 한 명령어는 순차적으로 인출되어 실행된다. 일반적인 프로그램은 순차적 실행과 비순차적 실행 비율이 대략 5:1정도인 것으로 알려져있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;본질적으로 캐시사용 목적은 데이터 액세스 시간의 단축이다. 방금 말한 캐시 히트율은 프로그램 특성에 따라 다르기때문에 이것만으로 캐시 사용 효율을 높이는데는 한계가 있다. 따라서 캐시 설계 과정에서는 여러가지를 고려해야하며 아래는 그 목표들의 나열이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 캐시 히트 극대화
(b) 캐시 액세스시간 최소화
(c) 캐시미스 시의 지연시간 최소화
(d) 메모리와 캐시사이 동기화에 따른 오버헤드 최소화(CPU가 데이터를 변경했을 때 메모리에서도 그 내용을 갱신시키는 일에 소요되는 지연시간)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;지금부터는 본격적으로 이와같은 목표달성을 위한 설계상의 이슈사항들에 대해 살펴본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1) 캐시 용량&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;캐시 용량이 크면 올릴 수 있는 데이터가 많아지기 때문에 캐시 적중률이 높아진다. 그러나 비용이나 부피문제가 존재하기 때문에 적정한 크기의 용량을 결정해야한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(2) 인출 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리에서 캐시로 데이터를 올리는 방식은 캐시 적중률에 큰 영향을 미친다. &lt;strong&gt;요구 인출(demand fetch)&lt;/strong&gt;는 CPU가 현재 필요한 데이터만 캐싱하는 방식이고, &lt;strong&gt;선인출(prefetch)&lt;/strong&gt;는 지역성을 고려하여 앞으로 필요할 것이라 예상되는 데이터도 미리 캐싱해두는 방식이다. 메모리에서 캐시로 캐싱되는 데이터들의 그룹을 블록(block)이라 부른다. 블록이 커질수록 인출 시간이 그만큼 길어지기에 선인출 방식은 지역성이 큰 경우에는 큰 효과를 보지만 아니라면 인출 시간만 길어지는 부작용이 나올 수 있다.&lt;/p&gt;

&lt;p&gt;아래 그림은 메모리와 캐시 조직을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/memory_cache_structure.png&quot; alt=&quot;memory_cache_structure&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메모리의 주소버스 폭은 n비트로 총 2^n개(0~2^n-1)의 주소를 지정할 수 있다. 다시말해 2^n개의 단어(word)를 저장할 수 있다. 선인출을 위해 메모리를 K개의 단어로 이루어진 블록들로 나눌 경우 전체 블록의 수는 2^n/K개가 된다.&lt;/p&gt;

&lt;p&gt;캐시는 m개의 라인(line, 혹은 슬롯(slot))을 가지고 있다. 각 라인에는 하나의 블록, 즉 K개의 단어를 저장할 수 있다. 다시말해 캐시의 라인 하나의 용량은 메모리의 블록크기와 같아야한다.&lt;/p&gt;

&lt;p&gt;선인출 방식을 다시 설명하자면 CPU가 실행에 필요한 명령어나 데이터에 액세스했을 때, 그 데이터가 포함된 전체 블록을 미리 캐싱해두는 것이다. 캐싱이 된 블록은 캐시의 한 라인에 적재된다.&lt;/p&gt;

&lt;p&gt;캐시의 용량은 작기 때문에 캐시 라인 수는 메모리 전체 블록 수보다 훨씬 작으며 따라서 메모리의 일부 블록만 캐시에 적재될 수 있다.&lt;/p&gt;

&lt;p&gt;메모리의 블록이 캐싱되면 매핑되어있는 캐시 라인에 적재된다. 그러나 앞에서 말했듯이 캐시 라인수는 전체 블록수보다 작기 때문에 캐시 라인은 여러 블록에 의해 공유된다. 그리고 캐시의 각 라인에는 현재 어느 블록이 저장되어있는지를 구분해주는 &lt;strong&gt;태그(tag)&lt;/strong&gt;가 함께 저장된다. 이와 같이 블록이 어떤 캐시 라인을 사용할 것인지를 결정하는 것을 사상이라고 하는데 여기에는 여러 방법이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(3) 사상 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;사상 방식(mapping scheme)은 메모리의 어떤 블록들이 캐시의 어떤 라인을 공유하며 사용할 것인지를 결정해주는 방식이다. 사상방식에는 대표적으로 직접 사상, 완전연관사상, 세트연관사상이 있다. 이제부터 각 방식에 대해 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(a) 직접 사상(direct mapping)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;각 블록은 미리 정해진 캐시 라인에만 적재될 수 있다. 이 방식을 위해 메모리의 주소는 아래와 같이 3개의 필드로 나누어서 해석한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/direct_mapping_field.png&quot; alt=&quot;direct_mapping_field&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 태그필드 : 라인을 공유하는 2^t개의 블록들을 서로 구분
b) 라인필드 : 캐시의 m=2^l개의 라인들 중 블록이 저장될 라인을 지정
c) 단어필드 : 각 블록내의 단어들을 서로 구분
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;라인당 2^t개의 블록이 공유되니 전체 블록의 수는 2^(t+l)개로 볼 수 있다. 따라서 태그필드와 라인필드의 (t+l)비트를 블록 번호로 간주한다.&lt;/p&gt;

&lt;p&gt;사상방식에서 블록j가 적재될 캐시 라인번호 i는 아래의 식과 같이 모듈로(modulo) 함수에 의해 결정된다.&lt;/p&gt;

&lt;p&gt;i = j mod m&lt;/p&gt;

&lt;p&gt;즉 블록 번호를 캐시의 전체 라인수로 나눈 나머지를 계산하여 블록이 저장될 라인 번호를 결정한다.&lt;/p&gt;

&lt;p&gt;결과적으로 캐시의 한 라인에는 태그(저장된 블록 번호)와 단어(데이터)가 함께 저장된다.&lt;/p&gt;

&lt;p&gt;이제 CPU의 읽기 동작에서 캐시 적중 여부를 검사하는 원리를 이해할 수 있다. 아래 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/direct_mapping_cache.png&quot; alt=&quot;direct_mapping_cache&quot; width=&quot;70%&quot; height=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CPU가 보낸 메모리 주소를 캐시에서 먼저 검사한다. 여기서 라인필드를 보고 캐시의 해당 라인으로 찾아간다. 이 때 주소의 태그필드와 캐시에 저장된 태그번호가 같으면 해당 내용은 캐시에 있는 것이므로 캐시 적중이다. 캐시 적중이면 주소 단어필드의 값을 통해 해당 단어(데이터)가 캐시에서 인출되어 CPU로 보내진다. 만약 두 태그가 일치하지 않거나 캐시의 해당 라인이 비어있으면 캐시미스이므로 주소가 메모리로 보내져 한 블록이 메모리에서 인출되고 이것이 캐시에 적재된다. 그런데 이미 해당 라인에 다른 블록이 저장되어있으면 그 내용은 지워지고 새로 꺼내온 데이터로 교체된다.&lt;/p&gt;

&lt;p&gt;아래 그림은 사상 방식이 적용된 메모리와 캐시의 예를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/direct_mapping_example.png&quot; alt=&quot;direct_mapping_example&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메모리의 각각 한 줄은 하나의 블록을 나타낸다. 단어비트가 모두 00인 이유는 각 블록의 4개의 워드 중 가장 첫 번째 워드의 주소만 나타냈기 때문이다.&lt;/p&gt;

&lt;p&gt;캐시가 8개의 라인을 가지고 있고, 이는 주소의 라인필드 3비트로 구분한다. 그리고 최상위 2비트는 태그로 사용된다. 태그와 라인을 합친 총 5비트가 블록번호이며 이를 캐시 전체 라인수 8로 나눈 나머지가 계산되어 캐시의 해당 라인에 저장된다. 그런데 태그비트 부분은 이미 8의 배수이므로 실질적으로 3비트만 따져주면 되며 이것이 곧 라인 필드 값이다.&lt;/p&gt;

&lt;p&gt;위 그림의 예로 CPU가 주소 0101000를 보낸 경우를 생각해보자. 먼저 라인 번호는010으로 라인 2이다. 라인 2의 태그는 현재 11이다. CPU가 보낸 주소의 태그는 01이므로 서로 불일치하고 캐시미스가 된다. 따라서 메모리의 0101000번지로 찾아가 해당 블록을 모두 꺼내어 캐시의 라인2번 내용을 교체한다. 즉, 태그는 01로 교체되고 단어는 “info”로 대체된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
지금까지 설명한 직접매핑의 단점은 하나의 블록이 저장될 수 있는 캐시 라인이 한 개 뿐이라는 것이다. 만약 라인을 공유하는 두 블록이 번갈아가며 필요한 경우에는 캐시가 반복적으로 교체될 것이고 이로인해 캐시 적중률이 낮아지며 오버헤드가 증가할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(b) 완전 연관사상(fully-associative mapping)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;블록이 캐시의 어떤 라인으로든 적재될 수 있도록 허용함으로써 직접사상의 단점을 보완한다. 따라서 완전연관사상 방식에서는 주소에 적재될 캐시 라인이 지정되는 라인 필드가 없다. 직접사상에서 태그 필드와 라인 필드로 사용하던 비트를 모두 태그 필드로 사용한다. 결과적으로 태그값이 메모리의 블록 번호와 같아진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/fully_associative_mapping_field.png&quot; alt=&quot;fully_associative_mapping_field&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 방식에서는 라인필드가 없으므로 캐시 적중 여부를 검사할 때 주소의 태그 필드와 캐시의 모든 라인의 태그값들을 비교해야한다. 이를 순차적으로 하나씩 하면 시간이 오래 걸리므로 병렬적으로 처리하기 위한 하드웨어를 구성해야한다. 아래 그림은 완전연관사상이 적용된 캐시 조직이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/fully_associative_mapping_cache.png&quot; alt=&quot;fully_associative_mapping_cache&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;특징은 비교기로 모든 캐시 라인의 태그가 입력된다는 점이다.&lt;/p&gt;

&lt;p&gt;캐시히트가 일어난 경우에는 캐시에 저장된 블록에서 CPU가 필요한 워드를 인출한다. 캐시미스가 발생했을 경우에는 메모리로부터 데이터 블록을 인출한다. 이후에 캐시에 빈 라인들 중 한곳에 태그와 블록내용을 같이 저장한다. 그런데 문제는 빈 라인이 없을 경우이다. 이 경우에는 정해진 교체 알고리즘에 따라 라인들 중 하나를 선택하여 새로 인출된 블록으로 교체한다. 이 알고리즘을 교체알고리즘이라고 하는데 오래된 라인 혹은 최근 액세스 횟수가 가장 적은 라인이 선택될 수 있다.&lt;/p&gt;

&lt;p&gt;완전연관사상은 라인 선택이 자유롭기 때문에 배열 전체가 캐시에 적재되어 데이터 지역성을 최대한 활용하는등의 이점이 있다. 다만 모든 태그를 병렬로 검사하기 위한 병렬처리 하드웨어를 포함해야하므로 매우 높은 비용이 든다. 따라서 실제로는 거의 사용되지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(c) 세트 연관사상(set-associative mapping)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;세트연관사상은 직접연관사상과 완전연관사상 각각의 장점을 취한 절충안이다. 이 방식에서 주소는 태그필드, 세트필드, 단어필드로 나누어진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/set_associative_mapping_field.png&quot; alt=&quot;set_associative_mapping_field&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직접연관사상의 라인 필드가 세트필드로 대체된 형태이다.&lt;/p&gt;

&lt;p&gt;캐시는 v개의 세트로 나누어지며, 각 세트마다 k개의 라인을 가진다. 따라서 캐시의 총 라인수 m = v × k 이다.&lt;/p&gt;

&lt;p&gt;이때 j번 블록이 적재될 수 있는 캐시의 세트번호는 i = j mod v 이다. 즉, 블록 번호를 세트번호로 나눈 나머지를 계산결과를 블록이 저장될 세트 번호로 사용한다. 직접사상에서 라인 번호가 정확히 지정되는 것과 다르게 여기선 세트 번호까지만 지정되고 이후에 세트에 포함된 라인들 중의 하나에 저장된다.&lt;/p&gt;

&lt;p&gt;아래 그림은 세트 연관사상 방식에서 데이터를 읽어오는 동작을 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/set_associative_mapping_cache.png&quot; alt=&quot;set_associative_mapping_cache&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 세트당 라인이 2개인 2-way 세트 연관사상 방식을 나타낸다. 세트당 라인이 k개이면 k-way 세트 연관사상이라 부른다. 아무튼 위 그림에서는 CPU에서 발생된 주소의 세트 필드값을 확인 후 캐시의 해당 세트로 이동한다. 해당 세트의 태그들 중 주소의 태그와 일치하는 태그가 있다면 캐시 적중이고 없다면 캐시 미스이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
이 방법은 직접 사상과 완전 연관사상의 절충적인 방법이라고 했었다. 만약 세트수와 라인수가 같다면 이는 직접 사상 방식과 같고 세트수가 1이라면 완전 연관 사상 방식과 같아진다. 일반적으로는 세트당 라인수가 2개인 2-way 세트 연관 사상이 가장 보편적으로 사용된다. 물론 2-way보다는 4-way 세트 사상 방식을 사용하면 캐시 적중률이 조금 더 올라가겠지만 드는 비용에 비해 2-way 연관사상과의 적중률 차이가 별로 크지 않다고 알려져 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(4) 교체 알고리즘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;사상방식을 설명할 때 캐시미스의 경우 메모리에서 데이터 블록을 가져와서 캐시에 적재한다고 말했다. 직접사상의 경우는 적재될 수 있는 라인이 유일하므로 선택의 여지없이 교체가 되지만, 완전연관사상이나 세트연관사상에서는 어떤 블록을 지워야할지 선택하기 위한 교체 알고리즘이 필요하다. 여기서는 대표적인 4가지에 대해 간단히 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(a)LRU(Least Recently Used)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최근 액세스 사용되지않은채로 가장 오래 적재되어있던 블록을 교체한다. 가장 흔히 사용하는 2-way 세트 연관 사상 방식에서는 LRU 알고리즘을 구현하기 위해 USE비트를 사용한다. 세트 내 두개의 라인 중 최근 액세스 된 블록의 USE비트가 1로 세트되고, 다른 하나의 USE 비트는 0으로 리셋된다. 새로운 블록이 메모리에서 적재될 때 USE비트가 0인 블록을 대체한다.&lt;/p&gt;

&lt;p&gt;실제로 더 최근에 사용된 데이터가 앞으로 사용될 가능성이 높다는 가정이 맞는 경우가 많기 때문에 LRU 알고리즘은 높은 캐시히트를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(b)FIFO(First-In-First-Out)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;가장 오래된 블록이 교체된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(c)LFU(Least Frequency Used)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;캐시에 적재된 이후 액세스 횟수가 가장 작은 블록을 교체한다. LRU랑 헷갈릴수도 있지만 LRU는 최근 참조횟수가 작은 블록의 교체이고 LFU는 적재이후로 액세스 횟수가 가장 작은 블록의 교체이다. 액세스 횟수를 카운트하기 위한 하드웨어의 추가가 필요하기때문에 LRU에 비해 잘 사용되지 않는 편이다.&lt;/p&gt;

&lt;p&gt;** (d)Random**&lt;/p&gt;

&lt;p&gt;랜덤으로 하나의 블록을 제거한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(5) 쓰기 정책&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;쓰기정책은 캐시의 내용이 변경되었을 때 메모리에 그 내용을 갱신하는 시기와 방법을 결정하는 것이다.&lt;/p&gt;

&lt;p&gt;CPU가 명령어를 실행하는 중에 캐시에 있는 데이터를 수정하였을 경우 메모리에 있는 내용과 달라진다. 이 때 외부 장치에서 메모리의 데이터를 읽어간다면 잘못된 결과를 초래한다. 따라서 메모리의 데이터도 캐시의 내용과 똑같이 업데이트 해주어야한다.&lt;/p&gt;

&lt;p&gt;그런데 메모리에 데이터를 쓰는 행위는 캐시에 데이터를 쓰는것에 비해 오랜 시간이 걸린다. 따라서 캐시 데이터가 수정될 때 마다 메모리의 내용을 업데이트 하지 않고 캐시 미스로 인해 캐시 라인의 데이터가 변경될 경우 혹은 외부에서 메모리의 데이터를 일겅가려하는 경우 업데이트 해주는 방식을 사용하기도 한다.&lt;/p&gt;

&lt;p&gt;여기에서는 대표적인 두 가지 쓰기정책을 소개한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(a) write-through&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;캐시의 내용이 수정될 때 동시에 메모리의 데이터를 업데이트 해주는 방식이다. 가장 간단한 방식이다. 단점은 메모리의 내용을 매번 갱신해주는데 시간이 소요된다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) write-back&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;캐시 라인이 M(modified)라는 비트를 포함한다. 이 비가 1로 세트 되어있으면 데이터 캐싱 이후 수정이 되었다는 것이다. 이후 캐시미스로 해당 라인이 교체될 때 캐시의 내용을 메모리로 업데이트 시켜준다. 다만 캐시 내용이 메모리로 업데이트 되기 전까지는 해당 메모리 블록이 무효상태에 있게 된다는 문제점이 존재한다. 또한 캐시의 수정상태를 기록하기 위해 모든 라인이 추가적인 비트를 포함해야 하고 여기에는 추가적인 하드웨어 회로가 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
아래 그림은 write-through 쓰기정책과 write-back 쓰기정책의 동작을 간단히 나타낸 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/cache_write_policy.png&quot; alt=&quot;cache_write_policy&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(6) 다중 캐시&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;요즘에는 일반적으로 캐시를 하나만 사용하지 않고 여러개를 사용하는 다중캐시를 사용하여 성능을 더욱 끌어올린다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;온 칩 캐시(On-Chip Cache)&lt;/strong&gt;는 CPU 내부의 1레벨 캐시와 외부에 2레벨 캐시를 동시에 두는 방식이다. 1레벨 캐시는 CPU내부에 존재하므로 외부버스가 필요없이 내부버스만으로 데이터가 이동할 수 있어 더욱 빠른 액세스를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;분리 캐시&lt;/strong&gt;는 용도에 따라 캐시를 분리하여 두는 방식이다. 명령어와 데이터 캐시를 따로 두어 명령어 파이프라인에서 명령어 인출단계와 오퍼랜드 인출단계 사이의 캐시 충돌을 방지할 수 있다.&lt;/p&gt;

&lt;p&gt;아래는 인텔 i7-990X 쿼드코어 프로세서의 3레벨 캐시 구조를 나타낸 그림이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/i7-990X_cache.png&quot; alt=&quot;i7-990X_cache&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-ddr-sdram&quot;&gt;6. DDR SDRAM&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;메모리의 속도 향상은 반도체 기술 발달에 따른 CPU의 속도 향상을 따라잡지 못하고 있다. DRAM의 직접도가 높아져 면적당 용량은 향상됐지만 속도는 아직 CPU에 비하면 현저히 떨어진다. 둘의 속도차에서 오는 병목현상 해결을 위해 여러가지 기술이 개발되었다. 여기서는 전통적인 DRAM의 데이터 전송방식을 변경하여 속도를 개선시킨 SDRAM과 이를 더욱 보강시킨 DDR SDRAM에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(1) SDRAM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SDRAM은 동기식 DRAM(Synchronous Dynamic Random Access Memory)으로 DRAM의 액세스 속도 한계 극복을 위해 개발된 반도체 기억장치이다. 동기식이라 함은 CPU 클럭 주기에 맞추어 데이터를 전송한다는 의미를 가진다.&lt;/p&gt;

&lt;p&gt;먼저 전통적인 DRAM의 원리를 보자. DRAM에서는 읽기/쓰기 신호가 들어오는 즉시 해당 주소의 데이터에 액세스하여 동작을 수행한다. 그런데 연속적인 신호가 들어오면 해당 동작들이 종료될 때 까지 CPU는 다른일을 하지 못한다. 또한 시스템 버스 권한도 메모리에 붙잡혀있게된다. 이 때문에 전체적인 지연시간이 생긴다.&lt;/p&gt;

&lt;p&gt;반면 SDRAM은 클록 신호 주기에 맞추어 모든 동작들이 수행된다. 아래는 SDRAM의 읽기동작 과정에 대한 설명이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) CPU는 한 클럭 주기동안 시스템 버스를 통해 주소와 읽기 신호를 메모리로 내보낸다. 이후에는 결과를 기다리지 않고 다른 연산을 수행한다.
(b) SDRAM은 신호를 받는 즉시 동작을 수행한다. 동작이 완료되면 시스템버스 권한을 얻은다음 다음 클록 주기에서 데이터를 CPU로 보낸다.
(c) CPU가 데이터를 받는다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
SDRAM은 여러개의 뱅크(bank)들로 이루어져있다. 여러개의 뱅크에 동시 액세스가 가능하여 뱅크별로 서로 다른 동작 수행이 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/sdram_bank_architecture.png&quot; alt=&quot;sdram_bank_architecture&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;512Mbit SDRAM이 있다고해보자. 이 칩은 16M×8bit 뱅크 4개로 이루어져있다. 16M×8bit 뱅크가 8K개의 행을 가지고 있다면 각 행에는 2K개의 8bit 메모리 셀이 있는 것이다. 따라서 행주소에는 13비트가 필요하고 열 주소에는 11비트의 주소가 필요하다.&lt;/p&gt;

&lt;p&gt;뱅크에서 행 주소에 의해 행이 선택되면 해당 행의 모든 데이터가 감지 증폭기(sense amplifier)로 이동한다. 이 동작을 ‘행을 연다(opening the row)’라고 한다. 열린 행의 데이터들은 워드(여기서는 1byte)단위로 선택되어 데이터 버스에 실린다. 데이터 액세스에서는 행을 여는데 시간이 오래 걸리지만 이미 증폭기에 실린 데이터를 전송하는것은 한 클록 주기만에 가능하다. 따라서 이후부터는 여러개의 데이터를 매 클록 주기마다 연속으로 전송할 수 있다.&lt;/p&gt;

&lt;p&gt;위와 같은 연속 동작을 버스트 모드(burst mode)라고 한다. 한 번의 버스트 모드 동안 전송되는 데이터 수를 버스트 길이(burst length)라고 하며 이 값은 보통 2,4, 혹은 8이다.&lt;/p&gt;

&lt;p&gt;아래 그림은 버스트 읽기 동작을 나타낸 흐름도이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/burst_mode_read_timing_diagram.png&quot; alt=&quot;burst_mode_read_timing_diagram&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;열 주소가 래치되기 시작한 순간부터 데이터가 인출되어 버스에 실릴 때까지의 시간을 CAS 지연이라하며 일반적으로 두 클록 주기 정도이다. 위 그림의 버스트 읽기 모드에서 4개의 바이트 데이터가 연속적으로 전송되는것을 볼 수 있다.&lt;/p&gt;

&lt;p&gt;그러나 버스트 쓰기 모드에서는 열 주소가 인가되는 순간부터 데이터도 같이 쓸 수 있기때문에 CAS 지연이 발생되지 않는다.&lt;/p&gt;

&lt;p&gt;결과적으로 여러개의 뱅크가 있고 각 뱅크마다 행 열기를 통해 한 행의 모든 데이터를 감지증폭기에 올려둠으로써 주소 해독, 액세스에 의한 지연 없이 매 CPU 클록 주기마다 한 바이트씩의 데이터가 연속적으로 보내지는 효과를 얻을 수 있는 것이다.(물론 CAS 지연은 존재하지만) 만약 위의 SDRAM 칩을 사용해 한 번에 64비트씩의 데이터 전송이 가능한 모듈을 구성하려면 8개를 병렬로 연결하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(2) DDR SDRAM&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SDRAM에서는 이미 뱅크 행의 전체 데이터가 감지증폭기에 들어가 있는 상황에서 버스트모드를 통해 매 클럭주기마다 연속적으로 데이터를 전송하는 것에 대해 알았다. 이제 여기서 버스 클록 주파수(진동수)만 더 높일수있다면 데이터 전송 대역폭(bandwidth)을 더욱 높일 수 있다.&lt;/p&gt;

&lt;p&gt;DDR이란 Double Data Rate의 약자로 SDRAM이 한 클록주기당 두 번 데이터를 전송할 수 있게 해주는 기술이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/5/double_data_rate.png&quot; alt=&quot;double_data_rate&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우리가 알다시피 SDRAM에서는 매 클럭 주기마다 한 번씩 데이터를 보낸다. 한 클럭 주기 신호에는 상승엣지(rising edge) 1번, 하강엣지(falling edge) 1번이 있다. SDRAM에서는 상승엣지에서만 데이터를 전송하는것과 달리 DDR SDRAM에서는 데이터전송을 위해 두 엣지를 모두 사용한다.&lt;/p&gt;

&lt;p&gt;이후 클록의 주파수를 2배 더 높인 기술을 사용하는 DDR2 SDRAM도 개발되었다.&lt;/p&gt;

&lt;p&gt;DDR(Double Data Rate) 기술의 핵심은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(a) 데이터전송에 클록의 상승엣지와 하강엣지를 모두 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(b) 하드웨어 회로를 개선함으로써 클록 주파수를 높인다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;현재 개발된 DDR3, DDR4 기술 역시 위의 원리에 바탕을 두고있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;(3) 메모리 랭크&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리 랭크(memory rank)란 데이터 전송폭이 64bit가 되도록 구성한 SDRAM의 집합, 즉 모듈이다. 메모리 산업표준그룹에서 제정된 표준 기억장치 랭크가 64bit이기 때문에 일반적으로 메모리 칩들을 병렬로 연결하여 64bit 폭의 모듈을 구성하여 사용한다.&lt;/p&gt;

&lt;p&gt;만약 x4 칩을 사용한다면 16개의 SDRAM칩이 필요하고, x8 칩을 사용하면 8개로 하나의 메모리 랭크를 구성할 수 있다.&lt;/p&gt;

&lt;p&gt;메모리 칩을 병렬로 연결시킨 기억장치 모듈은 메인보드의 메모리 슬롯에 장착된다. 여기에서 한 면에만 칩들을 장착시킨 단면 모듈을 SIMM(single in-line memory module), 양면에 칩들을 장착시킨 양면 모듈을 DIMM(dual in-line memory module)이라고 부른다.&lt;/p&gt;

&lt;p&gt;예를들어 x8칩을 사용해 각각의 면에 8개씩 붙이면 각 면은 64bit의 데이터 폭을 가지는 랭크가 된다. 이를 양면 2중랭크 모듈이라 부른다. 이를 한 면에만 붙이면 단면 단일랭크 모듈이라 부른다. 만약 모듈이 x4칩들로 만들어졌다면 양면이 합쳐서 64bit의 데이터폭을 가지게되므로 양면 단일랭크 모듈이 된다.&lt;/p&gt;</content><author><name>nobbaggu</name></author><category term="메모리" /><category term="기억장치" /><category term="RAM" /><category term="액세스" /><category term="직접액세스" /><category term="임의액세스" /><category term="직접액세스" /><category term="연관액세스" /><category term="액세스" /><category term="랜덤액세스" /><category term="access" /><category term="direct" /><category term="random" /><category term="sequential" /><category term="대역폭" /><category term="휘발성" /><category term="비휘발성" /><category term="해독기" /><category term="디코더" /><category term="sdram" /><category term="ddr" /><category term="cache" /><category term="캐시" /><category term="랭크" /><category term="뱅크" /><summary type="html">목차 기억장치의 분류와 특성 계층적 기억장치시스템 반도체 기억장치 기억장치 모듈의 설계 캐시 메모리 DDR SDRAM 차세대 비휘발성 기억장치 0. Intro 기억장치는 말그대로 데이터를 저장하기 위한 하드웨어를 말한다. 기억장치는 크게 내부 기억장치와 외부 기억장치로 나뉜다. 내부 기억장치는 흔히 알고있는 메모리로서 CPU가 직접 액세스할 수 있다. 외부 기억장치는 디스크나 외장하드, CD-ROM과 같은 보조 저장장치의 용도로 사용되며 CPU가 직접 액세스 할 수 없다. 이번 챕터에서는 일반적으로 메모리라고 부르는 내부 기억장치에 대해 설명한다. 1. 기억장치의 분류와 특성 기억장치의 데이터를 읽거나 쓰기 동작을 액세스(access)라고 한다. 기억장치는 제조 공정과 구조에 따라 액세스 방법이 달라지는데 그 유형은 아래와 같다. 1) 순차적 액세스(sequential access) 처음부터 순차적으로 액세스한다. 이 방식의 예시로는 자기 테이프(magnetic tape)이 있다. 데이터는 레코드(record)라 불리는 단위로 구분되며 각 레코드별로 주소가 할당되어있다. 한 쪽으로 감겨있는 자기테이프의 특정 위치에 데이터를 쓰기 위해서는 그 위치까지 재생시켜 통과시켜야한다. 즉, 특정 위치에 액세스하기 위해서는 시간이 걸린다. 2) 직접 액세스(direct access) 데이터가 레코드 혹은 블록으로 구분지어져있다. 특정 블록 내의 특정 위치에 액세스를 하기위해서는 해당 블록의 처음 위치로 이동한 후 그 위치까지 순차적 액세스를 실행해야한다. 직접 액세스를 사용하는 장치로는 CD-ROM, DVD등이 있다. 3) 임의 액세스(random access) 별도의 일기/쓰기 회로가 존재한다. 따라서 어떤 위치로든 바로 액세스할 수 있다. 특정 위치까지 이동하는 시간이 필요없고 어느 위치로 액세스하던지 같은 시간이 걸린다. 반도체 기억장치들이 임의 액세스 방식을 사용한다. 4) 연관 액세스(associative access) 임의 액세스를 응용한 방식이다. 다른점은 키(key)와 값(value)이 같이 저장되어있다. 임의 액세스가 주소를 통하여 액세스 하는것과 다르게 키를 이용하여 액세스한다. 즉 액세스 요구에는 주소가 아닌 키의 비트 패턴이 포함되고 이를 데이터의 각 키와 비교하여 일치하는 곳으로 액세스한다. 중요한 점은 키 값을 하나씩 순차적으로 비교하는 방식이 아닌 동시에 모든 키들과 비교하므로 액세스 시간이 소요되지 않는다는 점이다. 기억장치 시스템에서는 저장할 수 있는 용량(capacity)와 액세스 속도(access speed)가 중요하다. 이와 관련된 기억장치의 개념을 몇 가지 알아보자. a) 전송 단위(unit of transfer) CPU가 한 번에 액세스할 수 있는 메모리의 비트 수이다. 다시말해 CPU와 메모리 사이에 연결된 데이터 선의 수와 같다. b) 주소지정 단위(address unit) 하나의 주소에 할당된 메모리 용량이다. 일반적으로 바이트(byte)가 주소지정 단위이다. 때로는 워드(word)를 사용하기도 한다. 만약 CPU가 주소지정을 위해 사용하는 비트수가 A라면 2^A개의 주소가 지정될 수 있다. 이 때 주소지정단위가 BYTE라면 사용할 수 있는 메모리 크기는 2^A 바이트가 된다. 혹은 주소지정단위가 워드(word)이고 1워드가 4바이트라면 4*2^A 바이트만큼의 메모리를 사용할 수 있다. 프로그램의 성능에 직접적인 영향을 끼치는 메모리의 액세스 속도와 관련된 몇 가지 파라미터들에 대해 알아보자. 1) 액세스 시간(access time) 읽기/쓰기 신호가 메모리에 도착한 순간부터 읽기/쓰기가 완료되는데 걸리는 시간이다. 순차적 액세스 방식이나 직접 액세스에서는 데이터가 저장된 위치별로 다르지만 랜덤 액세스 방식을 사용하는 메모리에서는 데이터가 저장된 위치, 즉 주소에 상관없이 액세스 시간이 동일하다. 2) 기억장치 사이클 시간(memory cycle time) 최근에 개발되고 있는 FRAM같은 경우는 데이터를 읽은 후에는 데이터가 소멸되고 다시 자동적으로 복원된다. 기억장치 사이클 시간은 액세스 시간과 데이터 복원시간을 합친 것이다. 우리가 흔히 알고있는 반도체 메모리같은 경우는 액세스시간과 기억장치 사이클시간이 같다. 3) 데이터 전송률(data transfer rate) 1초당 읽거나 쓸 수 있는 비트 수를 말한다. 예를들어 액세스 시간이 100ns이고, 전송단위가 1바이트라면 데이터 전송률은 1byte/100ns = 10MByte/s가 된다. 추가적으로 메모리 제조에 사용되는 재료에 의한 구분도 있다. 크게 반도체 메모리, 자기표면 메모리, 광 메모리 등이 있다. 자기표면 기억장치나 광학 메모리는 비휘발성인데 반해 반도체 메모리는 휘발성, 비휘발성 두 종류가 있다. 2. 계층적 기억장치시스템 컴퓨터 성능에서 가장 큰 부분을 차지하는 CPU의 속도는 매우 향상되었다. 그러나 기억장치의 처리속도가 느리다면 CPU가 아무리 빠르더라도 메모리에서 병목현상이 일어난다. 대기시간만큼 컴퓨터는 느려질 수 밖에 없다. 따라서 메모리 액세스 시간 또한 컴퓨터 성능에서 매우 중요한 부분을 차지한다. 이번 평균 액세스 속도는 높이면서 성능대비 가격도 적절히 유지할 수 있도록 적절한 계층적 기억장치 시스템(hierarchical memory system)을 구성하는 방법과 효과에 대해 알아본다. 1) 필요성 및 효과 주기억장치와 CPU 사이의 속도차이도 문제지만 대용량 저장을 위한 일반적인 보조저장장치(디스크)는 일반적으로 메모리보다 액세스 속도가 10만배 가량 느리다. 따라서 메모리의 크기가 작으면 한 번에 올릴 수 있는 데이터량이 작으므로 필요할 때 마다 디스크 입/출력이 발생하므로 그만큼 성능저하는 더욱 심각해진다. 즉, 메모리의 용량이 클수록 더 많은 데이터를 CPU 가까이 위치시킬 수 있기 때문에 액세스 시간은 짧아진다. 그러나 부피 문제와 가격 문제로 인해 메모리 크기를 무한정 키울 수 없다. 메모리를 구성할 때는 속도뿐만 아니라 기능, 용량 및 가격까지 고려해야한다. 이러한 여러 조건들을 충족시키기 위해 여러개의 다른 종류의 기억장치들을 분리하여 계층적으로 구성한다. 캐시 메모리, 레지스터, 범용 메모리 등으로 나누는 이유가 이 때문이다. 즉, 컴퓨터 시스템에서 기억장치를 구성할 때는 속도, 용량, 가격 사이의 trade-off가 필요하다. 기억장치의 속도, 용량, 가격 사이에는 아래와 같은 관계들이 성립한다. a) 액세스 속도가 높아질수록 비트당 가격이 높다 b) 용량이 커질수록 비트당 가격은 낮다 c) 용량이 커질수록 액세스 속도는 낮다 따라서 컴퓨터의 사용 목적에 따라 더 크고 싸지만 속도는 느린 메모리를 구성할지, 가격은 비싸지만 액세스 속도가 빠른 메모리 종류를 추가할지를 결정하면 된다. 아래 그림은 계층적 기억장치 시스템을 구성함으로써 얻을 수 있는 이점을 설명하기 위한 그림이다. 위 그림에서 L1 메모리의 액세스 시간이 10ns, L2 메모리의 액세스 시간이 100ns라고 가정하고, 두 메모리만을 사용한다고 해보자. 프로그램 실행 과정에서 필요한 데이터의 50%가 L1, 나머지 50%가 L2에 있다고 가정했을 때 평균 액세스 시간은 0.5*10ns + 0.5*100ns = 55ns이다. 만약 8:2 비율로 있다면 28ns이다. 모든 데이터가 L1에 있다면 평균 액세스시간은 10ns가 된다. 일반적인 프로그램이 실행되는 동안에 액세스하는 메모리의 위치를 조사해보면 특정 구역에 집중되는 경향이 있다. 그 이유는 대부분의 프로그램이 특정 반복문이나 서브루틴 함수를 여러번 반복해서 호출하기 때문이다. 만약 프로그램 실행이후 얼마간의 시간이 지나고 자주 사용되는 데이터를 L1에 올리고 나머지는 L2에 두고 사용하면 평균 액세스 시간이 단축되어 더욱 신속하게 데이터를 읽어올 수 있다. 위와 같은 현상을 지역성의 원리(principle of locality)라고 한다. 대부분의 프로그램에는 이 원리가 적용되기 때문에 L1계층의 메모리에 대한 액세스가 L2계층에 비해 많다. 다시말해 계층적 기억장치 구성은 프로그램의 성능을 끌어올려준다. 2) 기억장치 계층 아래 그림은 요즘의 컴퓨터에 적용된 계층적 기억장치 시스템을 보여준다. 위 그림에서 상위 계층으로 갈수록 아래의 특징이 뚜렷해진다. (a) 가격 상승 (b) 용량 감소 (c) 액세스 시간 단축 (d) CPU에 의한 액세스 빈도 상승 특히 특징 (d)는 지역성의 원리를 활용하기 위한 계층적 기억장치의 특징을 가장 잘 나타낸다. 일반적으로 CPU 내부에는 일반목적, 특수목적 레지스터들이 수십개 정도(비싼 CPU의 경우 수백개) 있는데 레지스터의 경우에는 CPU 1클럭 주기 내에 데이터 액세스가 가능할 만큼 빠르다. CPU만큼 빠르거나 주기억장치만큼 크지는 않은 캐시 메모리(cache memory)가 있다. 캐시는 프로그래머가 직접 다룰 수 없고 운영체제에 의해 자주 사용하는 데이터가 캐시 히트(cache hit)되어 캐시 메모리에 적재된다. 캐시는 CPU와 메모리 사이의 속도차이를 보완하기 위해 사용된다. 레지스터, 캐시, 메모리 사이의 액세스 시간에는 아래와 같은 관계가 성립된다. 레지스터(~1ns) &amp;lt; 캐시(2~10ns) &amp;lt; 메모리(~100ns) 지금까지 설명한 이유들로 인해 계층적으로 기억장치를 구성하면 평균 액세스 시간은 단축시키고 전체적인 용량은 향상시키면서도 적절한 가격을 유지할 수 있다. 레지스터, 캐시, 주기억장치는 CPU가 주소를 지정하고 직접 액세스를 할 수 있는 내부 기억장치였다. 외부 기억장치(ex. SSD, CD-ROM, 하드디스크)는 장치의 제어기를 통하여서만 데이터 교환이 가능하다. 지금부터는 내부 기억장치에 초점을 맞춰 반도체 메모리와 캐시의 동작 및 원리에 대해 알아본다. 3. 반도체 기억장치 아주 오래전에는 자기 코어로 만들어진 자화의 원리를 사용한 기억장치를 사용했지만, 전자공학의 발전 이후 메모리는 거의 반도체로 만들어진다. 1) RAM RAM(Random Access Memorey)은 이름대로 임의 액세스를 하는 기억장치를 말한다. ROM(Read Only Memory)와 다르게 읽기와 쓰기가 모두 가능하다. 아래 그림과 같은 1K×8비트 용량의 RAM이 있다고 하자. RAM의 워드(word)는 8bit이고, 1K(1024)개의 주소 지정이 가능하다. 따라서 사용할 수 있는 메모리 용량은 1KByte이다. 1024=2^10개의 주소지정을 위해서 주소 버스의 폭은 10비트가 필요하다. 또한 워드는 8bit이므로 데이터 교환을 위한 데이터 버스의 폭은 8bit이다. 위에서 CS(chip select) 비트는 여러개의 칩을 사용하는 기억장치 시스템에서 사용하는 칩 선택 신호이다. RD는 읽기 신호, WR는 쓰기 신호이다. 위 도표에서는 1이 될 때 해당 신호가 활성화(active-high) 된 것으로 가정하였다.실제 대부분의 칩에서는 0이 될 때 활성화되는 active-low 신호를 사용한다.) RAM의 특징중 하나는 휘발성(volatile)이다. 전원 공급이 중단되면 데이터가 소멸된다. 즉, RAM은 일시적 기억장치로만 사용된다. ※DRAM vs SRAM a) DRAM(Dynamic RAM) DRAM은 데이터 저장을 위해 커패시터(capacitor)를 사용한다. 커패시터에 전하가 충전(charge)되어있으면 1, 아니면 0이다. 커패시터는 시간이 지남에따라 방전되는 성질로 인해 재충전이 필요하다. b) SRAM(Static RAM) SRAM은 데이터 저장을 위해 플립플롭(flip-flop)을 사용한다. 따라서 데이터가 안정된 상태로 유지될 수 있으므로 재충전이 필요하지 않다. DRAM과 SRAM은 모두 전원공급이 중단되면 데이터를 잃는 휘발성이다. DRAM에 비해 SRAM은 소자 하나의 부피가 크고 가격이 비싸다. 따라서 같은 면적에 더 많은 셀을 얹을 수 있는 DRAM이 SRAM에비해 가격이 싸다. 그러나 SRAM은 반도체 소자인만큼 속도가 DRAM보다 빠르다. 이러한 특성으로 인해 DRAM은 일반적인 메모리로 사용되고 SRAM은 캐시로 사용된다. RAM의 주소지정 원리를 보기 전 실제는 존재하지 않는 간단한 8×8비트 메모리의 주소지정에 대해 살펴보자. 8×8은 8개의 주소가 있고 각 주소당 8bit의 기억장소가 할당되는 메모리를 의미한다. 즉 총 용량은 64bit가 된다. 8개의 주소지정을 위해서는 3개의 주소선이 필요하다.(2^3=8) 해독기를 통하여 주소 비트가 해독되어 8개의 출력선들 중의 하나를 활성화시킨다. 이 메모리의 워드는 8비트이므로 데이터 교환을 위해서는 8비트 폭의 데이터 버스가 필요하다. 만약 이와같은 구조를 가지는 RAM의 전체 용량이 1Mbit(128K×8bit)라면 128K(128×2^10 = 2^17)개의 주소지정을 위해 17개의 주소선이 필요하다. 이제는 더 큰 용량의 메모리에 위 원리를 적용해보자. 다만 위에서는 기억장소들이 한 방향으로 선형적으로 나열되어있는 1차원 메모리를 가정하였으나 여기서는 2차원 메모리를 보여준다. 따라서 메모리의 주소지정을 위해서는 행(row) 주소와 열(column)주소를 따로 사용한다. 위 그림에서는 행주소와 열주소가 각각 행주소 버퍼와 열주소 버퍼로 들어간다. 이후 각각이 행 주소 해독기와 열 주소 해독기에 의해 해독되어 기억장소를 선택한다. 그림에서는 기억소자가 총 16M(=2^24)개 존재한다. 따라서 주소지정을 위해서는 24비트의 주소선이 필요하다. 그러나 실제로는 12비트의 주소선만 있어도 된다. 그 이유는 아래의 타이밍도를 통해 살펴보자. 일단 CPU는 24비트의 메모리 주소를 생성한다. 그들 중 상위 12비트는 행주소로, 하위 12비트는 열주소로 사용된다. RAS(Row Address Signal)과 CAS(Column Address Signal)는 메모리 제어기에 의해 발생되는 신호이다. 메모리 제어기는 먼저 RAS를 1(SET)로 만들어 행 주소부터 행주소버퍼에 래치시키고 그 다음 마찬가지로 CAS를 SET시켜 열주소를 열주소 버퍼에 래치시킨다. 이처한 동작으로 행주소와 열주소가 순차적으로 DRAM으로 보내지며 각각의 해독기에 의해 해독된다. 위 타이밍도에서 RD신호를 보면 행 주소가 래치되기 시작하는 순간부터 들어온다. 그러나 실제 데이터가 읽히는 시간은 열 주소가 래치되기 시작하는 순간부터 액세스 시간을 지난 이후부터이다. 그 결과가 유효 데이터가 되어 데이터 버스에 실리게 된다. 또한 위 기억장치는 DRAM을 나타내기 때문에 재충전 장치가 존재한다. 메모리 액세스가 없는 사이클 동안 재충전 계수기는 0부터 4095까지의 주소를 순서대로 발생시키며 해당 행에있는 모든 기억소자를 재충전시킨다. 아래 그림은 위에서 설명한 16M×4 DRAM의 실제 칩 패키징 구조를 보여준다. 2) ROM ROM(Read Only Memory)는 이름이 말해주듯이 읽기만 가능한 메모리이다. 대부분의 컴퓨터에서 메모리의 RAM 이외 일부는 ROM으로 구성된다. 또한 ROM은 비휘발성이다. 이러한 특성에 의해 ROM에는 아래와 같은 데이터가 주로 저장된다. a) 시스템 초기화 및 진단 프로그램 b) 자주 사용되는 서브루틴 c) 제어 유닛의 마이크로 프로그램 ROM에 저장될 데이터는 메모리 제조과정에서 미리 쓰여진다. ROM은 한 번 쓰게되면 이후 수정이 불가능하다는 제한을 완화하기 위하여 이후 아래와 같은 ROM들이 추가적으로 개발되었다. a)PROM(Programmable ROM) 제조 과정에서는 내용을 비워두며 사용자가 구입후에 필요한 데이터를 쓴다. ROM에 비해서는 융통성이 높지만 결국 한 번만 쓰기 가능하다는 점은 ROM과 같다. b) EPROM(Erasable Programmable ROM) 내용 삭제가 가능하다. 하지만 삭제를 위해서는 자외선이 필요하다. 따라서 내용 삭제를 위해서는 메모리를 컴퓨터에서 분리해야한다. 또한 일부 삭제는 불가능하고 ROM의 전체 내용 삭제만 가능하다. 삭제하는데 수십분의 오랜 시간이 소요된다. 여러 번 삭제가 가능하다는 장점이 있다. c) EEPROM(Electrically Erasable PROM) EPROM과 다르게 전기적인 신호를 통해 내용을 삭제할 수 있으므로 메모리를 분리할 필요가 없다. 한 번에 바이트 단위의 수정이 가능하며 일반적으로 쓰기 횟수는 수만번 정도 가능하다. d) 플래시 메모리(Flash Memory) EEPROM과 마찬가지로 전기적인 신호를 통해 내용 수정이 가능하다. 그러나 내용 삭제 속도가 EEPROM에 비해 현저히 빠르다는 장점이 있다. 그러나 바이트 단위의 쓰기가 가능한 EEPROM과 달리 쓰기 동작이 페이지 단위(보통 4K 바이트)로만 가능하다. 4. 기억장치 모듈의 설계 기억장치 칩 하나는 제한된 주소 갯수와 용량을 가지고 있다. 일반적인 메모리들은 이러한 칩 여러개를 물리적으로 접속시켜 사용한다. 물론 사용자가 보기에는 논리적으로 하나의 메모리처럼 보인다. 1) 병렬 접속 주소비트가 4개(0000~1111번지로 15개의 주소 지정)이고 주소 하나당 4bit를 저장하는 간단한 칩이 있다고 해보자. 그런데 CPU의 워드(word)가 8bit이다. 이런 경우 아래 그림과 같이 칩을 병렬로 접속해서 논리적으로 8bit인 메모리를 만들 수 있다. 4bit의 주소버스를 두 칩 주소버스에 공통적으로 연결한다. 그리고 8bit의 데이터를 4bit 나누어 칩의 데이터 버스와 연결했다. 이렇게 하면 두 메모리의 같은 위치에는 같은 번지가 배정되고 8bit의 데이터가 두개의 4bit로 쪼개져 각 칩의 기억장소에 저장된다. 이렇게 하면 16×4bit칩 2개로 16×8bit의 메모리를 구성할 수 있다. 좀 더 현실적인 예로 워드가 32bit(4byte)인 CPU를 사용하기 위해서 1K×8bit 칩으로 메모리를 구성한다면 아래 그림과 같이 4개를 병렬연결하면 된다. 이렇게 하면 1024개의 주소를 가지며 각 주소마다 32bit 크기의 기억장소를 가지는 메모리가 된다. 2) 직렬 접속 직렬접속을 사용하면 병렬접속과 달리 기억장소의 수를 확장시킬 수 있다. 아래 그림은 16×4bit 칩 2개를 직렬 연결하여 32×4bit의 메모리를 구성한 것이다. 32개(2^5)의 주소를 위해서는 5bit의 주소버스가 필요하다. 이 중 최상위 1bit는 각 칩의 선택 신호(CS-bar)에 인가되었다. CS-bar신호의 bar(CS신호 기호 위에있는 직선)는 active-low를 나타낸다. 즉, 이 신호는 0이 들어올 때 활성화가 된다는 뜻이다. 다시말해 0이 들어오면 칩이 선택되었단 것이다. 또한 데이터버스는 각각의 칩에 공통적으로 인가되었다. 이 때 주소의 최상위비트(A4)가 0이면 RAM1이 선택되고, 1이면 RAM2가 선택된다. 따라서 총 32개의 주소를 사용할 수 있는 것이다. RAM1 : 00000~01111번지 RAM2 : 10000~11111번지 아래 그림은 1K×8bit chip 4개를 직렬 연결하여 4K×8bit의 메모리를 구성한 것이다. 1K(2^10)이 4K(2^12)이 되기 위해서는 2개의 주소bit가 추가적으로 필요하다. 상위 2비트는 칩 선택 신호로 사용하고 나머지 10비트는 각 칩에 공통적으로 인가한다. 2개의 추가 주소비트를 2×4 해독기의 입력으로 넣어주면 4개의 신호로 구분될 수 있다. 그리고 각 신호가 4개 칩의 CS비트로 인가된다. 두 비트가 00, 01, 10, 11일 경우 각각 RAM1, RAM2, RAM3, RAM4가 선택된다. 예를들어 RAM3에는 1000 0000 0000 번지부터 1011 1111 1111번지까지 주소가 할당된다. 직렬접속과 병렬접속을 조합하면 우리가 원하는 주소폭과 데이터폭을 가지는 메모리를 설계할 수 있다. 5. 캐시 메모리 앞에서 언급했지만 캐시(cache) 메모리는 CPU와 메모리 사이의 속도차이로인한 성능 저하를 방지하기 위해 사용하는 반도체 메모리이다. 캐시는 메모리보다 CPU에 인접하거나 CPU 내부에 포함시키기도 한다. 프로그램 실행동안 메모리에서 자주 인출되는 명령어나 데이터가 캐시에 올라가게 된다. 캐시는 메모리보다 비싼 고속 기억장치이기도 하며 물리적으로 CPU와 더 가깝기 때문에 메모리보다 액세스 시간이 짧다. 비싸면서 설치 공간의 제한때문에 주기억장치의 용량에 비해 매우 작다. 일단 CPU가 메모리로부터 인출한 명령어나 데이터는 캐시에 적재(load)된다. 따라서 일정시간 경과 후에는 CPU가 한 번 이상 액세스한 내용은 캐시에 복사되어있는 상태가 된다. 그러나 캐시는 용량이 작기 때문에 계속 캐시에 남아있지는 못한다. 일단 캐시에 데이터가 적재되면 메모리에 비해 액세스 시간이 매우 짧아진다. CPU가 데이터에 엑세스 할 때는 캐시부터 검사 후 없으면 메모리로 이동한다. CPU가 데이터를 캐시에서 찾는것을 성공했을 경우를 캐시 적중(cache hit)라고 한다.(보통 캐시 히트라고 한다.) 반대로 캐시에서 찾지 못한 경우를 캐시 미스(cache miss)라고 한다. 캐시 적중률(cache hit ratio)는 CPU가 캐시히트를 할 확률이다. 풀어말하면 CPU가 데이터에 액세스 했을 때 그 데이터를 캐시로부터 찾았을 확률이며 아래와 같은 수식으로 나타낸다. 이를 응용하면 CPU의 기억장치 평균 액세스 시간()도 계산할 수 있다. 사실은 캐시미스의 경우 메모리에서 데이터를 인출하여 캐시에 올린 후 다시 빼내어 쓰기때문에 추가적인 시간이 소모되며 캐시히트를 검사하는 시간도 고려해야하나 이들은 상대적으로 매우 작기 때문에 수식을 간략히 적은 것이다. 캐시 히트가 높다는 것은 그만큼 캐시 사용 효과가 커진다는 것이다. 앞에서도 말했지만 캐시히트는 데이터 지역성에 크게 의존한다. 다시 말해 프로그램의 특정 부분에 위치한 코드나 데이터를 집중적으로 액세스하는 현상이다. 데이터 지역성은 특성에 따라 아래와 같이 분류될 수 있다. a) 시간적 지역성 최근 액세스된 코드나 데이터가 가까운 시간안에 다시 엑세스 될 가능성이 높아지는 특성이다. 반복문이나 서브루틴(함수), 공통 변수들은 반복적으로 빈번히 액세스된다. b) 공간적 지역성 메모리 내에서 인접하여 저장된 데이터들은 연속적으로 액세스 될 가능성이 높아지는 특성이다. 배열이나 리스트같은 자료구조가 대표적이다. c) 순차적 지역성 분기(branch)가 일어나지 않는 한 명령어는 순차적으로 인출되어 실행된다. 일반적인 프로그램은 순차적 실행과 비순차적 실행 비율이 대략 5:1정도인 것으로 알려져있다. 본질적으로 캐시사용 목적은 데이터 액세스 시간의 단축이다. 방금 말한 캐시 히트율은 프로그램 특성에 따라 다르기때문에 이것만으로 캐시 사용 효율을 높이는데는 한계가 있다. 따라서 캐시 설계 과정에서는 여러가지를 고려해야하며 아래는 그 목표들의 나열이다. (a) 캐시 히트 극대화 (b) 캐시 액세스시간 최소화 (c) 캐시미스 시의 지연시간 최소화 (d) 메모리와 캐시사이 동기화에 따른 오버헤드 최소화(CPU가 데이터를 변경했을 때 메모리에서도 그 내용을 갱신시키는 일에 소요되는 지연시간) 지금부터는 본격적으로 이와같은 목표달성을 위한 설계상의 이슈사항들에 대해 살펴본다. (1) 캐시 용량 캐시 용량이 크면 올릴 수 있는 데이터가 많아지기 때문에 캐시 적중률이 높아진다. 그러나 비용이나 부피문제가 존재하기 때문에 적정한 크기의 용량을 결정해야한다. (2) 인출 방식 메모리에서 캐시로 데이터를 올리는 방식은 캐시 적중률에 큰 영향을 미친다. 요구 인출(demand fetch)는 CPU가 현재 필요한 데이터만 캐싱하는 방식이고, 선인출(prefetch)는 지역성을 고려하여 앞으로 필요할 것이라 예상되는 데이터도 미리 캐싱해두는 방식이다. 메모리에서 캐시로 캐싱되는 데이터들의 그룹을 블록(block)이라 부른다. 블록이 커질수록 인출 시간이 그만큼 길어지기에 선인출 방식은 지역성이 큰 경우에는 큰 효과를 보지만 아니라면 인출 시간만 길어지는 부작용이 나올 수 있다. 아래 그림은 메모리와 캐시 조직을 보여준다. 메모리의 주소버스 폭은 n비트로 총 2^n개(0~2^n-1)의 주소를 지정할 수 있다. 다시말해 2^n개의 단어(word)를 저장할 수 있다. 선인출을 위해 메모리를 K개의 단어로 이루어진 블록들로 나눌 경우 전체 블록의 수는 2^n/K개가 된다. 캐시는 m개의 라인(line, 혹은 슬롯(slot))을 가지고 있다. 각 라인에는 하나의 블록, 즉 K개의 단어를 저장할 수 있다. 다시말해 캐시의 라인 하나의 용량은 메모리의 블록크기와 같아야한다. 선인출 방식을 다시 설명하자면 CPU가 실행에 필요한 명령어나 데이터에 액세스했을 때, 그 데이터가 포함된 전체 블록을 미리 캐싱해두는 것이다. 캐싱이 된 블록은 캐시의 한 라인에 적재된다. 캐시의 용량은 작기 때문에 캐시 라인 수는 메모리 전체 블록 수보다 훨씬 작으며 따라서 메모리의 일부 블록만 캐시에 적재될 수 있다. 메모리의 블록이 캐싱되면 매핑되어있는 캐시 라인에 적재된다. 그러나 앞에서 말했듯이 캐시 라인수는 전체 블록수보다 작기 때문에 캐시 라인은 여러 블록에 의해 공유된다. 그리고 캐시의 각 라인에는 현재 어느 블록이 저장되어있는지를 구분해주는 태그(tag)가 함께 저장된다. 이와 같이 블록이 어떤 캐시 라인을 사용할 것인지를 결정하는 것을 사상이라고 하는데 여기에는 여러 방법이 존재한다. (3) 사상 방식 사상 방식(mapping scheme)은 메모리의 어떤 블록들이 캐시의 어떤 라인을 공유하며 사용할 것인지를 결정해주는 방식이다. 사상방식에는 대표적으로 직접 사상, 완전연관사상, 세트연관사상이 있다. 이제부터 각 방식에 대해 설명한다. (a) 직접 사상(direct mapping) 각 블록은 미리 정해진 캐시 라인에만 적재될 수 있다. 이 방식을 위해 메모리의 주소는 아래와 같이 3개의 필드로 나누어서 해석한다. a) 태그필드 : 라인을 공유하는 2^t개의 블록들을 서로 구분 b) 라인필드 : 캐시의 m=2^l개의 라인들 중 블록이 저장될 라인을 지정 c) 단어필드 : 각 블록내의 단어들을 서로 구분 라인당 2^t개의 블록이 공유되니 전체 블록의 수는 2^(t+l)개로 볼 수 있다. 따라서 태그필드와 라인필드의 (t+l)비트를 블록 번호로 간주한다. 사상방식에서 블록j가 적재될 캐시 라인번호 i는 아래의 식과 같이 모듈로(modulo) 함수에 의해 결정된다. i = j mod m 즉 블록 번호를 캐시의 전체 라인수로 나눈 나머지를 계산하여 블록이 저장될 라인 번호를 결정한다. 결과적으로 캐시의 한 라인에는 태그(저장된 블록 번호)와 단어(데이터)가 함께 저장된다. 이제 CPU의 읽기 동작에서 캐시 적중 여부를 검사하는 원리를 이해할 수 있다. 아래 그림을 보자. CPU가 보낸 메모리 주소를 캐시에서 먼저 검사한다. 여기서 라인필드를 보고 캐시의 해당 라인으로 찾아간다. 이 때 주소의 태그필드와 캐시에 저장된 태그번호가 같으면 해당 내용은 캐시에 있는 것이므로 캐시 적중이다. 캐시 적중이면 주소 단어필드의 값을 통해 해당 단어(데이터)가 캐시에서 인출되어 CPU로 보내진다. 만약 두 태그가 일치하지 않거나 캐시의 해당 라인이 비어있으면 캐시미스이므로 주소가 메모리로 보내져 한 블록이 메모리에서 인출되고 이것이 캐시에 적재된다. 그런데 이미 해당 라인에 다른 블록이 저장되어있으면 그 내용은 지워지고 새로 꺼내온 데이터로 교체된다. 아래 그림은 사상 방식이 적용된 메모리와 캐시의 예를 나타낸다. 메모리의 각각 한 줄은 하나의 블록을 나타낸다. 단어비트가 모두 00인 이유는 각 블록의 4개의 워드 중 가장 첫 번째 워드의 주소만 나타냈기 때문이다. 캐시가 8개의 라인을 가지고 있고, 이는 주소의 라인필드 3비트로 구분한다. 그리고 최상위 2비트는 태그로 사용된다. 태그와 라인을 합친 총 5비트가 블록번호이며 이를 캐시 전체 라인수 8로 나눈 나머지가 계산되어 캐시의 해당 라인에 저장된다. 그런데 태그비트 부분은 이미 8의 배수이므로 실질적으로 3비트만 따져주면 되며 이것이 곧 라인 필드 값이다. 위 그림의 예로 CPU가 주소 0101000를 보낸 경우를 생각해보자. 먼저 라인 번호는010으로 라인 2이다. 라인 2의 태그는 현재 11이다. CPU가 보낸 주소의 태그는 01이므로 서로 불일치하고 캐시미스가 된다. 따라서 메모리의 0101000번지로 찾아가 해당 블록을 모두 꺼내어 캐시의 라인2번 내용을 교체한다. 즉, 태그는 01로 교체되고 단어는 “info”로 대체된다. 지금까지 설명한 직접매핑의 단점은 하나의 블록이 저장될 수 있는 캐시 라인이 한 개 뿐이라는 것이다. 만약 라인을 공유하는 두 블록이 번갈아가며 필요한 경우에는 캐시가 반복적으로 교체될 것이고 이로인해 캐시 적중률이 낮아지며 오버헤드가 증가할 것이다. (b) 완전 연관사상(fully-associative mapping) 블록이 캐시의 어떤 라인으로든 적재될 수 있도록 허용함으로써 직접사상의 단점을 보완한다. 따라서 완전연관사상 방식에서는 주소에 적재될 캐시 라인이 지정되는 라인 필드가 없다. 직접사상에서 태그 필드와 라인 필드로 사용하던 비트를 모두 태그 필드로 사용한다. 결과적으로 태그값이 메모리의 블록 번호와 같아진다. 이 방식에서는 라인필드가 없으므로 캐시 적중 여부를 검사할 때 주소의 태그 필드와 캐시의 모든 라인의 태그값들을 비교해야한다. 이를 순차적으로 하나씩 하면 시간이 오래 걸리므로 병렬적으로 처리하기 위한 하드웨어를 구성해야한다. 아래 그림은 완전연관사상이 적용된 캐시 조직이다. 특징은 비교기로 모든 캐시 라인의 태그가 입력된다는 점이다. 캐시히트가 일어난 경우에는 캐시에 저장된 블록에서 CPU가 필요한 워드를 인출한다. 캐시미스가 발생했을 경우에는 메모리로부터 데이터 블록을 인출한다. 이후에 캐시에 빈 라인들 중 한곳에 태그와 블록내용을 같이 저장한다. 그런데 문제는 빈 라인이 없을 경우이다. 이 경우에는 정해진 교체 알고리즘에 따라 라인들 중 하나를 선택하여 새로 인출된 블록으로 교체한다. 이 알고리즘을 교체알고리즘이라고 하는데 오래된 라인 혹은 최근 액세스 횟수가 가장 적은 라인이 선택될 수 있다. 완전연관사상은 라인 선택이 자유롭기 때문에 배열 전체가 캐시에 적재되어 데이터 지역성을 최대한 활용하는등의 이점이 있다. 다만 모든 태그를 병렬로 검사하기 위한 병렬처리 하드웨어를 포함해야하므로 매우 높은 비용이 든다. 따라서 실제로는 거의 사용되지 않는다. (c) 세트 연관사상(set-associative mapping) 세트연관사상은 직접연관사상과 완전연관사상 각각의 장점을 취한 절충안이다. 이 방식에서 주소는 태그필드, 세트필드, 단어필드로 나누어진다. 직접연관사상의 라인 필드가 세트필드로 대체된 형태이다. 캐시는 v개의 세트로 나누어지며, 각 세트마다 k개의 라인을 가진다. 따라서 캐시의 총 라인수 m = v × k 이다. 이때 j번 블록이 적재될 수 있는 캐시의 세트번호는 i = j mod v 이다. 즉, 블록 번호를 세트번호로 나눈 나머지를 계산결과를 블록이 저장될 세트 번호로 사용한다. 직접사상에서 라인 번호가 정확히 지정되는 것과 다르게 여기선 세트 번호까지만 지정되고 이후에 세트에 포함된 라인들 중의 하나에 저장된다. 아래 그림은 세트 연관사상 방식에서 데이터를 읽어오는 동작을 나타낸다. 위 그림은 세트당 라인이 2개인 2-way 세트 연관사상 방식을 나타낸다. 세트당 라인이 k개이면 k-way 세트 연관사상이라 부른다. 아무튼 위 그림에서는 CPU에서 발생된 주소의 세트 필드값을 확인 후 캐시의 해당 세트로 이동한다. 해당 세트의 태그들 중 주소의 태그와 일치하는 태그가 있다면 캐시 적중이고 없다면 캐시 미스이다. 이 방법은 직접 사상과 완전 연관사상의 절충적인 방법이라고 했었다. 만약 세트수와 라인수가 같다면 이는 직접 사상 방식과 같고 세트수가 1이라면 완전 연관 사상 방식과 같아진다. 일반적으로는 세트당 라인수가 2개인 2-way 세트 연관 사상이 가장 보편적으로 사용된다. 물론 2-way보다는 4-way 세트 사상 방식을 사용하면 캐시 적중률이 조금 더 올라가겠지만 드는 비용에 비해 2-way 연관사상과의 적중률 차이가 별로 크지 않다고 알려져 있다. (4) 교체 알고리즘 사상방식을 설명할 때 캐시미스의 경우 메모리에서 데이터 블록을 가져와서 캐시에 적재한다고 말했다. 직접사상의 경우는 적재될 수 있는 라인이 유일하므로 선택의 여지없이 교체가 되지만, 완전연관사상이나 세트연관사상에서는 어떤 블록을 지워야할지 선택하기 위한 교체 알고리즘이 필요하다. 여기서는 대표적인 4가지에 대해 간단히 설명한다. (a)LRU(Least Recently Used) 최근 액세스 사용되지않은채로 가장 오래 적재되어있던 블록을 교체한다. 가장 흔히 사용하는 2-way 세트 연관 사상 방식에서는 LRU 알고리즘을 구현하기 위해 USE비트를 사용한다. 세트 내 두개의 라인 중 최근 액세스 된 블록의 USE비트가 1로 세트되고, 다른 하나의 USE 비트는 0으로 리셋된다. 새로운 블록이 메모리에서 적재될 때 USE비트가 0인 블록을 대체한다. 실제로 더 최근에 사용된 데이터가 앞으로 사용될 가능성이 높다는 가정이 맞는 경우가 많기 때문에 LRU 알고리즘은 높은 캐시히트를 보여준다. (b)FIFO(First-In-First-Out) 가장 오래된 블록이 교체된다. (c)LFU(Least Frequency Used) 캐시에 적재된 이후 액세스 횟수가 가장 작은 블록을 교체한다. LRU랑 헷갈릴수도 있지만 LRU는 최근 참조횟수가 작은 블록의 교체이고 LFU는 적재이후로 액세스 횟수가 가장 작은 블록의 교체이다. 액세스 횟수를 카운트하기 위한 하드웨어의 추가가 필요하기때문에 LRU에 비해 잘 사용되지 않는 편이다. ** (d)Random** 랜덤으로 하나의 블록을 제거한다. (5) 쓰기 정책 쓰기정책은 캐시의 내용이 변경되었을 때 메모리에 그 내용을 갱신하는 시기와 방법을 결정하는 것이다. CPU가 명령어를 실행하는 중에 캐시에 있는 데이터를 수정하였을 경우 메모리에 있는 내용과 달라진다. 이 때 외부 장치에서 메모리의 데이터를 읽어간다면 잘못된 결과를 초래한다. 따라서 메모리의 데이터도 캐시의 내용과 똑같이 업데이트 해주어야한다. 그런데 메모리에 데이터를 쓰는 행위는 캐시에 데이터를 쓰는것에 비해 오랜 시간이 걸린다. 따라서 캐시 데이터가 수정될 때 마다 메모리의 내용을 업데이트 하지 않고 캐시 미스로 인해 캐시 라인의 데이터가 변경될 경우 혹은 외부에서 메모리의 데이터를 일겅가려하는 경우 업데이트 해주는 방식을 사용하기도 한다. 여기에서는 대표적인 두 가지 쓰기정책을 소개한다. (a) write-through 캐시의 내용이 수정될 때 동시에 메모리의 데이터를 업데이트 해주는 방식이다. 가장 간단한 방식이다. 단점은 메모리의 내용을 매번 갱신해주는데 시간이 소요된다는 것이다. b) write-back 캐시 라인이 M(modified)라는 비트를 포함한다. 이 비가 1로 세트 되어있으면 데이터 캐싱 이후 수정이 되었다는 것이다. 이후 캐시미스로 해당 라인이 교체될 때 캐시의 내용을 메모리로 업데이트 시켜준다. 다만 캐시 내용이 메모리로 업데이트 되기 전까지는 해당 메모리 블록이 무효상태에 있게 된다는 문제점이 존재한다. 또한 캐시의 수정상태를 기록하기 위해 모든 라인이 추가적인 비트를 포함해야 하고 여기에는 추가적인 하드웨어 회로가 필요하다. 아래 그림은 write-through 쓰기정책과 write-back 쓰기정책의 동작을 간단히 나타낸 그림이다. (6) 다중 캐시 요즘에는 일반적으로 캐시를 하나만 사용하지 않고 여러개를 사용하는 다중캐시를 사용하여 성능을 더욱 끌어올린다. 온 칩 캐시(On-Chip Cache)는 CPU 내부의 1레벨 캐시와 외부에 2레벨 캐시를 동시에 두는 방식이다. 1레벨 캐시는 CPU내부에 존재하므로 외부버스가 필요없이 내부버스만으로 데이터가 이동할 수 있어 더욱 빠른 액세스를 보여준다. 분리 캐시는 용도에 따라 캐시를 분리하여 두는 방식이다. 명령어와 데이터 캐시를 따로 두어 명령어 파이프라인에서 명령어 인출단계와 오퍼랜드 인출단계 사이의 캐시 충돌을 방지할 수 있다. 아래는 인텔 i7-990X 쿼드코어 프로세서의 3레벨 캐시 구조를 나타낸 그림이다. 6. DDR SDRAM 메모리의 속도 향상은 반도체 기술 발달에 따른 CPU의 속도 향상을 따라잡지 못하고 있다. DRAM의 직접도가 높아져 면적당 용량은 향상됐지만 속도는 아직 CPU에 비하면 현저히 떨어진다. 둘의 속도차에서 오는 병목현상 해결을 위해 여러가지 기술이 개발되었다. 여기서는 전통적인 DRAM의 데이터 전송방식을 변경하여 속도를 개선시킨 SDRAM과 이를 더욱 보강시킨 DDR SDRAM에 대해 알아본다. (1) SDRAM SDRAM은 동기식 DRAM(Synchronous Dynamic Random Access Memory)으로 DRAM의 액세스 속도 한계 극복을 위해 개발된 반도체 기억장치이다. 동기식이라 함은 CPU 클럭 주기에 맞추어 데이터를 전송한다는 의미를 가진다. 먼저 전통적인 DRAM의 원리를 보자. DRAM에서는 읽기/쓰기 신호가 들어오는 즉시 해당 주소의 데이터에 액세스하여 동작을 수행한다. 그런데 연속적인 신호가 들어오면 해당 동작들이 종료될 때 까지 CPU는 다른일을 하지 못한다. 또한 시스템 버스 권한도 메모리에 붙잡혀있게된다. 이 때문에 전체적인 지연시간이 생긴다. 반면 SDRAM은 클록 신호 주기에 맞추어 모든 동작들이 수행된다. 아래는 SDRAM의 읽기동작 과정에 대한 설명이다. (a) CPU는 한 클럭 주기동안 시스템 버스를 통해 주소와 읽기 신호를 메모리로 내보낸다. 이후에는 결과를 기다리지 않고 다른 연산을 수행한다. (b) SDRAM은 신호를 받는 즉시 동작을 수행한다. 동작이 완료되면 시스템버스 권한을 얻은다음 다음 클록 주기에서 데이터를 CPU로 보낸다. (c) CPU가 데이터를 받는다. SDRAM은 여러개의 뱅크(bank)들로 이루어져있다. 여러개의 뱅크에 동시 액세스가 가능하여 뱅크별로 서로 다른 동작 수행이 가능하다. 512Mbit SDRAM이 있다고해보자. 이 칩은 16M×8bit 뱅크 4개로 이루어져있다. 16M×8bit 뱅크가 8K개의 행을 가지고 있다면 각 행에는 2K개의 8bit 메모리 셀이 있는 것이다. 따라서 행주소에는 13비트가 필요하고 열 주소에는 11비트의 주소가 필요하다. 뱅크에서 행 주소에 의해 행이 선택되면 해당 행의 모든 데이터가 감지 증폭기(sense amplifier)로 이동한다. 이 동작을 ‘행을 연다(opening the row)’라고 한다. 열린 행의 데이터들은 워드(여기서는 1byte)단위로 선택되어 데이터 버스에 실린다. 데이터 액세스에서는 행을 여는데 시간이 오래 걸리지만 이미 증폭기에 실린 데이터를 전송하는것은 한 클록 주기만에 가능하다. 따라서 이후부터는 여러개의 데이터를 매 클록 주기마다 연속으로 전송할 수 있다. 위와 같은 연속 동작을 버스트 모드(burst mode)라고 한다. 한 번의 버스트 모드 동안 전송되는 데이터 수를 버스트 길이(burst length)라고 하며 이 값은 보통 2,4, 혹은 8이다. 아래 그림은 버스트 읽기 동작을 나타낸 흐름도이다. 열 주소가 래치되기 시작한 순간부터 데이터가 인출되어 버스에 실릴 때까지의 시간을 CAS 지연이라하며 일반적으로 두 클록 주기 정도이다. 위 그림의 버스트 읽기 모드에서 4개의 바이트 데이터가 연속적으로 전송되는것을 볼 수 있다. 그러나 버스트 쓰기 모드에서는 열 주소가 인가되는 순간부터 데이터도 같이 쓸 수 있기때문에 CAS 지연이 발생되지 않는다. 결과적으로 여러개의 뱅크가 있고 각 뱅크마다 행 열기를 통해 한 행의 모든 데이터를 감지증폭기에 올려둠으로써 주소 해독, 액세스에 의한 지연 없이 매 CPU 클록 주기마다 한 바이트씩의 데이터가 연속적으로 보내지는 효과를 얻을 수 있는 것이다.(물론 CAS 지연은 존재하지만) 만약 위의 SDRAM 칩을 사용해 한 번에 64비트씩의 데이터 전송이 가능한 모듈을 구성하려면 8개를 병렬로 연결하면 된다. (2) DDR SDRAM SDRAM에서는 이미 뱅크 행의 전체 데이터가 감지증폭기에 들어가 있는 상황에서 버스트모드를 통해 매 클럭주기마다 연속적으로 데이터를 전송하는 것에 대해 알았다. 이제 여기서 버스 클록 주파수(진동수)만 더 높일수있다면 데이터 전송 대역폭(bandwidth)을 더욱 높일 수 있다. DDR이란 Double Data Rate의 약자로 SDRAM이 한 클록주기당 두 번 데이터를 전송할 수 있게 해주는 기술이다. 우리가 알다시피 SDRAM에서는 매 클럭 주기마다 한 번씩 데이터를 보낸다. 한 클럭 주기 신호에는 상승엣지(rising edge) 1번, 하강엣지(falling edge) 1번이 있다. SDRAM에서는 상승엣지에서만 데이터를 전송하는것과 달리 DDR SDRAM에서는 데이터전송을 위해 두 엣지를 모두 사용한다. 이후 클록의 주파수를 2배 더 높인 기술을 사용하는 DDR2 SDRAM도 개발되었다. DDR(Double Data Rate) 기술의 핵심은 아래와 같다. (a) 데이터전송에 클록의 상승엣지와 하강엣지를 모두 사용한다. (b) 하드웨어 회로를 개선함으로써 클록 주파수를 높인다. 현재 개발된 DDR3, DDR4 기술 역시 위의 원리에 바탕을 두고있다. (3) 메모리 랭크 메모리 랭크(memory rank)란 데이터 전송폭이 64bit가 되도록 구성한 SDRAM의 집합, 즉 모듈이다. 메모리 산업표준그룹에서 제정된 표준 기억장치 랭크가 64bit이기 때문에 일반적으로 메모리 칩들을 병렬로 연결하여 64bit 폭의 모듈을 구성하여 사용한다. 만약 x4 칩을 사용한다면 16개의 SDRAM칩이 필요하고, x8 칩을 사용하면 8개로 하나의 메모리 랭크를 구성할 수 있다. 메모리 칩을 병렬로 연결시킨 기억장치 모듈은 메인보드의 메모리 슬롯에 장착된다. 여기에서 한 면에만 칩들을 장착시킨 단면 모듈을 SIMM(single in-line memory module), 양면에 칩들을 장착시킨 양면 모듈을 DIMM(dual in-line memory module)이라고 부른다. 예를들어 x8칩을 사용해 각각의 면에 8개씩 붙이면 각 면은 64bit의 데이터 폭을 가지는 랭크가 된다. 이를 양면 2중랭크 모듈이라 부른다. 이를 한 면에만 붙이면 단면 단일랭크 모듈이라 부른다. 만약 모듈이 x4칩들로 만들어졌다면 양면이 합쳐서 64bit의 데이터폭을 가지게되므로 양면 단일랭크 모듈이 된다.</summary></entry><entry><title type="html">(컴퓨터구조) 4. 제어유닛</title><link href="http://localhost:4000/2020/02/23/%EC%A0%9C%EC%96%B4%EC%9C%A0%EB%8B%9B/" rel="alternate" type="text/html" title="(컴퓨터구조) 4. 제어유닛" /><published>2020-02-23T13:37:19+09:00</published><updated>2020-02-23T13:37:19+09:00</updated><id>http://localhost:4000/2020/02/23/%EC%A0%9C%EC%96%B4%EC%9C%A0%EB%8B%9B</id><content type="html" xml:base="http://localhost:4000/2020/02/23/%EC%A0%9C%EC%96%B4%EC%9C%A0%EB%8B%9B/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;제어 유닛의 기능&lt;/li&gt;
  &lt;li&gt;제어 유닛의 구조&lt;/li&gt;
  &lt;li&gt;마이크로명령어 형식&lt;/li&gt;
  &lt;li&gt;마이크로프로그래밍&lt;/li&gt;
  &lt;li&gt;마이크로프로그램의 순서 제어&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-intro&quot;&gt;0. Intro&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;앞서 배운 ALU 및 레지스터들의 동작은 명령어를 인출하고 실행하는 과정 자체이었다. 그런데 이러한 일들의 순서 및 동작이 일어나게 하기 위한 제어 신호를 발생시키는것은 제어유닛이다. 제어유닛이 발생시키는 제어신호들로 하여금 각각의 모듈들이 어떠한 일을 실행할지 결정된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-제어-유닛의-기능&quot;&gt;1. 제어 유닛의 기능&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;제어유닛이 담당하는 중요한 기능 두 가지는 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;명령어 해독&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명령어 실행을 위한 제어신호 발생&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인출된 명령어를 해독하고 실행에 필요한 동작을 수행시키기 위한 제어신호를 발생하는 것이다. 즉, 명령어 사이클이 수행될 수 있도록 모든 동작을 제어하는 컨트롤타워 역할을 한다.&lt;/p&gt;

&lt;p&gt;하나의 명령어 사이클은 여러개의 마이크로 연산으로 구성되는것을 상기해보자. 아래는 인출 사이클을 위한 마이크로 연산 과정이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;t0 : MAR ← PC

t1 : M\[MAR\] ← MBR, PC ← PC + 1

t2 : IR ← MBR
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나의 마이크로 연산은 한 번의 CPU 클럭 주기동안 수행된다. 즉, 인출 사이클에는 3 CPU 클럭 주기가 소요된다.&lt;/p&gt;

&lt;p&gt;위와에서 단 하나의 마이크로 연산 역시 수행되어야 할 하나의 명령어이므로 2진 비트로 구성된다. 이처럼 하나의 마이크로연산을 위한 명령어를 &lt;strong&gt;마이크로 명령어(micro-instruction)&lt;/strong&gt;라고 부른다. 한 주기에 실행되는 명령어라는 의미에서 &lt;strong&gt;제어 단어(control word)&lt;/strong&gt;라고도 부른다. 마이크로 명령어들의 집합을 &lt;strong&gt;마이크로 프로그램(microprogram)&lt;/strong&gt;이라고 부른다.&lt;/p&gt;

&lt;p&gt;명령어 사이클을 하나의 마이크로 프로그램으로 본다면 이는 3개의 &lt;strong&gt;루틴(routine)&lt;/strong&gt;으로 구성되어있다고 할 수 있다.(인출 사이클 루틴, 간접 사이클 루틴, 실행 사이클 루틴) 루틴은 CPU의 특정 기능 수행을 위한 마이크로 명령어들을 논리적으로 묶은 마이크로명령어 그룹이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-제어-유닛의-구조&quot;&gt;2. 제어 유닛의 구조&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;아래 그림은 제어유닛의 구조를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/control_unit_structure.png&quot; alt=&quot;control_unit_structure&quot; width=&quot;70%&quot; height=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) 명령어 해독기(instruction decoder)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어의 연산코드를 해독하여 해당 연산의 수행을 위한 루틴의 시작 주소를 결정한다. 즉, 모든 마이크로 명령어를 위한 루틴들이 저장되어있는 제어 기억장치에서 해당 연산의 루틴이 저장된 곳의 주소를 알려주는 역할이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) 제어 주소 레지스터(control address register : CAR)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어 해독기가 알려준 마이크로 명령어의 주소가 임시로 저장되는 레지스터이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3) 제어 기억장치(control memory)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마이크로 명령어들로 이루어진 루틴들이 저장된 곳이다. 마이크로 명령어들은 CPU 설계 단계에서 확정되기때문에 제어 기억장치는 ROM(Read-Only Memory)로 만들어진 후 CPU칩 안에 포함된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4) 제어 버퍼 레지스터(control buffer register : CBR)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;제어 기억장치에서 빼낸 마이크로 명령어가 일시적으로 저장되는 레지스터&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5) 서브루틴 레지스터(subroutine register : SBR)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CBR에 임시로 저장된 마이크로명령어의 실행에서 서브루틴이 호출되는 경우에 현재의 CAR 내용을 임시적으로 저장하기 위한 레지스터&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6) 순서제어 모듈(sequencing module)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마이크로명령어들의 실행 순서를 결정한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;제어 기억장치에는 루틴들이 저장되어 있다고 했는데, 내부 구성은 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/control_memory_structure.png&quot; alt=&quot;control_memory_structure&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에 나타난 제어 기억장치에는 0~63번지 까지는 공통 루틴들이, 64~127번지 까지는 실행 사이클 루틴들이 저장되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
명령어 해독기는 연산코드(op-code)를 해독하여 해당 실행 루틴이 저장된 제어 기억장치의 주소를 찾아야한다. 이를 위한 여러 방법들 중 매핑(mapping)에 대해 알아본다.&lt;/p&gt;

&lt;p&gt;매핑에서는 연산 코드를 특정 비트 패턴과 혼합시켜 실행 사이클 루틴이 저장된 제어 기억장치의 주소를 찾아낸다. 아래 그림을 보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/routine_mapping.png&quot; alt=&quot;routine_mapping&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;먼저 명령어 형식이 16비트이고 이는 4비트의 연산코드와 1비트의 간접비트, 11비트의 오퍼랜드로 구성되어있다고 가정해보자.&lt;/p&gt;

&lt;p&gt;위 그림에서는 1XXXX00이라는 사상함수에 연산코드 4비트를 매핑시킨다.&lt;/p&gt;

&lt;p&gt;만약 연산코드가 0001이라면 사상결과는 1000100이 되고 이는 10진수로 68번지가 된다. 즉, 제어 주소 레지스터(CAR)에는 제어 기억장치의 68번지가 저장된다. 이후로 실행 사이클이 시작되면 68번지에서 시작되는 루틴의 마이크로 명령어들을 순차적으로 꺼내어 수행하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-마이크로명령어-형식&quot;&gt;3. 마이크로명령어 형식&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;제어 기억장치에 저장된 루틴들은 각각이 여러개의 마이크로 명령어들로 이루어져있다. 아래 그림은 하나의 마이크로 명령어 형식의 예시이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/micro_instruction_format.png&quot; alt=&quot;micro_instruction_format&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 연산 필드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마이크로 연산의 종류를 지정한다. 종류들의 예시는 아래 표와 같이 정리될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/operation_field_table.png&quot; alt=&quot;operation_field_table&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각각은 연산필드1과 연산필드2의 마이크로 연산들의 예시를 보여준다. 예를들어 명령어 인출의 두 번째 마이크로연산에서 MBR ← M[MAR]과 PC ← PC + 1은 동시에 일어나야하므로 다른 연산 필드에 위치해야 한다.&lt;/p&gt;

&lt;p&gt;위에서 제시한 마이크로 명령어 형식에서는 연산필드가 2개이므로 2개의 마이크로 명령어가 동시에 실행될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) 조건 필드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분기에 사용될 조건 플래그를 지정한다. 조건필드가 검사하는 조건이 1(SET)인지 0(CLEAR)인지에 따라 분기필드가 지정하는 분기가 일어날지 말지 결정된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/conditional_field_table.png&quot; alt=&quot;conditional_field_table&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조건 필드는 2개의 비트로 지정된다. 예를 들어 00이면 무조건 분기가 일어나고 11이면 AC에 저장된 데이터가 0인지 검사 후 true(1=SET)이면 분기가 일어나고 false(0=CLEAR)면 분기가 일어나지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c) 분기 필드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분기의 종류를 지정한다. 분기의 종류에따라 다음에 실행될 마이크로 명령어의 주소가 결정된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/branch_field_table.png&quot; alt=&quot;branch_field_table&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 분기 필드의 비트가 01이면 이는 서브루틴 호출을 나타낸다. 조건필드가 만족되어 1이면 주소필드(ADF) 값이 제어 주소 레지스터(CAR)로 적재된다. 이 때 서브루틴 호출이 끝난 후 복귀를 위해 다음에 실행되어야 할 CAR + 1 값은 서브루틴 레지스터(SBR)에 잠시 저장해둔다. 만약 조건필드가 만족되지 않는다면 CAR값이 1 증가하고 이에따라 다음 순서의 마이크로 명령어가 수행된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;d) 주소 필드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분기가 발생하는 경우 분기될 마이크로명령어가 있는 목적지 주소이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-마이크로프로그래밍&quot;&gt;4. 마이크로프로그래밍&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;제어 기억장치에 저장된 각각의 루틴들을 하나씩 마이크로프로그래밍 해보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1) 인출 사이클 루틴&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인출 사이클 루틴은 3개의 마이크로 명령어들로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/fetch_routine.png&quot; alt=&quot;fetch_routine&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인출 사이클 루틴은 제어 기억장치의 0번지부터 시작된다. 따라서 각각의 마이크로 명령어는 00000000, 00000001, 00000010 번지에 저장되어 있다.&lt;/p&gt;

&lt;p&gt;마지막 사이클에서는 조건필드가 U이고 분기필드가 MAP이므로 실행 사이클의 루틴 시작주소를 CAR로 매핑시킨다. 따라서 다음 사이클에서는 해당 실행 사이클 루틴으로 분기가 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 간접 사이클 루틴&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;간접 사이클 루틴은 명렁어의 I 비트가 SET 일때 호출된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/indirect_routine.png&quot; alt=&quot;indirect_routine&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;간접 사이클 루틴의 마지막 마이크로명령어의 분기 필드는 원래의 실행 사이클로 복귀하기위한 RET이다. 간접 사이클 루틴을 호출할 때 서브루틴 레지스터(SBR)에 저장해두었던 목적지 주소를 다시 CAR에 적재하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;3) 실행 사이클 루틴&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아래 테이블은 명령어의 대표적인 연산 코드들을 정리한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/operation_codes.png&quot; alt=&quot;operation_codes&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;각각의 연산코드별로 제어 기억장치에 저장된 루틴의 시작주소들의 매핑값이 표시되어 있다.&lt;/p&gt;

&lt;p&gt;아래는 각각의 실행 루틴의 마이크로 프로그래밍 순서들을 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/images/computer_architecture/4/execute_routine.png&quot; alt=&quot;execute_routine&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 중요한점은 모든 실행 루틴의 마지막 마이크로 명령어의 분기 목적지 주소인 주소필드의 내용이 FETCH인 것이다. 즉, 실행사이클 루틴이 끝나면 다음 명령어 인출을 위한 인출 사이클 루틴으로 분기하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-마이크로프로그램의-순서-제어&quot;&gt;5. 마이크로프로그램의 순서 제어&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;지금까지의 내용 중 핵심은 제어 기억장치에 저장된 마이크로 명령어 혹은 루틴을 적절히 인출하는 것이다. 이번 포스팅의 가장 처음에 보여준 그림의 순서제어 모듈을 좀더 세부적으로 뜯어보면 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/4/sequencing_module.png&quot; alt=&quot;sequencing_module&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;제어 주소 레지스터에 어떤 값이 들어가냐에 따라 다음에 인출할 마이크로 명령어가 달라진다. 현재 실행중인 마이크로 명령어의 조건 필드(CD)가 MUX2로 들어와 네 개의 조건 비트 중 하나의 값이 주소 선택회로의 입력으로 들어간다. 주소선택회로의 또다른 입력은 현재 실행중인 마이크로 명령어의 분기 필드(BR) 값이다. 즉, 조건필드와 분기필드에 따라 다음에 어떤 마이크로 명령어를 인출할지가 결정되는 것이다. MUX1에는 다음 순서의 마이크로 명령어 시작주소(0), 현재 실행중인 마이크로 명령어에 있는 목적지 주소(1), 서브루틴 호출이 끝난 후의 복귀 주소(SBR), 명령어 실행의 연산코드에 따른 매핑 주소(3) 4개가 입력으로 들어오며, 주소선택 회로의 결과에 따라 4개 중 어떤 주소가 선택될지 결정되는 것이다.&lt;/p&gt;

&lt;p&gt;최종적으로 선택된 주소가 제어 주소 레지스터(CAR)로 들어오게 되며 제어 기억장치의 해당 주소에서 마이크로 명령어가 인출된다.&lt;/p&gt;

&lt;p&gt;그리고 인출된 마이크로 명령어의 연산 코드는 제어 신호가 되어 외부로 전송된다. 연산 코드 이외의 조건필드, 분기필드, ADF는 다음 마이크로 명령어 인출을 위해 순서 제어 모듈로 들어가 CAR에 적절한 제어 기억장치의 루틴 시작 주소를 적재시킨다.&lt;/p&gt;</content><author><name>nobbaggu</name></author><category term="마이크로" /><category term="마이크로명령어" /><category term="마이크로프로그램" /><category term="제어유닛" /><category term="루틴" /><summary type="html">목차 제어 유닛의 기능 제어 유닛의 구조 마이크로명령어 형식 마이크로프로그래밍 마이크로프로그램의 순서 제어 0. Intro 앞서 배운 ALU 및 레지스터들의 동작은 명령어를 인출하고 실행하는 과정 자체이었다. 그런데 이러한 일들의 순서 및 동작이 일어나게 하기 위한 제어 신호를 발생시키는것은 제어유닛이다. 제어유닛이 발생시키는 제어신호들로 하여금 각각의 모듈들이 어떠한 일을 실행할지 결정된다. 1. 제어 유닛의 기능 제어유닛이 담당하는 중요한 기능 두 가지는 아래와 같다. 명령어 해독 명령어 실행을 위한 제어신호 발생 인출된 명령어를 해독하고 실행에 필요한 동작을 수행시키기 위한 제어신호를 발생하는 것이다. 즉, 명령어 사이클이 수행될 수 있도록 모든 동작을 제어하는 컨트롤타워 역할을 한다. 하나의 명령어 사이클은 여러개의 마이크로 연산으로 구성되는것을 상기해보자. 아래는 인출 사이클을 위한 마이크로 연산 과정이다. t0 : MAR ← PC t1 : M\[MAR\] ← MBR, PC ← PC + 1 t2 : IR ← MBR 하나의 마이크로 연산은 한 번의 CPU 클럭 주기동안 수행된다. 즉, 인출 사이클에는 3 CPU 클럭 주기가 소요된다. 위와에서 단 하나의 마이크로 연산 역시 수행되어야 할 하나의 명령어이므로 2진 비트로 구성된다. 이처럼 하나의 마이크로연산을 위한 명령어를 마이크로 명령어(micro-instruction)라고 부른다. 한 주기에 실행되는 명령어라는 의미에서 제어 단어(control word)라고도 부른다. 마이크로 명령어들의 집합을 마이크로 프로그램(microprogram)이라고 부른다. 명령어 사이클을 하나의 마이크로 프로그램으로 본다면 이는 3개의 루틴(routine)으로 구성되어있다고 할 수 있다.(인출 사이클 루틴, 간접 사이클 루틴, 실행 사이클 루틴) 루틴은 CPU의 특정 기능 수행을 위한 마이크로 명령어들을 논리적으로 묶은 마이크로명령어 그룹이다. 2. 제어 유닛의 구조 아래 그림은 제어유닛의 구조를 보여준다. 1) 명령어 해독기(instruction decoder) 명령어의 연산코드를 해독하여 해당 연산의 수행을 위한 루틴의 시작 주소를 결정한다. 즉, 모든 마이크로 명령어를 위한 루틴들이 저장되어있는 제어 기억장치에서 해당 연산의 루틴이 저장된 곳의 주소를 알려주는 역할이다. 2) 제어 주소 레지스터(control address register : CAR) 명령어 해독기가 알려준 마이크로 명령어의 주소가 임시로 저장되는 레지스터이다. 3) 제어 기억장치(control memory) 마이크로 명령어들로 이루어진 루틴들이 저장된 곳이다. 마이크로 명령어들은 CPU 설계 단계에서 확정되기때문에 제어 기억장치는 ROM(Read-Only Memory)로 만들어진 후 CPU칩 안에 포함된다. 4) 제어 버퍼 레지스터(control buffer register : CBR) 제어 기억장치에서 빼낸 마이크로 명령어가 일시적으로 저장되는 레지스터 5) 서브루틴 레지스터(subroutine register : SBR) CBR에 임시로 저장된 마이크로명령어의 실행에서 서브루틴이 호출되는 경우에 현재의 CAR 내용을 임시적으로 저장하기 위한 레지스터 6) 순서제어 모듈(sequencing module) 마이크로명령어들의 실행 순서를 결정한다. 제어 기억장치에는 루틴들이 저장되어 있다고 했는데, 내부 구성은 아래 그림과 같다. 위 그림에 나타난 제어 기억장치에는 0~63번지 까지는 공통 루틴들이, 64~127번지 까지는 실행 사이클 루틴들이 저장되어 있다. 명령어 해독기는 연산코드(op-code)를 해독하여 해당 실행 루틴이 저장된 제어 기억장치의 주소를 찾아야한다. 이를 위한 여러 방법들 중 매핑(mapping)에 대해 알아본다. 매핑에서는 연산 코드를 특정 비트 패턴과 혼합시켜 실행 사이클 루틴이 저장된 제어 기억장치의 주소를 찾아낸다. 아래 그림을 보자. 먼저 명령어 형식이 16비트이고 이는 4비트의 연산코드와 1비트의 간접비트, 11비트의 오퍼랜드로 구성되어있다고 가정해보자. 위 그림에서는 1XXXX00이라는 사상함수에 연산코드 4비트를 매핑시킨다. 만약 연산코드가 0001이라면 사상결과는 1000100이 되고 이는 10진수로 68번지가 된다. 즉, 제어 주소 레지스터(CAR)에는 제어 기억장치의 68번지가 저장된다. 이후로 실행 사이클이 시작되면 68번지에서 시작되는 루틴의 마이크로 명령어들을 순차적으로 꺼내어 수행하게 된다. 3. 마이크로명령어 형식 제어 기억장치에 저장된 루틴들은 각각이 여러개의 마이크로 명령어들로 이루어져있다. 아래 그림은 하나의 마이크로 명령어 형식의 예시이다. a) 연산 필드 마이크로 연산의 종류를 지정한다. 종류들의 예시는 아래 표와 같이 정리될 수 있다. 각각은 연산필드1과 연산필드2의 마이크로 연산들의 예시를 보여준다. 예를들어 명령어 인출의 두 번째 마이크로연산에서 MBR ← M[MAR]과 PC ← PC + 1은 동시에 일어나야하므로 다른 연산 필드에 위치해야 한다. 위에서 제시한 마이크로 명령어 형식에서는 연산필드가 2개이므로 2개의 마이크로 명령어가 동시에 실행될 수 있다. b) 조건 필드 분기에 사용될 조건 플래그를 지정한다. 조건필드가 검사하는 조건이 1(SET)인지 0(CLEAR)인지에 따라 분기필드가 지정하는 분기가 일어날지 말지 결정된다. 조건 필드는 2개의 비트로 지정된다. 예를 들어 00이면 무조건 분기가 일어나고 11이면 AC에 저장된 데이터가 0인지 검사 후 true(1=SET)이면 분기가 일어나고 false(0=CLEAR)면 분기가 일어나지 않는다. c) 분기 필드 분기의 종류를 지정한다. 분기의 종류에따라 다음에 실행될 마이크로 명령어의 주소가 결정된다. 만약 분기 필드의 비트가 01이면 이는 서브루틴 호출을 나타낸다. 조건필드가 만족되어 1이면 주소필드(ADF) 값이 제어 주소 레지스터(CAR)로 적재된다. 이 때 서브루틴 호출이 끝난 후 복귀를 위해 다음에 실행되어야 할 CAR + 1 값은 서브루틴 레지스터(SBR)에 잠시 저장해둔다. 만약 조건필드가 만족되지 않는다면 CAR값이 1 증가하고 이에따라 다음 순서의 마이크로 명령어가 수행된다. d) 주소 필드 분기가 발생하는 경우 분기될 마이크로명령어가 있는 목적지 주소이다. 4. 마이크로프로그래밍 제어 기억장치에 저장된 각각의 루틴들을 하나씩 마이크로프로그래밍 해보자. 1) 인출 사이클 루틴 인출 사이클 루틴은 3개의 마이크로 명령어들로 구성된다. 인출 사이클 루틴은 제어 기억장치의 0번지부터 시작된다. 따라서 각각의 마이크로 명령어는 00000000, 00000001, 00000010 번지에 저장되어 있다. 마지막 사이클에서는 조건필드가 U이고 분기필드가 MAP이므로 실행 사이클의 루틴 시작주소를 CAR로 매핑시킨다. 따라서 다음 사이클에서는 해당 실행 사이클 루틴으로 분기가 된다. 2) 간접 사이클 루틴 간접 사이클 루틴은 명렁어의 I 비트가 SET 일때 호출된다. 간접 사이클 루틴의 마지막 마이크로명령어의 분기 필드는 원래의 실행 사이클로 복귀하기위한 RET이다. 간접 사이클 루틴을 호출할 때 서브루틴 레지스터(SBR)에 저장해두었던 목적지 주소를 다시 CAR에 적재하게 된다. 3) 실행 사이클 루틴 아래 테이블은 명령어의 대표적인 연산 코드들을 정리한 것이다. 각각의 연산코드별로 제어 기억장치에 저장된 루틴의 시작주소들의 매핑값이 표시되어 있다. 아래는 각각의 실행 루틴의 마이크로 프로그래밍 순서들을 나타낸다. 여기서 중요한점은 모든 실행 루틴의 마지막 마이크로 명령어의 분기 목적지 주소인 주소필드의 내용이 FETCH인 것이다. 즉, 실행사이클 루틴이 끝나면 다음 명령어 인출을 위한 인출 사이클 루틴으로 분기하게 된다. 5. 마이크로프로그램의 순서 제어 지금까지의 내용 중 핵심은 제어 기억장치에 저장된 마이크로 명령어 혹은 루틴을 적절히 인출하는 것이다. 이번 포스팅의 가장 처음에 보여준 그림의 순서제어 모듈을 좀더 세부적으로 뜯어보면 아래 그림과 같다. 제어 주소 레지스터에 어떤 값이 들어가냐에 따라 다음에 인출할 마이크로 명령어가 달라진다. 현재 실행중인 마이크로 명령어의 조건 필드(CD)가 MUX2로 들어와 네 개의 조건 비트 중 하나의 값이 주소 선택회로의 입력으로 들어간다. 주소선택회로의 또다른 입력은 현재 실행중인 마이크로 명령어의 분기 필드(BR) 값이다. 즉, 조건필드와 분기필드에 따라 다음에 어떤 마이크로 명령어를 인출할지가 결정되는 것이다. MUX1에는 다음 순서의 마이크로 명령어 시작주소(0), 현재 실행중인 마이크로 명령어에 있는 목적지 주소(1), 서브루틴 호출이 끝난 후의 복귀 주소(SBR), 명령어 실행의 연산코드에 따른 매핑 주소(3) 4개가 입력으로 들어오며, 주소선택 회로의 결과에 따라 4개 중 어떤 주소가 선택될지 결정되는 것이다. 최종적으로 선택된 주소가 제어 주소 레지스터(CAR)로 들어오게 되며 제어 기억장치의 해당 주소에서 마이크로 명령어가 인출된다. 그리고 인출된 마이크로 명령어의 연산 코드는 제어 신호가 되어 외부로 전송된다. 연산 코드 이외의 조건필드, 분기필드, ADF는 다음 마이크로 명령어 인출을 위해 순서 제어 모듈로 들어가 CAR에 적절한 제어 기억장치의 루틴 시작 주소를 적재시킨다.</summary></entry><entry><title type="html">(컴퓨터구조) 3. 컴퓨터의 산술연산과 논리연산</title><link href="http://localhost:4000/2020/02/15/%EC%82%B0%EC%88%A0%EC%97%B0%EC%82%B0%EA%B3%BC-%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0/" rel="alternate" type="text/html" title="(컴퓨터구조) 3. 컴퓨터의 산술연산과 논리연산" /><published>2020-02-15T19:37:19+09:00</published><updated>2020-02-15T19:37:19+09:00</updated><id>http://localhost:4000/2020/02/15/%EC%82%B0%EC%88%A0%EC%97%B0%EC%82%B0%EA%B3%BC%20%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0</id><content type="html" xml:base="http://localhost:4000/2020/02/15/%EC%82%B0%EC%88%A0%EC%97%B0%EC%82%B0%EA%B3%BC-%EB%85%BC%EB%A6%AC%EC%97%B0%EC%82%B0/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;ALU의 구성요소&lt;/li&gt;
  &lt;li&gt;정수 표현방식&lt;/li&gt;
  &lt;li&gt;논리연산&lt;/li&gt;
  &lt;li&gt;시프트연산&lt;/li&gt;
  &lt;li&gt;정수 연산&lt;/li&gt;
  &lt;li&gt;부동소수점 표현방식&lt;/li&gt;
  &lt;li&gt;부동소수점 연산&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-intro&quot;&gt;0. Intro&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;컴퓨터의 출발은 4칙연산 계산기이며 지금도 근본적인 기능은 수치의 산술연산 및 논리 연산이다. 산술연산은 정수와 이외의 실수(부동소수점으로 표현)에 대한 계산이고 논리연산은 2진수로 표현되는 데이터에 대하여(AND, OR, NOT 등) 이루어진다.&lt;/p&gt;

&lt;p&gt;이 장에서는 산술 및 논리연산을 수행하는 CPU의 핵심 부품인 산술논리연산장치(ALU - Arithmetic and Logical Unit)의 내부 구성과 연산 방법에 대한 내용이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-alu의-구성요소&quot;&gt;1. ALU의 구성요소&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;ALU는 CPU를 구성하는 모듈들 중 하나로 수치 및 논리 데이터에 대한 연산을 수행하는 하드웨어이다. ALU의 내부 구성요소들은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) 산술연산장치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;4칙연산 수행&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) 논리연산장치&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;논리연산(AND, OR, NOT, NOR, XOR 등)을 수행&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3) 시프트 레지스터(shift register)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;비트를 좌,우로 이동&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4) 보수기(complementer)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2의 보수 출력&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5) 상태 레지스터(status register)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;연산 결과의 상태를 나타내는 플래그(flag)들을 저장&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/alu_modules.png&quot; alt=&quot;alu_modules&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALU는 CPU의 제어유닛으로부터 오는 제어신호를 받아 계산에 필요한 모듈을 선택하여 연산을 수행하고 결과의 상태들을 상태 레지스터에 저장한다. 상태 레지스터의 플래그들은 조건 분기 등의 이후 프로그램 실행에 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-정수-표현방식&quot;&gt;2. 정수 표현방식&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;컴퓨터는 2진수(binary number) 시스템을 사용하므로 모든것을 0과 1로 표현할 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;만약 음수가 없고 양수만 존재한다면 표현 방법은 수학시간에 배운 일반적인 2진수 표현 방법만큼 간단하다. 예를들어 8bit를 사용해 10진수 60을 나타낸다면 00111100처럼 쓸 수 있다. 혹은 255를 나타낸다면 11111111이 된다.&lt;/p&gt;

&lt;p&gt;그러나 컴퓨터는 음수도 표현해야 하므로 부호 비트(sign bit)를 사용한다. 부호비트를 사용하는 2진수 표현에는  3가지 방법이 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 부호화-크기 표현&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;최상위 비트(MSB - Most Significant Bit)가 0이면 양수, 1이면 음수이다. MSB를 제외한 하위 비트들은 수의 크기를 나타낸다.&lt;/p&gt;

&lt;p&gt;ex1) 8bit를 이용한 +10 표현 -&amp;gt; 00001010
ex2) 8bit를 이용한 -10 표현 -&amp;gt; 10001010&lt;/p&gt;

&lt;p&gt;이 방법의 단점 중 첫번째는 두 개 이상의 정수사이 연산과정에서 부호를 별도로 처리해야한다는 점이다. 두 번째는 0을 표현하는 경우가 2가지가 된다는 점이다. 이 경우 데이터가 ‘0’인지 검사하는 과정이 더 복잡해진다.&lt;/p&gt;

&lt;p&gt;부호화-크기 표현에서 n비트가 표현할 수 있는 수들의 갯수는 (2^n-1) 개이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) 보수 표현&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;보수(complementary number)의 어원적 의미는 상호보완하는 수이다. 보수에는 2가지 종류가 있다. n진법에는 (n-1)의 보수와 n의 보수가 존재한다. 따라서 10진법에서는 9의보수와 10의보수가 사용된다.&lt;/p&gt;

&lt;p&gt;274의 9의 보수는 (999-274) = 725이며, 10의 보수는 (1000-274) = 726이다.&lt;/p&gt;

&lt;p&gt;마찬가지로 2진법에서는 1의보수와 2의보수가 존재한다. 100101의 1의 보수는 모든 비트를 반전시켜 011010이 되며, 2의 보수는 1의 보수에 1을 더한 011011이 된다.&lt;/p&gt;

&lt;p&gt;정리하면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) 1의 보수&lt;/strong&gt; : 모든 비트를 반전시킨다.(0 -&amp;gt; 1, 1 -&amp;gt; 0)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) 2의 보수&lt;/strong&gt; : 모든 비트를 반전시키고(1의 보수를 취하고) 1을 더한다.&lt;/p&gt;

&lt;p&gt;일반적으로 거의 모든 컴퓨터의 숫자 체계는 2의 보수표현을 사용한다. 이유는 2의 보수 표현이 1의 보수 표현보다 표현할 수 있는 수의 가짓수가 1개 더 많기 때문이다. 1의 보수 표현에서는 부호화-크기 표현과 마찬가지로 0에 대한 표현이 2가지 존재한다.&lt;/p&gt;

&lt;p&gt;아래 표는 8비트를 사용하여 표현할 수 있는 수의 범위를 1의 보수 표현과 2의 보수 표현으로 나타낸 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/complement_representation.png&quot; alt=&quot;complement_representation&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;결론적으로 컴퓨터의 정수 체계를 이해한다는 것은 2의 보수 표현을 이해한다는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 10진수 -&amp;gt; 2진수 변환&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;양수 : 일반적인 2진수 계산&lt;/p&gt;

&lt;p&gt;음수 : 매칭되는 양수의 2진수를 계산 후 2의 보수로 변환(비트 반전 -&amp;gt; 1 더하기)&lt;/p&gt;

&lt;p&gt;ex) -100을 8bit의 2진수로 변환 : 100은 2진수로 01100100이고 이를 비트 반전시키면 10011011이며, 1을 더하면 최종적으로 10011100이 된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) 2진수 -&amp;gt; 10진수 변환&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;양수 : 일반적인 2진수 계산&lt;/p&gt;

&lt;p&gt;음수 : MSB가 1일 것이므로 n비트의 경우 -2^(n-1)에다가 나머지 비트들을 10진수로 변환 후 더하기&lt;/p&gt;

&lt;p&gt;ex) 10011100 = -2^7 + 2^4 + 2^3 + 2^2 = -128 + 16 + 8 + 4 = -100&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-논리-연산&quot;&gt;3. 논리 연산&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;논리 연산은 비트 단위로 의미를 가지며, 연산도 비트 단위로 처리된다. 1비트 사이의 기본적인 논리 연산이 아래 표와같이 정리되었다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/logical_operation.png&quot; alt=&quot;logical_operation&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;참고로 XOR 연산은 exclusive-OR 이라는 의미로서 두 비트가 서로 다른 경우에는 결과가 1, 같은 경우에는 0이 된다.&lt;/p&gt;

&lt;p&gt;위의 논리 연산을 위한 실제 하드웨어는 아래 그림과 같이 설계될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/logical_operation_unit.png&quot; alt=&quot;logical_operation_unit&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;입력비트 A와 B는 모든 게이트들을 통과하지만 두 개의 선택 신호(Selection Bit)에 의해 어떤 게이트의 결과가 출력되어 F로 나갈지 선택된다.&lt;/p&gt;

&lt;p&gt;위의 논리연산 모듈을 n개 이어붙이면 n-bit 데이터 사이의 논리연산도 가능해진다. 아래 그림은 4bit 데이터 사이의 논리 연산을 위한 장치이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/logical_operation_module.png&quot; alt=&quot;logical_operation_module&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;데이터의 처리는 CPU의 워드(word) 단위로 처리되므로 실제 CPU 하드웨어에는 논리연산 유닛을 n개 이어붙인 형태가 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-시프트-연산&quot;&gt;4. 시프트 연산&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1) 논리적 시프트 연산&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;데이터 내의 모든 비트를 왼쪽, 혹은 오른쪽으로 한 칸씩 이동시키는 연산이다. 예를들어 좌측 시프트(shift left) 연산을 수행하면 모든 비트가 왼쪽으로 한칸씩 이동한다. 이 때 최상위 비트(MSB - Most Significant Bit)는 날아가고 최하위 비트(LSB - Least Significant Bit)에는 0이 채워진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/logical_shift.png&quot; alt=&quot;logical_shift&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가령 11001011을 좌측 시프트연산 시키면 10010110이 된다. 우측 시프트연산 시키면 01100101이 된다.&lt;/p&gt;

&lt;p&gt;아래는 시프트 레지스터의 내부 구성도이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/logical_shift_unit.png&quot; alt=&quot;logical_shift_unit&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 좌측 시프트 신호(L)를 1로 SET하면 오른쪽 플립플롭의 출력(Q)과 AND연산이 되어서 왼쪽 플립플롭의 입력(D)로 들어가게 된다. 이 때 가장 오른쪽의 AND게이트의 입력으로는 0이 들어와 가장 오른쪽 플립플롭에는 0이 채워진다다.&lt;/p&gt;

&lt;p&gt;우측 시프트 신호(R)를 1로 SET하면 왼쪽 플립플롭의 출력(Q)과 AND연산되어 오른쪽 플립플롭의 입력(D)로 들어가게 된다. 이 때 가장 왼쪽의 AND게이트 입력으로 0이 들어와 가장 왼쪽 플립플롭에는 0이 채워진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 순환 시프트 연산&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;순환 시프트(circular shift) 연산은 논리적 시프트 연산과 같지만 MSB나 LSB를 버리지 않고 반대편 끝에있는 비트 위치로 이동시키는 것이다. 아래 그림은 순환 좌측 시프트 연산을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/circular_shift_left.png&quot; alt=&quot;circular_shift_left&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서는 MSB가 버려지는 대신 0으로 채워질 LSB 위치로 이동하는 것이다.&lt;/p&gt;

&lt;p&gt;결론적으로 논리적 시프트 연산과 다르게 비트가 버려지거나 0으로 채워지는 대신 버려질 비트를 0으로 채워질 비트 자리에 채우는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;3) 산술적 시프트 연산&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;부호비트를 고려하여 수행되는 논리적 시프트 연산이다. 부호 비트는 변하지 않는다는 특징이 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 산술적 좌측 시프트 연산 : MSB는 변하지 않고 나머지 비트들에 대해 논리적 좌측 시프트가 수행된다. LSB는 0으로 채워진다.

b) 산술적 우측 시프트 연산 : MSB는 변하지 않고 나머지 비트들에 대해 논리적 우측 시프트가 수행된다. MSB의 바로 오른쪽 비트는 MSB와 같은 비트로 채워진다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
산술적 시프트 연산의 설명을 종합해보면 양수이건 음수이건 상관없이 좌측 시프트 연산은 원래 데이터에 2를 곱하는 결과를, 우측 시프트 연산은 원래 데이터를 2로 나눈 결과가 된다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;5-정수-연산&quot;&gt;5. 정수 연산&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1) 덧셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;두 수를 더하면 된다. 여기서 올림수(carry)가 발생하여 새로운 자리의 비트가 생성되면 버리면 된다.&lt;/p&gt;

&lt;p&gt;ex1) -4 + 5
 1100
+0101
10001 -&amp;gt; carry 날리면 0001 = 1&lt;/p&gt;

&lt;p&gt;ex2) -100+45
 10011100
+00101101
 11001001 = -55&lt;/p&gt;

&lt;p&gt;이처럼 덧셈을 수행하는 하드웨어 유닛을 병렬 가산기(parallel adder)라고 부른다. 가산기에는 반가산기(half adder)와 전가산기(full adder)가 있다. 병렬 가산기는 전가산기를 병렬로 연결한 모듈이다. n개의 전가산기를 병렬로 연결한 병렬 가산기는 n자리 이진수 사이의 덧셈을 수행할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/parallel_adder.png&quot; alt=&quot;parallel_adder&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;병렬 가산기에서 올림수 비트(carry bit)는 상위 전가산기로 전송된다.&lt;/p&gt;

&lt;p&gt;2진 데이터 (A4A3A2A1)과 (B4B3B2B1)을 더하여 나온 결과는 S4S3S2S1으로 출력된다.&lt;/p&gt;

&lt;p&gt;덧셈의 결과와 관련된 정보를 저장해주는 상태 레지스터에는 아래와같은 플래그들이 포함되어 있다.&lt;/p&gt;

&lt;p&gt;S : 부호 플래그. 최상위 비트(MSB)를 저장한다. 따라서 양수면 0, 음수면 1이 된다. 즉, 덧셈 결과가 음수면 SET이 된다.&lt;/p&gt;

&lt;p&gt;C : 올림수 플래그. 최상위 단계의 전가산기에서 올림수가 발생하면 SET된다.&lt;/p&gt;

&lt;p&gt;Z : 제로(Zero) 플래그. 덧셈결과 각각의 비트가 NOR 게이트를 통과한다. 모든 비트가 0인 경우에만 1이 되므로 덧셈결과가 0이면 Z플래그가 SET이 된다.&lt;/p&gt;

&lt;p&gt;V : 오버플로(overflow) 플래그. 가장 최상위 두 단계의 전가산기의 올림수(위 그림에서는 C4와 C3)가 다르다는 것은 두 수의 덧셈 결과가 비트의 표현 범위를 초과하게 되었다는 것이다. C4와 C3의 값이 XOR 게이트를 통과하므로 두 값이 다르면 V값이 SET된다.&lt;/p&gt;

&lt;p&gt;ex) 오버플로 예제&lt;/p&gt;

&lt;p&gt;4bit로 표현되는 두 수 8과 9를 덧셈해보자.&lt;/p&gt;

&lt;p&gt;1000
+1001
10001 -&amp;gt; 올림수 버리면 0001 = 1&lt;/p&gt;

&lt;p&gt;2의 보수 표현법에서 4비트가 표현 가능한 범위는 -8 ~ +7 이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 뺄셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;뺄셈을 위한 회로는 따로 없다. 예를들어 A에서 B를 빼야하는 경우(A-B)에는 B를 2의 보수화 시켜서 더하면 된다. 논리적으로는 A-B = A+(-B)이다. 물론 덧셈과 마찬가지로 최상위비트에서 발생하는 올림수는 버린다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;3) 곱셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 부호 없는 정수의 곱셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;곱셈은 컴퓨터 입장에서 꽤 복잡한 연산이다. 2의 보수로 표현되는 정수의 곱셈을 보기 전 부호 없는 정수간의 곱셈부터 살펴본다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/unsigned_integer_multiply.png&quot; alt=&quot;unsigned_integer_multiply&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;승수의 각 비트들에 대해 차례대로 곱셈이 수행되고 피승수에 더해진다. 더해진 부분적들은 오른쪽으로 shift하여 새로 나온 부분적과 자릿수를 맞춘다.&lt;/p&gt;

&lt;p&gt;컴퓨터에서는 위 계산을 병렬 가산기를 사용하여 수행한다. 승수 비트가 1이면 피승수를 현재까지의 누적 부분적에 더하고, 0이면 더하지 않으면 된다. 왜냐하면 2진수에서는 모든 비트가 0 혹은 1이기 때문이다. 이 과정을 수행하는 하드웨어 구성도는 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/unsigned_integer_multiply_hardware.png&quot; alt=&quot;unsigned_integer_multiply_hardware&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;레지스터 C와 A, 그리고 Q는 논리적으로 하나의 레지스터로 본다. 계산이 수행될때마다 오른쪽으로 1번씩 shift 연산을 하고 최종적으로 C-A-Q에 저장된 비트들이 곱셈 결과이다.&lt;/p&gt;

&lt;p&gt;초기에는 C와 A는 0으로 채워진다. 그리고 Q에는 승수로 초기화되어있다. 또한 M에 피승수가 저장되어있다.&lt;/p&gt;

&lt;p&gt;매번 연산이 수행될 때 Q의 최하위비트 Q0비트가 1이면 M레지스터의 피승수와 A레지스터의 중간결과가 더해지고, 0이면 더해지지 않는다. 만약 올림수가 발생하면 레지스터 C에 저장된다. 이후에 C-A-Q에서 오른쪽으로 shift연산이 이루어진다. Q레지스터의 최하위비트는 곱셈에 사용되었으므로 버려진다.&lt;/p&gt;

&lt;p&gt;위 예제의 계산이 진행됨에따라 위 그림 하드웨어의 레지스터들 값의 상태변화는 아래 실행도와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/unsigned_integer_multiply_flow.png&quot; alt=&quot;unsigned_integer_multiply_flow&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;b) 2의 보수의 곱셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2의 보수의 곱셈을 위해서는 부호 없는 정수의 곱셈을 위한 하드웨어에 추가적인 모듈이 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;피승수를 저장하는 레지스터 M과 병렬 가산기 사이에 보수기(complementer)가 추가된다.&lt;/li&gt;
  &lt;li&gt;Q레지스터의 오른쪽에 1비트짜리 Q-1 레지스터가 추가된다. Q0 레지스터와 함께 Q-1 레지스터의 값이 제어회로에 입력된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;2의 보수 곱셈을 컴퓨터를 통해 하는 과정은 상당히 난해하다. 가장 널리 쓰이는 알고리즘이 Booth 알고리즘인데, 알고리즘의 흐름도는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/booth_algorithm_flowchart.png&quot; alt=&quot;booth_algorithm_flowchart&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;4) 나눗셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;나눗셈에서도 곱셈과 마찬가지로 반복적인 뺄셈과 시프트 연산으로 수행된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/unsigned_integer_divide.png&quot; alt=&quot;unsigned_integer_divide&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 부호없는 나눗셈 과정이다. 일반적인 나눗셈 과정을 생각해보면 피제수의 비트를 하나씩 내리면서 제수보다 커질 경우 제수를 빼고 부분 나머지를 획득한다. 여기에 피제수의 남은 비트들을 하나씩 이어붙이면서 제수보다 커지면 제수를 빼고 부분 나머지를 획득한다. 이 과정의 반복이다. 다만 곱셈 연산과 다른 점은 시프트연산이 좌측으로 일어난다는 점이다. 이것은 나눗셈의 계산과정과 관련있다. 피제수에서 상위 비트부터 아래로 내려가면서 제수를 빼줄수 있는지 탐색하기 때문이다.&lt;/p&gt;

&lt;p&gt;위 알고리즘의 흐름도는 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/unsigned_integer_divide_flowchart.png&quot; alt=&quot;unsigned_integer_divide_flowchart&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부분 나머지는 레지스터 A에 저장된다. 또한 몫은 레지스터 Q의 최하위비트(Q0)에 한 사이클당 하나씩 채워진다. 그리고 시프트 연산이 수행되는 과정들이 반복되면 최후에 레지스터 Q에는 몫이, A에는 최종 나머지가 저장되어있다.&lt;/p&gt;

&lt;p&gt;특이하게도 피제수를 뺄 수 있는지 체크를 하지않고 부분나머지 A에서 제수 M을 일단 뺀다. 이후 빼는 행위가 정당했다면 A는 0보다 크거나 같을 것이다. 0보다 작다면 몫에 Q0에 0을 넣고 A에 M을 다시 더한다.&lt;/p&gt;

&lt;p&gt;2의 보수의 나눗셈은 위의 알고리즘을 약간 고치면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;지금까지 정수의 4칙연산에 대해 다루었다. 덧셈과 뺄셈은 병렬 가산기에 의해 수행된다. 곱셈과 나눗셈은 알고리즘이 상당히 복잡하다. 그러나 핵심 포인트는 병렬 가산기와 시프트연산의 반복 수행이란 점이다. 실제 곱셈이나 나눗셈 연산을 한 비트씩 진행하면서 중간 결과들을 레지스터에 저장하는 동작이 반복적으로 일어난다는 점이 중요하다. 그 결과로 컴퓨터 입장에서 덧셈과 나눗셈보다는 곱셈, 나눗셈의 연산에 더 많은 자원이 소모된다는 점이 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;6-부동소수점-표현방식&quot;&gt;6. 부동소수점 표현방식&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1) 부동소수점 표현방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;정수의 2진수 표현방법으로도 소수를 표현할 방법이 있지만 표현범위의 한계가 너무 작아 비효율적이다. 과학적 표기의 가수, 지수 개념을 응용하여 표현가능범위를 크게 늘린 방식이 부동소수점(floating-point) 표현 방식이다.&lt;/p&gt;

&lt;p&gt;부동소수점의 일반식은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/floating_point_general_eqeuation.png&quot; alt=&quot;floating_point_general_eqeuation&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;S : 부호(sign)
M : 가수(mantissa)
B : 기수(base)
E : 지수(exponent)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;예를들어 10진 부동소수점 수 3.48 * 10^21에서 S=0, M=3.48, B=10, E=21이다.&lt;/p&gt;

&lt;p&gt;10진 부동소수점수에서 B는 10이고, 2진 부동소수점의경우 B는 2로 암묵적 약속이 되어있어 실제 표현에서는 B를위한 비트는 할당되지 않는다. 컴퓨터가 사용하는 방식은 2진 부동소수점 방식으로 모든 수가 0 혹은 1이다.&lt;/p&gt;

&lt;p&gt;2진 부동소수점 수에는 32비트 혹은 64비트가 표현형식이 있다. 아래 그림은 전형적인 32비트 2진 부동소수점 수의 형식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/32bit_floating_point_representation.png&quot; alt=&quot;32bit_floating_point_representation&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;가수 M에 할당된 비트수가 클수록 수를 더욱 정밀하게 표현할 수 있으며, 지수 E에 할당된 범위가 클수록 표현가능 범위가 늘어난다. 하나를 위해 더 많은 비트수를 할당하면 다른 하나는 줄어들기때문에 적절한 범위 조절이 필요하다.&lt;/p&gt;

&lt;p&gt;위 그림에서 지수 필드는 8비트를 사용하므로 -2^7 ~ +2^7-1의 범위를 표현할 수 있다. 또한 가수 필드는 23비트를 사용하므로 2^-23의 정밀도까지 수를 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 정규화 표현&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;부동소수점 표현에서는 아래와 같이 하나의 같은수를 위한 여러개의 표현이 존재할 수 있다.&lt;/p&gt;

&lt;p&gt;0.1101 * 2^5 = 11.01 * 2^3 = 0.001101 * 2^7&lt;/p&gt;

&lt;p&gt;위 수들은 모두 동일하다. 혼란을 막기위해 부동소수점 표현에서는 정규화 표현(normalized representation)을 사용한다.&lt;/p&gt;

&lt;p&gt;정수 부분은 0이며, 소숫점 첫째 자리는 1이 되도록 지수 E를 고정한 표현방식이 정규화 표현이다. 위 3개의 수들 중 정규화표현에 해당하는 수는 0.1101 * 2^5이다. 여기서 0.1bbb의 형태를 만들기위해 지수 E는 5로 고정되었다.&lt;/p&gt;

&lt;p&gt;그럼 0.1101 * 2^5의 예를 32비트 지금까지 설명한 부동소수점 형식으로 표현해보자.&lt;/p&gt;

&lt;p&gt;부동소수점 표현에서 정수부분 0은 표현할 필요가 없다.&lt;/p&gt;

&lt;p&gt;가수필드(M) 1101 0000 0000 0000 0000 000 이 된다.&lt;/p&gt;

&lt;p&gt;지수필드(E) 0000 0101&lt;/p&gt;

&lt;p&gt;부호필드(S) 0&lt;/p&gt;

&lt;p&gt;단순히 각각의 필드에 해당 수를 넣어주면 된다. 그러나 실제로는 여러가지 문제점때문에 이러한 방식을 사용하지 않는다. 위 부동소수점 표현에 2가지 변화가 추가된다. 이 2가지 변화를 설명한 후 그 문제점이 무엇이고 아래의 방법이 어떻게 해결을 하는지 설명한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 바이어스(bias)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;지수 필드는 그대로 사용되지 않는다. &lt;strong&gt;&lt;em&gt;지수 필드의 비트는 실제 지수에 +128(1000 0000)을 더한 값이다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를들어 0.1101 * 2^5에서는 지수필드가 5(0000 0101) 이었지만 실제 컴퓨터는 여기에 +128(1000 0000)을 더한 (1000 0101)을 사용한다. 즉, 실제 지수필드 값이 +128 바이어스되어 사용된다.&lt;/p&gt;

&lt;p&gt;바이어스는 기준점 정도로 생각하면 된다. 비슷한 예로 우리가 사용하는 모든 전압 표현은 땅의 전압을 기준으로 바이어스된 전압인 것과 마찬가지이다. 즉, 5V라고 말하는 표현은 지구 땅의 전압보다 5V가 높다는 것이다.&lt;/p&gt;

&lt;p&gt;반대로 실제 지수 필드를 구할때는 &lt;strong&gt;&lt;em&gt;지수 비트에서 128(1000 0000)을 빼서 구한다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;결과를 정리하자면 0000 0000(-128)부터 1111 1111(+127)까지가 있다.&lt;/p&gt;

&lt;p&gt;이렇게 했을때 해결되는 문제점은 0-비트 검사 문제이다. 기존 방식에서는 0을 표현할 때 가수(M)만 0이 된다면 지수필드 E는 어떤 값이 되어도 상관없었다. 그러나 바이어스를 사용하면 가수가 0이고 지수필드가 0일 때 지수가 -127이 되고 이는 0에 매우 근접한 수이다. 여기서 중요한 점은 이 때 모든 비트가 0이 된다는 점이고 CPU가 쉽게 0비트 검사를 할 수가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b)첫 번째 소수점은 표현하지 않는다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;정규화 표현에서의 약속은 0.1bbbbb * 2^E 형태였다. 첫 번째 소숫점은 항상 1로 고정되므로 처리할 때 이를 따져주기만 하면 된다. 따라서 가수 필드에서는 첫 번째 소수점의 1은 표시하지 않기 때문에 1비트를 추가적으로 사용할 수 있게 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 두 가지 변화사항을 적용하여 새로이 0.1101 *2^5의 32비트 부동소수점 필드값들을 계산해보자.&lt;/p&gt;

&lt;p&gt;가수필드(M) : 첫 번째 소수점은 넣지 않으므로 1010 0000 0000 0000 0000 000&lt;/p&gt;

&lt;p&gt;지수필드(E) : 실제 지수 5(0000 0101)에 128(1000 0000)을 더한 1000 0101&lt;/p&gt;

&lt;p&gt;부호 필드(S) : 0&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 결과들을 종합했을 때 32비트 부동소수점 표현방식이 나타낼 수 있는 수의 표현범위는 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/floating_point_representation_range.png&quot; alt=&quot;floating_point_representation_range&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;양수를 기준으로 가장 작은 수는 먼저 가수의 0.1bbbbb 부분에서 모든 b가 0이 될 경우, 즉 0.5이다. 또한 지수는 -128 ~ +128 범위를 가지므로 지수는 -128인 경우이다. 즉, 0.5 * 2^-128이 나타낼 수 있는 가장 작은 수이다.&lt;/p&gt;

&lt;p&gt;가장 큰 수는 모든 가수가 1이 되는 경우에는 모든 23비트의 가수필드가 1이 되고 지수가 127이 되는경우, 즉 (1/2 + 1/4 + 1/8 + … + 2^-24) * 2^127 이다.&lt;/p&gt;

&lt;p&gt;위 그림에서 절대값이 아무리 작아도 0으로는 근접할 수 없기 때문에 언더플로우가 존재한다. 또한 범위를 넘어가는 경우에는 오버플로우가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;3) IEEE 754 부동소수점 표현 형식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;미국 전기전자공학회(IEEE)에서는 가수부를 0.1bbbb 형식이 아닌 1.M 형식을 사용한다. 또한 바이어스를 128이 아닌 127(0111 1111)을 사용한다.&lt;/p&gt;

&lt;p&gt;따라서 부호필드 비트가 S, 가수필드 비트가 M, 지수필드 비트가 E라면 실수 N = (-1)^S * (1.M) * 2^(E-127)이 된다.&lt;/p&gt;

&lt;p&gt;-1101.101 = -1.101101 * 2^3; [1][0000 0011][1011 0100 0000 0000 0000 000]&lt;/p&gt;

&lt;p&gt;00000011
01111111
10000010&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;7-부동소수점-연산&quot;&gt;7. 부동소수점 연산&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1) 덧셈과 뺄셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;덧셈과 뺄셈을 할때는 지수부를 일치시켜야 한다. 자릿수를 맞추는 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/floating_point_addition.png&quot; alt=&quot;floating_point_addition&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;부동소수점의 덧셈 과정을 정리하면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 소수점 위치가 같아지도록 지수를 일치시킨다.
b) 가수들간의 덧셈을 수행한다.
c) 결과를 정규화시킨다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;소수점 위치가 같아지도록 조정하는 과정은 가수부를 오른쪽으로 쉬프트 시키고 한 번의 쉬프트연산마다 지수를 1씩 증가시키는 것이다. 이 과정을 두 수의 지수가 같아질때까지 하면 된다.&lt;/p&gt;

&lt;p&gt;지수값을 일치시킬 때 더 작은 지수의 값을 더 큰 지수로 맞추어 주는것이 좋다. 그래야 버려지는 비트가 발생하더라도 잃게되는 수의 절대크기가 상대적으로 작은 값이 되기때문에 오차범위가 줄어든다.&lt;/p&gt;

&lt;p&gt;빼기 과정은 감수(빼지는 수)를 2의 보수를 취한후에 덧셈과정을 진행하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 곱셈과 나눗셈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;곱셈과 나눗셈은 지수부 일치가 필요하지 않기때문에 덧셈 과정보다 간단하다. 2진 부동소수점의 곱셈 과정은 아래의 단계들로 이루어진다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 가수끼리 곱한다.
b) 지수끼리 더한다. 바이어스도 두 번 더해진것이므로 바이어스를 뺀다.
c) 결과를 정규화한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래 그림은 위 과정을 수행하는 예제이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/3/floating_point_multiplication.png&quot; alt=&quot;floating_point_multiplication&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
나눗셈의 경우에는 가수끼리 나누고 지수끼리 빼면 된다는 점만 다르고 나머지는 곱셈 과정과 동일하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
부동 소수점의 4칙연산 과정에서는 오버플로우 문제가 발생할 수 있다. 예를들어 곱셈 과정에서 지수끼리 더했는데 표현할 수 있는 범위를 넘어서는 경우 엉뚱한 값이 저장된다. 혹은 덧셈 과정에서 소수점 위치를 맞추기 위해 더 작은수의 가수를 쉬프트 시키는 과정에서 버려지는 수가 발생하게 될 수도 있는데, 이 때는 반올림이나 버림 과정이 진행된다. 이 때는 버려지는 비트 자릿수가 MSB에 비해 절대적 크기가 작은 경우에는 크게 문제가 되지 않으므로 지수 오버플로우보다는 그 영향력이 덜하다고 할 수 있다.&lt;/p&gt;</content><author><name>nobbaggu</name></author><category term="ALU" /><category term="정수" /><category term="부동소수점" /><category term="시프트연산" /><category term="논리연산" /><category term="레지스터" /><category term="보수" /><category term="AND" /><category term="OR" /><category term="XOR" /><category term="NOR" /><category term="NOT" /><category term="CPU" /><category term="부호비트" /><summary type="html">목차 ALU의 구성요소 정수 표현방식 논리연산 시프트연산 정수 연산 부동소수점 표현방식 부동소수점 연산 0. Intro 컴퓨터의 출발은 4칙연산 계산기이며 지금도 근본적인 기능은 수치의 산술연산 및 논리 연산이다. 산술연산은 정수와 이외의 실수(부동소수점으로 표현)에 대한 계산이고 논리연산은 2진수로 표현되는 데이터에 대하여(AND, OR, NOT 등) 이루어진다. 이 장에서는 산술 및 논리연산을 수행하는 CPU의 핵심 부품인 산술논리연산장치(ALU - Arithmetic and Logical Unit)의 내부 구성과 연산 방법에 대한 내용이다. 1. ALU의 구성요소 ALU는 CPU를 구성하는 모듈들 중 하나로 수치 및 논리 데이터에 대한 연산을 수행하는 하드웨어이다. ALU의 내부 구성요소들은 아래와 같다. 1) 산술연산장치 4칙연산 수행 2) 논리연산장치 논리연산(AND, OR, NOT, NOR, XOR 등)을 수행 3) 시프트 레지스터(shift register) 비트를 좌,우로 이동 4) 보수기(complementer) 2의 보수 출력 5) 상태 레지스터(status register) 연산 결과의 상태를 나타내는 플래그(flag)들을 저장 ALU는 CPU의 제어유닛으로부터 오는 제어신호를 받아 계산에 필요한 모듈을 선택하여 연산을 수행하고 결과의 상태들을 상태 레지스터에 저장한다. 상태 레지스터의 플래그들은 조건 분기 등의 이후 프로그램 실행에 사용된다. 2. 정수 표현방식 컴퓨터는 2진수(binary number) 시스템을 사용하므로 모든것을 0과 1로 표현할 수 밖에 없다. 만약 음수가 없고 양수만 존재한다면 표현 방법은 수학시간에 배운 일반적인 2진수 표현 방법만큼 간단하다. 예를들어 8bit를 사용해 10진수 60을 나타낸다면 00111100처럼 쓸 수 있다. 혹은 255를 나타낸다면 11111111이 된다. 그러나 컴퓨터는 음수도 표현해야 하므로 부호 비트(sign bit)를 사용한다. 부호비트를 사용하는 2진수 표현에는 3가지 방법이 있다. a) 부호화-크기 표현 최상위 비트(MSB - Most Significant Bit)가 0이면 양수, 1이면 음수이다. MSB를 제외한 하위 비트들은 수의 크기를 나타낸다. ex1) 8bit를 이용한 +10 표현 -&amp;gt; 00001010 ex2) 8bit를 이용한 -10 표현 -&amp;gt; 10001010 이 방법의 단점 중 첫번째는 두 개 이상의 정수사이 연산과정에서 부호를 별도로 처리해야한다는 점이다. 두 번째는 0을 표현하는 경우가 2가지가 된다는 점이다. 이 경우 데이터가 ‘0’인지 검사하는 과정이 더 복잡해진다. 부호화-크기 표현에서 n비트가 표현할 수 있는 수들의 갯수는 (2^n-1) 개이다. b) 보수 표현 보수(complementary number)의 어원적 의미는 상호보완하는 수이다. 보수에는 2가지 종류가 있다. n진법에는 (n-1)의 보수와 n의 보수가 존재한다. 따라서 10진법에서는 9의보수와 10의보수가 사용된다. 274의 9의 보수는 (999-274) = 725이며, 10의 보수는 (1000-274) = 726이다. 마찬가지로 2진법에서는 1의보수와 2의보수가 존재한다. 100101의 1의 보수는 모든 비트를 반전시켜 011010이 되며, 2의 보수는 1의 보수에 1을 더한 011011이 된다. 정리하면 아래와 같다. 1) 1의 보수 : 모든 비트를 반전시킨다.(0 -&amp;gt; 1, 1 -&amp;gt; 0) 2) 2의 보수 : 모든 비트를 반전시키고(1의 보수를 취하고) 1을 더한다. 일반적으로 거의 모든 컴퓨터의 숫자 체계는 2의 보수표현을 사용한다. 이유는 2의 보수 표현이 1의 보수 표현보다 표현할 수 있는 수의 가짓수가 1개 더 많기 때문이다. 1의 보수 표현에서는 부호화-크기 표현과 마찬가지로 0에 대한 표현이 2가지 존재한다. 아래 표는 8비트를 사용하여 표현할 수 있는 수의 범위를 1의 보수 표현과 2의 보수 표현으로 나타낸 것이다. 결론적으로 컴퓨터의 정수 체계를 이해한다는 것은 2의 보수 표현을 이해한다는 것이다. a) 10진수 -&amp;gt; 2진수 변환 양수 : 일반적인 2진수 계산 음수 : 매칭되는 양수의 2진수를 계산 후 2의 보수로 변환(비트 반전 -&amp;gt; 1 더하기) ex) -100을 8bit의 2진수로 변환 : 100은 2진수로 01100100이고 이를 비트 반전시키면 10011011이며, 1을 더하면 최종적으로 10011100이 된다. b) 2진수 -&amp;gt; 10진수 변환 양수 : 일반적인 2진수 계산 음수 : MSB가 1일 것이므로 n비트의 경우 -2^(n-1)에다가 나머지 비트들을 10진수로 변환 후 더하기 ex) 10011100 = -2^7 + 2^4 + 2^3 + 2^2 = -128 + 16 + 8 + 4 = -100 3. 논리 연산 논리 연산은 비트 단위로 의미를 가지며, 연산도 비트 단위로 처리된다. 1비트 사이의 기본적인 논리 연산이 아래 표와같이 정리되었다. 참고로 XOR 연산은 exclusive-OR 이라는 의미로서 두 비트가 서로 다른 경우에는 결과가 1, 같은 경우에는 0이 된다. 위의 논리 연산을 위한 실제 하드웨어는 아래 그림과 같이 설계될 수 있다. 입력비트 A와 B는 모든 게이트들을 통과하지만 두 개의 선택 신호(Selection Bit)에 의해 어떤 게이트의 결과가 출력되어 F로 나갈지 선택된다. 위의 논리연산 모듈을 n개 이어붙이면 n-bit 데이터 사이의 논리연산도 가능해진다. 아래 그림은 4bit 데이터 사이의 논리 연산을 위한 장치이다. 데이터의 처리는 CPU의 워드(word) 단위로 처리되므로 실제 CPU 하드웨어에는 논리연산 유닛을 n개 이어붙인 형태가 될 것이다. 4. 시프트 연산 1) 논리적 시프트 연산 데이터 내의 모든 비트를 왼쪽, 혹은 오른쪽으로 한 칸씩 이동시키는 연산이다. 예를들어 좌측 시프트(shift left) 연산을 수행하면 모든 비트가 왼쪽으로 한칸씩 이동한다. 이 때 최상위 비트(MSB - Most Significant Bit)는 날아가고 최하위 비트(LSB - Least Significant Bit)에는 0이 채워진다. 가령 11001011을 좌측 시프트연산 시키면 10010110이 된다. 우측 시프트연산 시키면 01100101이 된다. 아래는 시프트 레지스터의 내부 구성도이다. 위 그림에서 좌측 시프트 신호(L)를 1로 SET하면 오른쪽 플립플롭의 출력(Q)과 AND연산이 되어서 왼쪽 플립플롭의 입력(D)로 들어가게 된다. 이 때 가장 오른쪽의 AND게이트의 입력으로는 0이 들어와 가장 오른쪽 플립플롭에는 0이 채워진다다. 우측 시프트 신호(R)를 1로 SET하면 왼쪽 플립플롭의 출력(Q)과 AND연산되어 오른쪽 플립플롭의 입력(D)로 들어가게 된다. 이 때 가장 왼쪽의 AND게이트 입력으로 0이 들어와 가장 왼쪽 플립플롭에는 0이 채워진다. 2) 순환 시프트 연산 순환 시프트(circular shift) 연산은 논리적 시프트 연산과 같지만 MSB나 LSB를 버리지 않고 반대편 끝에있는 비트 위치로 이동시키는 것이다. 아래 그림은 순환 좌측 시프트 연산을 보여준다. 위 그림에서는 MSB가 버려지는 대신 0으로 채워질 LSB 위치로 이동하는 것이다. 결론적으로 논리적 시프트 연산과 다르게 비트가 버려지거나 0으로 채워지는 대신 버려질 비트를 0으로 채워질 비트 자리에 채우는 것이다. 3) 산술적 시프트 연산 부호비트를 고려하여 수행되는 논리적 시프트 연산이다. 부호 비트는 변하지 않는다는 특징이 있다. a) 산술적 좌측 시프트 연산 : MSB는 변하지 않고 나머지 비트들에 대해 논리적 좌측 시프트가 수행된다. LSB는 0으로 채워진다. b) 산술적 우측 시프트 연산 : MSB는 변하지 않고 나머지 비트들에 대해 논리적 우측 시프트가 수행된다. MSB의 바로 오른쪽 비트는 MSB와 같은 비트로 채워진다. 산술적 시프트 연산의 설명을 종합해보면 양수이건 음수이건 상관없이 좌측 시프트 연산은 원래 데이터에 2를 곱하는 결과를, 우측 시프트 연산은 원래 데이터를 2로 나눈 결과가 된다는 점이다. 5. 정수 연산 1) 덧셈 두 수를 더하면 된다. 여기서 올림수(carry)가 발생하여 새로운 자리의 비트가 생성되면 버리면 된다. ex1) -4 + 5 1100 +0101 10001 -&amp;gt; carry 날리면 0001 = 1 ex2) -100+45 10011100 +00101101 11001001 = -55 이처럼 덧셈을 수행하는 하드웨어 유닛을 병렬 가산기(parallel adder)라고 부른다. 가산기에는 반가산기(half adder)와 전가산기(full adder)가 있다. 병렬 가산기는 전가산기를 병렬로 연결한 모듈이다. n개의 전가산기를 병렬로 연결한 병렬 가산기는 n자리 이진수 사이의 덧셈을 수행할 수 있다. 병렬 가산기에서 올림수 비트(carry bit)는 상위 전가산기로 전송된다. 2진 데이터 (A4A3A2A1)과 (B4B3B2B1)을 더하여 나온 결과는 S4S3S2S1으로 출력된다. 덧셈의 결과와 관련된 정보를 저장해주는 상태 레지스터에는 아래와같은 플래그들이 포함되어 있다. S : 부호 플래그. 최상위 비트(MSB)를 저장한다. 따라서 양수면 0, 음수면 1이 된다. 즉, 덧셈 결과가 음수면 SET이 된다. C : 올림수 플래그. 최상위 단계의 전가산기에서 올림수가 발생하면 SET된다. Z : 제로(Zero) 플래그. 덧셈결과 각각의 비트가 NOR 게이트를 통과한다. 모든 비트가 0인 경우에만 1이 되므로 덧셈결과가 0이면 Z플래그가 SET이 된다. V : 오버플로(overflow) 플래그. 가장 최상위 두 단계의 전가산기의 올림수(위 그림에서는 C4와 C3)가 다르다는 것은 두 수의 덧셈 결과가 비트의 표현 범위를 초과하게 되었다는 것이다. C4와 C3의 값이 XOR 게이트를 통과하므로 두 값이 다르면 V값이 SET된다. ex) 오버플로 예제 4bit로 표현되는 두 수 8과 9를 덧셈해보자. 1000 +1001 10001 -&amp;gt; 올림수 버리면 0001 = 1 2의 보수 표현법에서 4비트가 표현 가능한 범위는 -8 ~ +7 이다. 2) 뺄셈 뺄셈을 위한 회로는 따로 없다. 예를들어 A에서 B를 빼야하는 경우(A-B)에는 B를 2의 보수화 시켜서 더하면 된다. 논리적으로는 A-B = A+(-B)이다. 물론 덧셈과 마찬가지로 최상위비트에서 발생하는 올림수는 버린다. 3) 곱셈 a) 부호 없는 정수의 곱셈 곱셈은 컴퓨터 입장에서 꽤 복잡한 연산이다. 2의 보수로 표현되는 정수의 곱셈을 보기 전 부호 없는 정수간의 곱셈부터 살펴본다. 승수의 각 비트들에 대해 차례대로 곱셈이 수행되고 피승수에 더해진다. 더해진 부분적들은 오른쪽으로 shift하여 새로 나온 부분적과 자릿수를 맞춘다. 컴퓨터에서는 위 계산을 병렬 가산기를 사용하여 수행한다. 승수 비트가 1이면 피승수를 현재까지의 누적 부분적에 더하고, 0이면 더하지 않으면 된다. 왜냐하면 2진수에서는 모든 비트가 0 혹은 1이기 때문이다. 이 과정을 수행하는 하드웨어 구성도는 아래 그림과 같다. 레지스터 C와 A, 그리고 Q는 논리적으로 하나의 레지스터로 본다. 계산이 수행될때마다 오른쪽으로 1번씩 shift 연산을 하고 최종적으로 C-A-Q에 저장된 비트들이 곱셈 결과이다. 초기에는 C와 A는 0으로 채워진다. 그리고 Q에는 승수로 초기화되어있다. 또한 M에 피승수가 저장되어있다. 매번 연산이 수행될 때 Q의 최하위비트 Q0비트가 1이면 M레지스터의 피승수와 A레지스터의 중간결과가 더해지고, 0이면 더해지지 않는다. 만약 올림수가 발생하면 레지스터 C에 저장된다. 이후에 C-A-Q에서 오른쪽으로 shift연산이 이루어진다. Q레지스터의 최하위비트는 곱셈에 사용되었으므로 버려진다. 위 예제의 계산이 진행됨에따라 위 그림 하드웨어의 레지스터들 값의 상태변화는 아래 실행도와 같다. b) 2의 보수의 곱셈 2의 보수의 곱셈을 위해서는 부호 없는 정수의 곱셈을 위한 하드웨어에 추가적인 모듈이 필요하다. 피승수를 저장하는 레지스터 M과 병렬 가산기 사이에 보수기(complementer)가 추가된다. Q레지스터의 오른쪽에 1비트짜리 Q-1 레지스터가 추가된다. Q0 레지스터와 함께 Q-1 레지스터의 값이 제어회로에 입력된다. 2의 보수 곱셈을 컴퓨터를 통해 하는 과정은 상당히 난해하다. 가장 널리 쓰이는 알고리즘이 Booth 알고리즘인데, 알고리즘의 흐름도는 아래와 같다. 4) 나눗셈 나눗셈에서도 곱셈과 마찬가지로 반복적인 뺄셈과 시프트 연산으로 수행된다. 위 그림은 부호없는 나눗셈 과정이다. 일반적인 나눗셈 과정을 생각해보면 피제수의 비트를 하나씩 내리면서 제수보다 커질 경우 제수를 빼고 부분 나머지를 획득한다. 여기에 피제수의 남은 비트들을 하나씩 이어붙이면서 제수보다 커지면 제수를 빼고 부분 나머지를 획득한다. 이 과정의 반복이다. 다만 곱셈 연산과 다른 점은 시프트연산이 좌측으로 일어난다는 점이다. 이것은 나눗셈의 계산과정과 관련있다. 피제수에서 상위 비트부터 아래로 내려가면서 제수를 빼줄수 있는지 탐색하기 때문이다. 위 알고리즘의 흐름도는 아래 그림과 같다. 부분 나머지는 레지스터 A에 저장된다. 또한 몫은 레지스터 Q의 최하위비트(Q0)에 한 사이클당 하나씩 채워진다. 그리고 시프트 연산이 수행되는 과정들이 반복되면 최후에 레지스터 Q에는 몫이, A에는 최종 나머지가 저장되어있다. 특이하게도 피제수를 뺄 수 있는지 체크를 하지않고 부분나머지 A에서 제수 M을 일단 뺀다. 이후 빼는 행위가 정당했다면 A는 0보다 크거나 같을 것이다. 0보다 작다면 몫에 Q0에 0을 넣고 A에 M을 다시 더한다. 2의 보수의 나눗셈은 위의 알고리즘을 약간 고치면 된다. 지금까지 정수의 4칙연산에 대해 다루었다. 덧셈과 뺄셈은 병렬 가산기에 의해 수행된다. 곱셈과 나눗셈은 알고리즘이 상당히 복잡하다. 그러나 핵심 포인트는 병렬 가산기와 시프트연산의 반복 수행이란 점이다. 실제 곱셈이나 나눗셈 연산을 한 비트씩 진행하면서 중간 결과들을 레지스터에 저장하는 동작이 반복적으로 일어난다는 점이 중요하다. 그 결과로 컴퓨터 입장에서 덧셈과 나눗셈보다는 곱셈, 나눗셈의 연산에 더 많은 자원이 소모된다는 점이 중요하다. 6. 부동소수점 표현방식 1) 부동소수점 표현방식 정수의 2진수 표현방법으로도 소수를 표현할 방법이 있지만 표현범위의 한계가 너무 작아 비효율적이다. 과학적 표기의 가수, 지수 개념을 응용하여 표현가능범위를 크게 늘린 방식이 부동소수점(floating-point) 표현 방식이다. 부동소수점의 일반식은 아래와 같다. S : 부호(sign) M : 가수(mantissa) B : 기수(base) E : 지수(exponent) 예를들어 10진 부동소수점 수 3.48 * 10^21에서 S=0, M=3.48, B=10, E=21이다. 10진 부동소수점수에서 B는 10이고, 2진 부동소수점의경우 B는 2로 암묵적 약속이 되어있어 실제 표현에서는 B를위한 비트는 할당되지 않는다. 컴퓨터가 사용하는 방식은 2진 부동소수점 방식으로 모든 수가 0 혹은 1이다. 2진 부동소수점 수에는 32비트 혹은 64비트가 표현형식이 있다. 아래 그림은 전형적인 32비트 2진 부동소수점 수의 형식이다. 가수 M에 할당된 비트수가 클수록 수를 더욱 정밀하게 표현할 수 있으며, 지수 E에 할당된 범위가 클수록 표현가능 범위가 늘어난다. 하나를 위해 더 많은 비트수를 할당하면 다른 하나는 줄어들기때문에 적절한 범위 조절이 필요하다. 위 그림에서 지수 필드는 8비트를 사용하므로 -2^7 ~ +2^7-1의 범위를 표현할 수 있다. 또한 가수 필드는 23비트를 사용하므로 2^-23의 정밀도까지 수를 표현할 수 있다. 2) 정규화 표현 부동소수점 표현에서는 아래와 같이 하나의 같은수를 위한 여러개의 표현이 존재할 수 있다. 0.1101 * 2^5 = 11.01 * 2^3 = 0.001101 * 2^7 위 수들은 모두 동일하다. 혼란을 막기위해 부동소수점 표현에서는 정규화 표현(normalized representation)을 사용한다. 정수 부분은 0이며, 소숫점 첫째 자리는 1이 되도록 지수 E를 고정한 표현방식이 정규화 표현이다. 위 3개의 수들 중 정규화표현에 해당하는 수는 0.1101 * 2^5이다. 여기서 0.1bbb의 형태를 만들기위해 지수 E는 5로 고정되었다. 그럼 0.1101 * 2^5의 예를 32비트 지금까지 설명한 부동소수점 형식으로 표현해보자. 부동소수점 표현에서 정수부분 0은 표현할 필요가 없다. 가수필드(M) 1101 0000 0000 0000 0000 000 이 된다. 지수필드(E) 0000 0101 부호필드(S) 0 단순히 각각의 필드에 해당 수를 넣어주면 된다. 그러나 실제로는 여러가지 문제점때문에 이러한 방식을 사용하지 않는다. 위 부동소수점 표현에 2가지 변화가 추가된다. 이 2가지 변화를 설명한 후 그 문제점이 무엇이고 아래의 방법이 어떻게 해결을 하는지 설명한다. a) 바이어스(bias) 지수 필드는 그대로 사용되지 않는다. 지수 필드의 비트는 실제 지수에 +128(1000 0000)을 더한 값이다. 예를들어 0.1101 * 2^5에서는 지수필드가 5(0000 0101) 이었지만 실제 컴퓨터는 여기에 +128(1000 0000)을 더한 (1000 0101)을 사용한다. 즉, 실제 지수필드 값이 +128 바이어스되어 사용된다. 바이어스는 기준점 정도로 생각하면 된다. 비슷한 예로 우리가 사용하는 모든 전압 표현은 땅의 전압을 기준으로 바이어스된 전압인 것과 마찬가지이다. 즉, 5V라고 말하는 표현은 지구 땅의 전압보다 5V가 높다는 것이다. 반대로 실제 지수 필드를 구할때는 지수 비트에서 128(1000 0000)을 빼서 구한다. 결과를 정리하자면 0000 0000(-128)부터 1111 1111(+127)까지가 있다. 이렇게 했을때 해결되는 문제점은 0-비트 검사 문제이다. 기존 방식에서는 0을 표현할 때 가수(M)만 0이 된다면 지수필드 E는 어떤 값이 되어도 상관없었다. 그러나 바이어스를 사용하면 가수가 0이고 지수필드가 0일 때 지수가 -127이 되고 이는 0에 매우 근접한 수이다. 여기서 중요한 점은 이 때 모든 비트가 0이 된다는 점이고 CPU가 쉽게 0비트 검사를 할 수가 있다. b)첫 번째 소수점은 표현하지 않는다 정규화 표현에서의 약속은 0.1bbbbb * 2^E 형태였다. 첫 번째 소숫점은 항상 1로 고정되므로 처리할 때 이를 따져주기만 하면 된다. 따라서 가수 필드에서는 첫 번째 소수점의 1은 표시하지 않기 때문에 1비트를 추가적으로 사용할 수 있게 된다. 위 두 가지 변화사항을 적용하여 새로이 0.1101 *2^5의 32비트 부동소수점 필드값들을 계산해보자. 가수필드(M) : 첫 번째 소수점은 넣지 않으므로 1010 0000 0000 0000 0000 000 지수필드(E) : 실제 지수 5(0000 0101)에 128(1000 0000)을 더한 1000 0101 부호 필드(S) : 0 위 결과들을 종합했을 때 32비트 부동소수점 표현방식이 나타낼 수 있는 수의 표현범위는 아래 그림과 같다. 양수를 기준으로 가장 작은 수는 먼저 가수의 0.1bbbbb 부분에서 모든 b가 0이 될 경우, 즉 0.5이다. 또한 지수는 -128 ~ +128 범위를 가지므로 지수는 -128인 경우이다. 즉, 0.5 * 2^-128이 나타낼 수 있는 가장 작은 수이다. 가장 큰 수는 모든 가수가 1이 되는 경우에는 모든 23비트의 가수필드가 1이 되고 지수가 127이 되는경우, 즉 (1/2 + 1/4 + 1/8 + … + 2^-24) * 2^127 이다. 위 그림에서 절대값이 아무리 작아도 0으로는 근접할 수 없기 때문에 언더플로우가 존재한다. 또한 범위를 넘어가는 경우에는 오버플로우가 발생한다. 3) IEEE 754 부동소수점 표현 형식 미국 전기전자공학회(IEEE)에서는 가수부를 0.1bbbb 형식이 아닌 1.M 형식을 사용한다. 또한 바이어스를 128이 아닌 127(0111 1111)을 사용한다. 따라서 부호필드 비트가 S, 가수필드 비트가 M, 지수필드 비트가 E라면 실수 N = (-1)^S * (1.M) * 2^(E-127)이 된다. -1101.101 = -1.101101 * 2^3; [1][0000 0011][1011 0100 0000 0000 0000 000] 00000011 01111111 10000010 7. 부동소수점 연산 1) 덧셈과 뺄셈 덧셈과 뺄셈을 할때는 지수부를 일치시켜야 한다. 자릿수를 맞추는 것이다. 부동소수점의 덧셈 과정을 정리하면 아래와 같다. a) 소수점 위치가 같아지도록 지수를 일치시킨다. b) 가수들간의 덧셈을 수행한다. c) 결과를 정규화시킨다. 소수점 위치가 같아지도록 조정하는 과정은 가수부를 오른쪽으로 쉬프트 시키고 한 번의 쉬프트연산마다 지수를 1씩 증가시키는 것이다. 이 과정을 두 수의 지수가 같아질때까지 하면 된다. 지수값을 일치시킬 때 더 작은 지수의 값을 더 큰 지수로 맞추어 주는것이 좋다. 그래야 버려지는 비트가 발생하더라도 잃게되는 수의 절대크기가 상대적으로 작은 값이 되기때문에 오차범위가 줄어든다. 빼기 과정은 감수(빼지는 수)를 2의 보수를 취한후에 덧셈과정을 진행하면 된다. 2) 곱셈과 나눗셈 곱셈과 나눗셈은 지수부 일치가 필요하지 않기때문에 덧셈 과정보다 간단하다. 2진 부동소수점의 곱셈 과정은 아래의 단계들로 이루어진다. a) 가수끼리 곱한다. b) 지수끼리 더한다. 바이어스도 두 번 더해진것이므로 바이어스를 뺀다. c) 결과를 정규화한다. 아래 그림은 위 과정을 수행하는 예제이다. 나눗셈의 경우에는 가수끼리 나누고 지수끼리 빼면 된다는 점만 다르고 나머지는 곱셈 과정과 동일하다. 부동 소수점의 4칙연산 과정에서는 오버플로우 문제가 발생할 수 있다. 예를들어 곱셈 과정에서 지수끼리 더했는데 표현할 수 있는 범위를 넘어서는 경우 엉뚱한 값이 저장된다. 혹은 덧셈 과정에서 소수점 위치를 맞추기 위해 더 작은수의 가수를 쉬프트 시키는 과정에서 버려지는 수가 발생하게 될 수도 있는데, 이 때는 반올림이나 버림 과정이 진행된다. 이 때는 버려지는 비트 자릿수가 MSB에 비해 절대적 크기가 작은 경우에는 크게 문제가 되지 않으므로 지수 오버플로우보다는 그 영향력이 덜하다고 할 수 있다.</summary></entry><entry><title type="html">(컴퓨터구조) 2. CPU</title><link href="http://localhost:4000/2020/02/07/CPU/" rel="alternate" type="text/html" title="(컴퓨터구조) 2. CPU" /><published>2020-02-07T19:37:19+09:00</published><updated>2020-02-07T19:37:19+09:00</updated><id>http://localhost:4000/2020/02/07/CPU</id><content type="html" xml:base="http://localhost:4000/2020/02/07/CPU/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;CPU의 구조&lt;/li&gt;
  &lt;li&gt;명령어 실행&lt;/li&gt;
  &lt;li&gt;명령어 파이프라이닝&lt;/li&gt;
  &lt;li&gt;명령어 세트&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;0intro&quot;&gt;0.Intro&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;CPU는 프로그램 실행을 하는 가장 핵심적인 부품이다. CPU는 아래의 동작들을 차례로 수행함으로써 프로그램을 실행한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 명령어 인출(fetch)&lt;/strong&gt; : 메모리에서 명령어 가져오기&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 명령어 해독(decode)&lt;/strong&gt; : 명령어를 해석하여 연산 수행 및 결과를 저장&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 데이터 인출&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 데이터 처리&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 데이터 저장&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명령어를 실행하기 위해 필요한 데이터가 있고, 그 결과를 저장할 필요가 있다면 3,4,5가 실행된다.&lt;/p&gt;

&lt;p&gt;이러한 CPU의 동작을 세부적으로 알기위해 생겨먹은 구조를 간단히 파악할 필요가 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-cpu의-구조&quot;&gt;1. CPU의 구조&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/cpu_structure.png&quot; alt=&quot;cpu_structure&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ALU&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;각종 산술연산(4칙연산) 및 논리연산(AND, OR, NOT 등) 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;레지스터(Register)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CPU내부에 위치한 기억장치로 명령어 실행도중 발생하는 데이터들을 임시 저장&lt;/li&gt;
  &lt;li&gt;메인 메모리보다 CPU가 더 빨리 접근할 수 있음&lt;/li&gt;
  &lt;li&gt;부피가 커 많은 수를 포함시키지는 못함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;제어(Control) 유닛&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;명령어 해석&lt;/li&gt;
  &lt;li&gt;명령어 실행을 위한 신호 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-명령어-실행&quot;&gt;2. 명령어 실행&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;명령어 사이클(instruction cycle)&lt;/p&gt;

    &lt;p&gt;CPU가 한 개의 명령어를 실행하는 전체 과정으로 [인출+실행] 단계로 구성&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/instruction_cycle.png&quot; alt=&quot;instruction_cycle&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;프로그램 시작부터 종료까지 명령어 사이클이 반복적으로 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;/images/computer_architecture/2/cpu_inner_architecture.png&quot; alt=&quot;cpu_inner_architecture&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림은 명령어 사이클에 사용되는 CPU 내부 레지스터들이다. 각 레지스터의 역할은 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;프로그램 카운터(Program Counter: PC)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;다음에 인출(fetch)될 명령어가 존재하는 메모리 주소가 저장된다. 마지막 명령어 인출 후 ‘명령어 주소 크기 단위’만큼 자동으로 증가하거나 혹은 분기(if나 switch와 같은)문의 경우 목적지 주소로 업데이트된다. 이 주소는 주소버스를 통해 내보내진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;누산기(Accumulator: AC)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;연산 과정에 필요한 데이터를 일시적으로 저장한다. 따라서 비트 수는 워드 크기와 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;명령어 레지스터(Instruction Register: IR)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;가장 최근에 인출된 명령어를 저장한다. 이후에 여기에 저장된 명령어가 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;기억장치 주소 레지스터(Memory Address Register: MAR)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PC의 주소값을 주소버스에 내보기전 일시적으로 저장하는 곳이다. MAR이 주소버스와 직접 연결된다. 즉 인출할 명령어의 주소는 PC → MAR → 주소버스 → 메모리를 거친다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;기억장치 버퍼 레지스터(Memory Buffer Register: MBR)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;메모리에 저장할 데이터 혹은 메모리로부터 읽은 데이터(인출된 명령어 포함)를 임시적으로 저장하기 위한 버퍼 레지스터이다. 따라서 데이터 버스와 접속되어 있다. 예를들어 다음에 실행할 명령어를 인출한다면 메모리 → 데이터버스 → MBR → IR → 제어유닛 순으로 데이터가 이동한다.&lt;/p&gt;

&lt;p&gt;위에서 설명한 CPU의 내부구조를 기반으로 명령어 인출 및 실행 사이클에서 일어나는 동작에 대해 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-1-인출-사이클&quot;&gt;2-1. 인출 사이클&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;프로그램 카운터가 가리키는 주소를 통해 메모리에서 명령어를 인출한다. 이후 PC의 값이 다음 메모리주소값으로 증가한다(혹은 분기의 경우 목적지 주소로 갱신한다). 인출 사이클은 더 작게는 마이크로 연산(micro-operation)들로 나타낼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/micro_operation.png&quot; alt=&quot;micro_operation&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;인출 사이클은 위에서 보는바와 같이 3개의 마이크로 연산으로 이루어져있다. 각 마이크로 연산은 CPU 클럭 주기에 하나씩 실행된다. 즉, 인출사이클이 실행되기 위해서는 총 3 CPU 클럭이 필요하다.&lt;/p&gt;

&lt;p&gt;첫 번째 주기에서는 다음 인출 명령어가 존재하는 주소가 PC에서  MAR로 이동한다. 곧바로 해당 주소가 주소버스를 타고 메모리로 전달된다.&lt;/p&gt;

&lt;p&gt;두 번째 주기에서는 메모리의 해당 번지수에 있던 명령어가 데이터버스를 타고 MBR로 들어온다. 이 과정이 진행되는 동시에 PC값이 명령어 주소 크기 단위만큼 증가한다. 가령 메모리주소에 8bit가 사용되고 명령어가 16bit로 이루어져있다면 하나의 명령어는 2개의 번지수를 차지하게 된다. 따라서 PC값은 2가 증가한다.&lt;/p&gt;

&lt;p&gt;마지막 주기에서는 MBR에서 IR로 명령어가 이동한다.&lt;/p&gt;

&lt;p&gt;여기까지가 인출 사이클이다. 이후 IR에 저장된 명령어가 실행되는 단계가 실행 단계이다. 아래 그림은 인출 사이클이 실행되는 흐름도이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/fetch_cycle.png&quot; alt=&quot;fetch_cycle&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-2-실행-사이클&quot;&gt;2-2. 실행 사이클&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;IR에 저장된 명령어를 해독하고 실행한다. 실행의 종류는 크게 4가지로 분류된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;데이터 읽기&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU와 메모리, 혹은 I/O장치 사이의 데이터 교환
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;데이터 쓰기&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;연산결과 혹은 입력장치에서 읽은 데이터를 메모리나 보조기억장치에 저장
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;데이터 처리&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;산술연산과 논리연산 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;프로그램 제어&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;프로그램의 실행순서 결정
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
위에서 말한 실행 종류들별로 마이크로 연산 과정이 다르다. 명령어 종류별로 예시를 보겠다.&lt;/p&gt;

&lt;p&gt;그 전에 명령어는 연산 종류를 나타내는 연산코드와 연산에 필요한 연산과 관련된 메모리 주소를 나타내는 오퍼랜드로 구성되어있다는 것을 상기하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/instruction_format.png&quot; alt=&quot;instruction_format&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
	&lt;strong&gt;&lt;em&gt;a)데이터 읽기 예제&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;메모리의 특정 주소에서 데이터를 읽어서 AC에 저장(LOAD addr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/data_read_execution.png&quot; alt=&quot;data_read_execution&quot; width=&quot;20%&quot; height=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 읽을 메모리 주소)가 MAR로 이동한다.&lt;/p&gt;

&lt;p&gt;두 번째 주기에서 해당 주소의 데이터(M[MAR])가 데이터 버스를타고 MBR로 이동한다.&lt;/p&gt;

&lt;p&gt;세 번째 주기에서는 MBR에 임시로 저장되었던 데이터가 AC로 이동한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
	&lt;strong&gt;&lt;em&gt;b)데이터 쓰기 예제&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AC의 값을 메모리의 특정 주소에 저장(STA addr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/data_write_execution.png&quot; alt=&quot;data_write_execution&quot; width=&quot;20%&quot; height=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 저장할 메모리 주소)가 MAR로 이동한다.&lt;/p&gt;

&lt;p&gt;두 번째 주기에서 AC의 데이터가 MBR로 이동한다.&lt;/p&gt;

&lt;p&gt;세 번째 주기에서 해당 메모리 주소(M[MAR])와 MBR의 데이터가 각각 주소버스와 데이터버스를 타고 메모리로 전송된 후 데이터가 저장된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
	&lt;strong&gt;&lt;em&gt;c)데이터 처리 예제&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;메모리의 특정 주소에서 데이터를 읽어 AC값과 더해서 AC에 저장(ADD addr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/data_process_execution.png&quot; alt=&quot;data_process_execution&quot; width=&quot;20%&quot; height=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 읽을 메모리 주소)가 MAR로 이동한다.(곧바로 주소버스를 타고 메모리로 이동한다.)&lt;/p&gt;

&lt;p&gt;두 번째 주기에서 메모리로부터 값이 들어와 MBR에 저장된다.&lt;/p&gt;

&lt;p&gt;세 번째 주기에서 AC값과 MBR값이 더해져 AC에 저장된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
	&lt;strong&gt;&lt;em&gt;d)프로그램 제어 예제&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PC가 아닌 다른 주소로의 분기 명령어(JUMP addr)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/program_control_execution.png&quot; alt=&quot;program_control_execution&quot; width=&quot;20%&quot; height=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우에는 명령어 실행 마이크로 오퍼레이션이 한 주기만에 실행된다. 예를들어 if문이 만족하여 if문의 블럭을 실행하는 경우이다.&lt;/p&gt;

&lt;p&gt;명령어의 오퍼랜드(분기할 목적지 주소)를 PC로 보내버리면 된다. 그러면 다음 명령어를 메모리의 해당 주소에서 인출할 것이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-3-인터럽트-사이클&quot;&gt;2-3. 인터럽트 사이클&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1) 인터럽트란?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;인터럽트(interrupt)&lt;/strong&gt;란 현재 진행중인 명령어 실행 사이클을 즉시 중단하고 다른 동작을 처리하도록 요구하는 매커니즘이다. 순차적인 명령어에 포함되지는 않지만 CPU 외부로부터 요구가 들어오면 실행된다.&lt;/p&gt;

&lt;p&gt;인터럽트 발생시 실행해야 하는 동작을 인터럽트 서비스 루틴(ISR - Interrupt Service Routine)이라고 부른다. 인터럽트 서비스 루틴에대한 처리가 끝나면 CPU는 원래 루틴으로 복귀하여 계속 프로그램을 실행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/interrupt.png&quot; alt=&quot;interrupt&quot; width=&quot;70%&quot; height=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;사실 명령어 인출 및 실행 단계에서 설명하지 않은 추가 동작이 더 있다. 실행 사이클이 끝난 뒤 새로운 인출 사이클이 시작되기 전에 인터럽트 요구신호가 대기중인지 검사하는 것이다. 만약 인터럽트 비트가 SET 되어있다면 아래의 동작을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 인터럽트 사이클 실행 순서&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) ISR수행이 끝난 후 복귀를 위해 PC의 값을 스택(stack)에 저장&lt;/strong&gt;
&lt;strong&gt;b) ISR의 시작 주소를 PC에 로드한다. 이 주소는 인터럽트를 요구한 장치로부터 받거나 미리 계획된 인터럽트일경우 메모리에서 가져온다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;요약하자면 인터럽트 사이클은 아래의 순서대로 실행된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;[인터럽트 요구신호 검사 → (인터럽트 비트가 SET이면)현재 내용을 스택에 저장 → 인터럽트 시작주소를 PC에 로드]&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인터럽트 시작 주소를 PC에 로드하는 것 까지가 인터럽트 사이클이다. ISR의 시작주소가 PC에 적재되었기 때문에 다음 사이클에서는 ISR에 대해 명령어 인출-실행 단계를 거친다. 이를 마이크로연산으로 분리해보면 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/interrupt_micro_operation.png&quot; alt=&quot;interrupt_micro_operation&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫 번째 주기에서는 현재 PC의 내용이 시스템버스를 타고 MBR을 통해 메모리로 이동한다.&lt;/p&gt;

&lt;p&gt;두 번째 주기에서는 스택포인터(SP)가 가르키는 스택의 마지막 주소를 MAR를 통해 메모리로 내보낸다. 동시에 ISR의 시작 주소를 PC에 올린다.&lt;/p&gt;

&lt;p&gt;마지막 주기에서는 MBR에 저장되어있던 원래의 PC내용이 데이터버스를 타고 메모리로 이동하면 두 번째 주기에서 메모리가 받았던 스택의 마지막 주소에 이 내용이 저장된다.(이로써 원래의 순차적 프로그램 순서에서 다음에 인출할 명령어 주소가 스택에 저장된 것이다.) 그리고 동시에 스택포인터 SP의 값이 1 감소한다.&lt;/p&gt;

&lt;p&gt;결론적으로 PC에 있던 내용이 스택에 저장되고, PC에 ISR의 시작주소가 적재되었기 때문에 다음 사이클에는 ISR이 수행되는 것이다. 그리고 ISR이 끝나면 스택에 저장되어있던 원래 PC의 내용을 가져와 계속 수행하게된다.&lt;/p&gt;

&lt;p&gt;스택포인터인 SP는 CPU 내부에 있는 특수목적 레지스터들 중의 하나이다. SP는 항상 스택의 최상위 주소(Top Of Stack - TOS)를 가리킨다. 또한 일반적으로 스택 영역은 메모리의 끝 부분이 사용되므로 스택에 내용이 쌓일수록 SP는 1씩 감소하게 된다.&lt;/p&gt;

&lt;p&gt;아래 그림은 인터럽트가 포함된 전체 명령어 사이클을 표현한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/instruction_cycle_with_interrupt.png&quot; alt=&quot;instruction_cycle_with_interrupt&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;외부 장치의 인터럽트 요구가 있다고해서 항상 실행중인 사이클을 중단하고 ISR이 실행되는것은 아니다. CPU 설정값에서 INTERRUPT_ENABLE 비트와 같이 인터럽트 가능 여부를 설정할 수 있는 값이 SET 되어있어야한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;3) 인터럽트 도중 레지스터 내용의 변경을 방지하는 방법&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인터럽트 사이클 도중에 원래 사이클이 사용하던 값들이 저장된 레지스터의 값이 변경된다면? 예를들어 연산 중간 결과가 AC에 저장되어있었는데 ISR 수행 도중 AC값을 변경한다면 인터럽트 후 원래의 사이클로 복귀했을때 문제가 발생한다. 이를 해결하기 위해 ISR 시작 단계에서는 CPU 레지스터들의 내용을 스택에 저장하였다가 ISR 수행 후 다시 가져오는 절차가 수행된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4) 다중 인터럽트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ISR 수행도중 다른 외부장치가 또 다른 인터럽트를 요구하는 경우를 다중 인터럽트(Multiple Interrupt)라고 부른다.&lt;/p&gt;

&lt;p&gt;다중 인터럽트를 처리하는 방법에는 2가지가 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) interrupt disable 상태로 변경&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ISR 수행 도중에는 interrupt를 disable하여 다른 인터럽트가 끼어들지 못하게 한다. 현재 처리중인 ISR이 끝나고 다시 interrupt enable 상태가 되면 대기중인 인터럽트가 인식된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) 인터럽트 우선순위 설정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ISR 수행도중 우선순위가 더 높은 인터럽트 요구가 들어올 경우에는 해당 인터럽트로 새로 분기하고 우선순위가 낮은 인터럽트에 대해서는 대기를 시켜놓는 것이다. 이 내용을 그림으로 표현하면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/multiple_interrupt.png&quot; alt=&quot;multiple_interrupt&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 경우 PC와 다른 인터럽트 내용을 저장하고 ISR이 끝난 후 갱신하는 내용은 앞에서 설명한 절차와 동일하다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-4-간접-사이클&quot;&gt;2-4. 간접 사이클&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;연산이 필요한 경우(더하기, 빼기같은) 명령어의 오퍼랜드는 데이터가 있는 메모리의 주소를 나타낸다고 했었다. 그런데 데이터의 주소가 아닌 데이터의 주소를 내용으로 가지고있는 메모리의 주소 경우가 있다. 다시말하면 메모리에서 데이터가 저장된 곳의 주소를 받아와 다시 그 주소로 찾아가 데이터를 가져와야한다. 이 경우 데이터의 실제 주소를 가지고 있는 주소를 가져오는 과정을 간접 사이클이라고 하는데, 간접 사이클은 인출 사이클과 실행 사이클 사이에 위치한다. 이 사이클은 간접주소방식(이후 내용에서 설명한다)에서 사용된다.&lt;/p&gt;

&lt;p&gt;간접 사이클에서는 IR의 오퍼랜드를 MAR로 내보내고 메모리의 해당 주소에서 데이터가 저장된 곳의 주소를 가져와 MBR에 저장한다. 여기까지는 일반적인 실행 사이클과 같다. 그런데 여기사 MBR의 값을 IR의 오퍼랜드와 바꿔치기하는 과정이 한번 더 일어난다. 이제야 IR에 있는 명령어의 오퍼랜드가 데이터의 실제 주소를 가지게 되어 데이터를 가져올 수 있게된 것이다.&lt;/p&gt;

&lt;p&gt;이를 마이크로 연산으로 나타내면 아래 그림과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/indirect_cycle.png&quot; alt=&quot;indirect_cycle&quot; width=&quot;20%&quot; height=&quot;20%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-명령어-파이프라이닝&quot;&gt;3. 명령어 파이프라이닝&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;명령어 파이프라닝(instruction pipelining)은 명령어 실행에 사용되는 하드웨어를 여러 단계(stage)로 분할하고 각각이 동시에 서로 다른 명령어들을 처리하도록 하여 속도를 향상시키는 기술이다. 일반적으로 분할 단계가 많아질수록 처리 속도가 높아진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-1-2-단계-명령어-파이프라인&quot;&gt;3-1. 2-단계 명령어 파이프라인&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;인출 사이클과 실행 사이클을 처리하는 하드웨어를 독립적인 모듈로 분리하여 두 사이클을 동시에 처리하는 기술이다. 인출된 명령어가 실행되는 동시에 다음 명령어를 인출하는 것이다. 그림으로 나타내면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/2-stage-pipeline.png&quot; alt=&quot;2-stage-pipeline&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 명령이 실행되는 동안 다음 명령어를 미리 인출하는 것을 명령어 선인출(instruction prefetch)라고 부른다.&lt;/p&gt;

&lt;p&gt;각 클럭 주기마다 인출된 명령어의 실행과 다음 명령어의 인출이 동시에 일어나기때문에 2번째 명령어부터는 한 클럭 주기만에 완료되는 효과를 얻을 수 있다. 이러한 단계가 반복되면 전체 프로그램 실행 시간은 절반으로 수렴할 것이다.&lt;/p&gt;

&lt;p&gt;하지만 위 그림에서는 인출 단계과 실행 단계의 실행이 각각 한 클럭 주기에 일어난다는 것을 가정한 것이다. 실제로는 각 사이클은 여러 마이크로 연산으로 분리될 수 있고 실제로는 각각의 마이크로 연산의 실행에 한 클럭 주기가 소요된다. 또한 일반적으로 인출단계보다는 실행단계가 더 많은 마이크로 연산으로 이루어져있고 따라서 더 많은 클럭주기가 소요된다. 결과적으로 명령어 인출이 끝나더라도 다음 명령어 선인출을 위해서 현재 진행중인 실행 사이클이 종료될 때 까지 기다려야 하므로 시간 낭비가 발생한다. 이러한 이유때문에 2단계 명령어 파이프라이닝은 실제 프로그램 처리 속도를 2배까지 올리지 못한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-2-4단계-명령어-파이프라인&quot;&gt;3-2. 4단계 명령어 파이프라인&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;1) 4단계 파이프라이닝의 동작 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2단계 파이프라인의 한계를 극복하기 위해 아래 그림과 같이 처리 단계를 더 세부적인 4단계로 나누는 방법이 4단계 명령어 파이프라이닝이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a)명령어 인출(IF)
b)명령어 해독(ID)
c)오퍼랜드 인출(OF)
d)실행(EX)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;편의상 각 단계가 같은 시간을 소요한다는 가정하면(여기서는 1 클럭 주기) 아래 그림과 같은 명령어 사이클의 시간 흐름도를 생각할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/4-stage-pipeline.png&quot; alt=&quot;4-stage-pipeline&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에 따르면 1개의 명령어 사이클이 수행되는데 4 클럭주기가 소요된다.&lt;/p&gt;

&lt;p&gt;10개 명령어의 경우 : 파이프라이닝이 없다면 40클럭주기, 4단계 파이프라이닝에서 13클럭주기가 소요된다. → 약 3.08배 속도향상&lt;/p&gt;

&lt;p&gt;100개 명령어의 경우 : 파이프라이닝이 없다면 400 클럭주기, 4단계 파이프라이닝에서 103 클럭주기가 소요된다. → 약 3.89배 속도향상&lt;/p&gt;

&lt;p&gt;이런 식으로 계산했을 때 명령어가 100만개인 경우는 약 3.99999배가 향상된다. 명령어가 많아질수록 4배의 속도향상에 수렴한다.&lt;/p&gt;

&lt;p&gt;이것을 일반화 시켜서 파이프라이닝 단계 수를 k(즉, 하나의 명령어 사이클이 수행되는데 걸리는 클럭주기)로 하고 처리해야할 명령어의 수가 N개라고 했을때 총 소요되는 클럭주기는 *\k + (N-1)*이 된다.&lt;/p&gt;

&lt;p&gt;즉, 첫 번째 명령어만 k주기가 소요되고 이후부터는 1주기마다 1개씩 실행되므로 나머지 N-1개에 대해서는 1주기만 소요되는것과 같다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) 4단계 파이프라이닝의 문제점&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;앞서 설명한 4단계 파이프라이닝은 상황을 매우 단순화시킨 이상적인 경우이다. 그러나 실제 4배의 속도향상이 되지못하게 하는 여러가지 문제점들이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 불필요한 시간 소모&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;앞에서는 모든 명령어가 4개의 파이프라인을 거친다고 가정하였으나 꼭 그렇지는 않다. 오퍼런드 인출단계는 필요한 경우에는 수행되지만 항상 수행되는것은 아니다. 그러나 파이프라인 하드웨어 단순화를 위해 모든 명령어가 항상 4단계를 거치도록 해야하므로 불필요한 시간 소모가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(b) 각 단계가 항상 같은 시간을 소모하지 않는다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;파이프라인 클록은 처리시간이 가장 긴 단계를 기준으로 정해진다. 일반적으로는 EX가 가장 긴 시간을 소모한다. 그러나 IF, ID, OF 단계의 결과는 EX가 완료될때까지 기다렸다가 보내져야하므로 불필요한 시간소모가 발생한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(c) 기억장치 충돌&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;실제 메모리에는 한 번에 하나의 모듈만 접근할 수 있다. 그러나 IF와 OF 단계에서는 모두 인출을 위한 메모리 접근이 필요하다. 따라서 둘 중 하나는 나머지 하나의 처리를 기다리느라 지연될 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(d) 조건 분기 명령어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;EX단계의 처리 결과에 따라 선인출되어 처리되고있던 명령어들이 무효화되어 제거될 수가 있다. 예를들어 EX 처리 중 조건문이 만족되어 특정 명령어로의 분기해야하는 경우 앞 단계들이 이미 처리된 명령어들이 필요가 없어지게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/4_stage_pipeline_with_branch.png&quot; alt=&quot;4_stage_pipeline_with_branch&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(b)를 해결하기 위해 명령어 사이클을 더욱 세부적으로 분기하는 &lt;strong&gt;슈퍼파이프라이닝(superpipelining)&lt;/strong&gt; 기술을 사용한다. 최근에는 대부분의 프로세서들이 10단계 이상의 파이프라인 구조를 사용한다.&lt;/p&gt;

&lt;p&gt;(c)기억장치 충돌을 해결하기 위해 &lt;strong&gt;명령어 캐시&lt;/strong&gt;와 &lt;strong&gt;데이터 캐시&lt;/strong&gt;로 분리하여 IF와 OF가 동시에 처리될 수 있는 방법을 사용한다.&lt;/p&gt;

&lt;p&gt;(d)의 해결을 위해서도 여러 방법이 존재한다. 최근 분기 결과를 저장해두는 분기역사표(branch history table)을 사용하여 어떤 명령어를 선인출할지를 확률적으로 계산하는 모델인 분기 예측이 가장 널리 사용된다. 또한 추가적인 버퍼를 두어 다음 명령어와 분기 목적지의 명령어를 모두 인출하는 방법인 분기 목적지 선인출도 있다. 이외에도 루프버퍼, 지연분기라는 방법도 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-3-슈퍼스칼라&quot;&gt;3-3. 슈퍼스칼라&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;슈퍼스칼라(superscalar)는 CPU 내부에 여러개의 파이프라인 하드웨어를 포함시킨 구조이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/superscalar.png&quot; alt=&quot;superscalar&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그림에서 아래의 2-way 슈퍼스칼라 파이프라인의 명령어 실행 시간 흐름도를 보면 알 수 있듯이 단순히 파이프라인의 갯수가 높아진만큼 한 번에 2개의 명령어를 처리할 수 있도록하여 프로그램 처리 속도를 높이는 것이다.&lt;/p&gt;

&lt;p&gt;기본적으로 파이프라인 구조는 4단계 파이프라이닝이다. 여기서 파이프라인 갯수를 m(m-way 슈퍼스칼라)라고 했을 때 전체 명렁어 갯수 N에 대한 처리 시간을 계산해보자.&lt;/p&gt;

&lt;p&gt;처음 명령어는 항상 k(위 그림에서는 4) 클럭주기가 소요되고 남은 (N-m)개에 대해서는 한번에 m개씩 처리되므로 (N-m)/m 클럭주기가 소요된다. 따라서 소요되는 전체 시간은 T = k + (N-m)/m이다.&lt;/p&gt;

&lt;p&gt;명령어 수가 매우 많아질 경우 m-way 스칼라 파이프라이닝은 1-way 스칼라 파이프라이닝에 비해 처리속도가 m배 빨라질 수 있다.&lt;/p&gt;

&lt;p&gt;그러나 여기서도 이론상의 m배를 달성하지 못하는 문제점들이 존재한다. 예를들어 두 명령어 사이에 의존성(한 명령어가 다른 명령어의 결과를 데이터로 사용하는 경우같은)이 있을경우이다. 이 경우에 파이프라인의 일부 단계들이 유휴(idle) 상태가 되어 놀게된다. 따라서 이론상의 m배를 달성하지 못한다.&lt;/p&gt;

&lt;p&gt;이러한 한계에도 불구하고 여러 이점들로 최근 개발되는 대부분의 프로세서들은 슈퍼스칼라 파이프라인 구조를 사용하고 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-4-듀얼코어-및-멀티코어&quot;&gt;3-4. 듀얼코어 및 멀티코어&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;CPU 코어(core)란 프로세서 내에서 명령어 사이클에 반드시 필요한 핵심 모듈들을 의미한다. 즉, 명령어 파이프라인들로 이루어진 슈퍼스칼라 모듈, ALU, 레지스터 세트 등이 코어다.&lt;/p&gt;

&lt;p&gt;멀티코어 프로세서란 코어를 한 프로세스안에 여러개 집어넣은 프로세서이다. 멀티코어를 통해 슈퍼스칼라를 구현하면 동시에 여러개의 명령어를 처리할 수 있다.&lt;/p&gt;

&lt;p&gt;멀티코어에서는 각 CPU코어가 내부캐시와 버스 인터페이스만을 공유하며 동시에 여러 프로그램을 처리할 수 있다. 즉, 동시에 여러 명령어 사이클을 수행하는 슈퍼스칼라와 달리 동시에 여러 태스크 프로그램을 처리할 수 있으므로 독립성이 더 높다. 이를 두고 &lt;strong&gt;멀티 태스킹(multi-tasking)&lt;/strong&gt;이라고 부른다.&lt;/p&gt;

&lt;p&gt;추가적으로 하나의 코어 내에 상태 레지스터 세트를 여러개 두어 하나의 코어에서 여러 스레드를 실행시키는 것을 &lt;strong&gt;멀티 스레딩(multi-threadiing)&lt;/strong&gt; 기법이라 부르며, 이를통해 CPU의 처리 성능을 향상시킬 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-명령어-세트&quot;&gt;4. 명령어 세트&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;CPU 종류마다 다른 명령어 종류와 수를 가지고 있다. 하나의 CPU를 위해 정의되어있는 명령어들의 집합을 명령어 세트(instruction set)라 한다.&lt;/p&gt;

&lt;p&gt;명령어 세트의 설계에는 다음 사항들이 고려되어야한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) 연산 종류&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;수행할 연산의 수, 종류
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2) 데이터 유형&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;연산이 수행될 데이터 유형. 즉, 데이터 길이나 표현방식(정수, 부동소수점) 등
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3) 명령어 형식&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;명령어의 길이, 오퍼랜드의 필드 개수와 길이 등
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4) 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;오퍼랜드의 주소를 지정하는 방식
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-1-연산의-종류&quot;&gt;4-1. 연산의 종류&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;CPU가 수행할 수 있는 ‘일’을 의미한다. 아래가 가장 기본적인 것들이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 데이터 전송&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;레지스터와 메모리 사이에서 데이터를 전달하는 일
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;b) 산술 연산&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;정수와 실수같은 데이터의 사칙연산
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;b) 논리 연산&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AND, OR, NOR 등의 논리연산
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;d) 입출력&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CPU와 외부장치들 사이의 데이터 교환
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;e) 프로그램 제어&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분기나 서브루틴 호출과 같은 명령의 실행 순서를 결정하고 변경하는 연산이다. 원래 실행하던 프로그램을 메인 프로그램이라하고 그 흐름을 메인 루틴이라 한다면 서브루틴은 메인 프로그램에서 사이사이에 존재하는 보조적인 실행 흐름이다. 프로그래밍 언어상에서 main()함수의 본체(메인 루틴)가 실행되다가 함수를 만나면 함수의 몸통에 해당하는 명령어가 실행되고 이것이 기계에서의 서브루틴 호출이다.&lt;/p&gt;

&lt;p&gt;서브루틴의 실행을 위해서는 두 가지 연산이 필요한데, CALL과 RET이다.&lt;/p&gt;

&lt;p&gt;CALL 명령어가 실행되면 잠시 메인 프로그램이 중지되고 서브루틴으로 이동한다. 서브루틴의 마지막에 RET 명령어를 만나면 자신을 호출한 메인 프로그램의 위치로 복귀한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/subroutine.png&quot; alt=&quot;subroutine&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에서 메인 루틴이 실행되다가 SUB1이라는 루틴이 호출되어 해당 루틴으로 이동한다. SUB1이 실행되는 도중에 SUB2가 두 번 호출된다. 이후 RET 명령어를 만나면 자신을 호출한 상위 루틴으로 복귀한다.&lt;/p&gt;

&lt;p&gt;서브루틴이 시작되기 전 현재 위치를 메모리의 스택에 저장해두는데, 이유는 서브루틴의 실행이 종료되고 원래의 위치로 복귀하기 위함이다.&lt;/p&gt;

&lt;p&gt;서브루틴의 실행 순서를 마이크로 연산으로 나타내면 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/subroutine_micro_operation.png&quot; alt=&quot;subroutine_micro_operation&quot; width=&quot;40%&quot; height=&quot;40%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PC의 내용과 SP의 내용이 각각 MBR과 MAR을 타고 메모리로 나가서 SP가 가르키는 스택 주소에 PC의 내용이 저장된다. 이와 더불어 서브루틴 X의 주소가 PC에 업로드되고 스택포인터의 값이 1 감소한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;서브루틴이 종료될 때의 실행순서를 마이크로 연산으로 나타내면 아래와 같다.&lt;/p&gt;

&lt;p&gt;서브루틴이 종료될 때는 기존 프로그램의 실행을 위해 스택에 저장해두었던 PC의 값을 가져와야한다. SP의 값을 1 증가시켜 PC내용이 저장된곳을 가르키게 한 후 이 주소를 MAR로 내보내면 메모리의 해당 주소에서 내요을 꺼내어 PC로 전달한다. 이제 PC에서 다음 명령어의 주소를 인출하면 원래의 프로그램 명령어가 인출된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-2-명령어-형식&quot;&gt;4-2. 명령어 형식&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;명령어는 CPU가 무엇을 해야할지 충분히 알 수 있도록 필요한 모든 정보를 제공해야 한다. 명령어는 아래와 같은 필드들로 구성된다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;a) 연산코드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LOAD, ADD, CALL과 같은 연산의 종류를 지정한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b) 오퍼랜드&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;연산에 필요한 데이터 혹은 데이터의 주소이다. 각 연산은 한개 혹은 두개의 입력 오퍼랜드와 한개의 출력 오퍼랜드를 가질 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c) 다음 명령어 주소&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;분기나 서브루틴 호출과 같이 실행 순서를 변경하는 경우에 필요한 명령어의 주소이다. 순차적인 프로그램 실행시에는 필요하지 않다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;명령어 형식은 위에서 설명한 필드의 수와 배치방식, 각 필드에 할당할 비트수에 의해 결정된다.&lt;/p&gt;

&lt;p&gt;아래 그림은 워드가 2바이트(16비트)인 경우의 명령어 형식 예시이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/instruction_format_field.png&quot; alt=&quot;instruction_format_field&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드는 데이터, 메모리 주소 및 레지스터 번호를 저장하는 용도로 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;위 그림에서는 연산코드가 4bit인만큼 사용할 수 있는 연산의 종류는 2^4 = 16가지이다.&lt;/p&gt;

&lt;p&gt;예를들어 오퍼랜드1은 레지스터 번호를, 오퍼랜드2는 메모리 주소를 지정하는 용도일 수 있다. 결과적으로 레지스터 번호는 4비트를 사용하므로 16가지를, 메모리 주소는 256개(0번지~255번지)를 지정할 수 있다. 또다른 예로&lt;/p&gt;

&lt;p&gt;오퍼랜드가 1개만 필요하다면 12비트를 모두 사용할 수 있다. 이 때 오퍼랜드가 부호가 없는 정수 데이터의 저장 용도로 쓰인다면 0~4095의 범위를 표현할 수 있고 메모리 주소 저장 용도로 쓰인다면 4096개(0번지~4095번지)의 주소를 지정할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;※ 명령어 형식의 설계&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드 수를 기준으로 명령어의 종류를 아래와같이 나눌 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;a) 1-주소 명령어&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드가 1개인 명령어 형식&lt;/p&gt;

&lt;p&gt;LOAD X : AC ← M[X]&lt;/p&gt;

&lt;p&gt;위 어셈블리 코드는 메모리의 X번지에서 데이터를 가져와 AC에 적재하기위한 것이다. 이 경우 메모리의 주소만 필요하므로 1-주소 명령어 형식으로도 가능하다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;b) 2-주소 명령어&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드가 2개인 명령어 형식&lt;/p&gt;

&lt;p&gt;ADD R1,R2 : R1 ← R1 + R2&lt;/p&gt;

&lt;p&gt;위 어셈블리 코드는 2-주소 명령어형식으로 표현한 것이다. 레지스터 R1의 값과 R2의 값을 더해서 R1에 저장하라는 명령이다. 1-주소 명령어형식을 사용해서 같은 일을 하려면 여러번의 연산이 필요하고 따라서 연산코드가 한줄보다 길어지게 된다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;c) 3-주소 명령어&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드가 3개인 명령어 형식&lt;/p&gt;

&lt;p&gt;MUL X,R1,R2 : M[X] ← R1 × R2&lt;/p&gt;

&lt;p&gt;3-주소 명령어 형식을 사용하면 R1과 R2를 더해서 메모리의 X번지에 저장하는 코드를 위와같이 한 줄로 작성할 수 있다. 만약 2주소 형식을 사용한다면 아래의 과정들이 필요하다.&lt;/p&gt;

&lt;p&gt;MUL R1,R2 : R1 ← R1 × R2&lt;/p&gt;

&lt;p&gt;STOR X,R1 : M[X] ← R1&lt;/p&gt;

&lt;p&gt;코드가 두 줄로 늘어났다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;위 예시들에서 보았듯이 명령어 형식은 프로그램 작성 코드 길이에 영향을 미친다. 그러나 명령어 해독 과정이 복잡하다는 단점도 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-3-주소지정-방식&quot;&gt;4-3. 주소지정 방식&lt;/h3&gt;
&lt;hr /&gt;

&lt;p&gt;명렁어의 비트 수는 일반적으로 CPU가 한 번에 처리할 수 있는 데이터의 길이, 즉 CPU의 워드(word)와 같다. 제한된 명령어 길이에서 우리는 제한된 오퍼랜드 길이를 사용할 수 밖에없다. 이에따라 지정할 수 있는 메모리 주소의 수에는 한계가 있고 더 큰 용량의 메모리사용을 위해 여러가지 주소지정 방식이 생겨났다.&lt;/p&gt;

&lt;p&gt;주소지정 방식은 매우 다양하고 CPU에따라 다르지만 기본적인 방식들을 살펴본다.&lt;/p&gt;

&lt;p&gt;주소지정 방식에대해 보기전에 기본적인 용어를 정하면 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;EA : 유효주소(Effective Address), 데이터가 저장된 실제 주소&lt;/li&gt;
  &lt;li&gt;A : 명령어 내의 주소필드 내용(오퍼랜드가 메모리 주소인 경우)&lt;/li&gt;
  &lt;li&gt;R : 명령어 내의 레지스터 번호(오퍼랜드가 레지스터 번호인 경우)&lt;/li&gt;
  &lt;li&gt;(A) : 메모리 A번지의 내용&lt;/li&gt;
  &lt;li&gt;(R) : 레지스터 R의 내용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주소지정 방식의 목적은 명령어 실행과정에서 유효주소인 EA를 결정하는 것이다. 이 유효주소 EA가 최종적으로 데이터에 접근하기 위한 주소로 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;1) 직접 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드의 내용을 그대로 유효주소 EA로 사용한다. 즉, &lt;strong&gt;EA=A&lt;/strong&gt; 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/direct_addressing_mode.png&quot; alt=&quot;direct_addressing_mode&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;직접 주소지정 방식에서는 유효 주소 EA를 결정하기 위한 다른 절차나 계산이 없다는 장점이 있다. 그러나 연산코드를 제외한 부분의 비트수에 따라 지정할 수 있는 주소의 수가 제한된다는 단점이 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;2) 간접 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;명렁어의 오퍼랜드 필드가 가리키는 주소에 실제 데이터가 저장된 주소를 지정하는 방식이다. 즉, &lt;strong&gt;EA = (A)&lt;/strong&gt; 이다. 다시말해, 오퍼랜드의 내용이 A이고, 메모리의 A번지에 저장된 주소를 통해 실제 데이터가 있는 주소로 한번 더 찾아가는것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/indirect_addressing_mode.png&quot; alt=&quot;indirect_addressing_mode&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드의 길이로 10비트만 사용했던 경우에 2^10 = 1024개의 주소만 사용할 수 있었다면 간접 주소지정방식에서는 메모리의 단어길이만큼의 주소를 사용할 수 있다. 만약 메모리의 단어 길이가 16비트라면 2^16 = 65,536개의 주소를 지정할 수 있다.&lt;/p&gt;

&lt;p&gt;직접주소지정방식과 간접주소지정방식을 구분하기 위해 명령어에는 아래 그림과 같이 ‘간접비트’ I가 포함되어야한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/indirect_bit.png&quot; alt=&quot;indirect_bit&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를들면 I가 0이면 직접주소지정방식이고 1이면 간접주소지정 방식이라고 CPU에게 알려주는 것이다.&lt;/p&gt;

&lt;p&gt;간접주소지정방식의 단점은 두 번의 메모리 액세스가 필요하다는 것이다.&lt;/p&gt;

&lt;p&gt;또한 간접 주소지정이 여러번 중복되어 사용되는 경우도 있다. 이 경우 메모리 액세스가 여러번 필요하다는 단점이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;3) 묵시적 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;묵시적&lt;/strong&gt;
관형사·명사
직접적으로 말이나 행동으로 드러내지 않고 은연중에 뜻을 나타내 보이는. 또는 그런 것.
(네이버 국어사전 - https://ko.dict.naver.com/)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;묵시적 주소지정은 오퍼랜드가 아니더라도 이미 사용할 데이터가 있는곳의 위치를 안다는 것이다. 예를들어 ‘PUSH R1’과 같이 레지스터 R1의 내용을 스택에 저장하라는 명령어의 실행을 위해서는 스택 포인터 SP가 사용되어야한다. 이와같이 사용할 주소를 묵시적으로 알 수 있는 경우 해당 주소가 유효주소로 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;4)즉시 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;즉시 주소지정방식을 사용하는 명령어는 연산에 필요한 데이터가 오퍼랜드에 포함되어 있다. 이 경우 아무런 데이터 인출을 위한 주소가 필요하지 않다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/immediate_addressing_mode.png&quot; alt=&quot;immediate_addressing_mode&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;주의해야할 점은 데이터의 표현 범위가 오퍼랜드의 길이에 의해 제한된다는 점이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;5) 레지스터 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;레지스터 주소지정 방식에서는 오퍼랜드 필드의 내용이 레지스터 번호이다. 즉, EA = R이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/register_addressing_mode.png&quot; alt=&quot;register_addressing_mode&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드로 사용할 수 있는 비트 길이가 k라면 2^k개의 레지스터 번호를 지정할 수 있다.&lt;/p&gt;

&lt;p&gt;이 방식을 사용하면 CPU가 메모리보다 레지스터로 접근하는 시간이 훨씬 짧기 때문에 더 빨리 명령을 실행할 수 있다. 그러나 데이터 저장이 레지스터로 제한된다는 단점 또한 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;6) 레지스터 간접 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;오퍼랜드 필드가 가리키는 레지스터가 유효주소를 가지고 있다. 즉, EA = (R)이다. 레지스터에서 유효주소를 인출하고 메모리의 해당 주소로 이동하여 데이터를 인출한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/register_indirect_addressing_mode.png&quot; alt=&quot;register_indirect_addressing_mode&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;7) 변위 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;‘직접 주소지정 방식’과 ‘레지스터 간접 주소지정 방식’을 결합하여 만든 주소지정 방식이다. 여기서 오퍼랜드 필드는 2개를 사용하는데, 하나는 변위를 나타내는 주소 A이고 다른 하나는 레지스터 번호 R이다. 레지스터의 내용 (R)을 A에 더함으로써 유효주소 EA가 결정된다. 즉, EA = A + (R) 이다.&lt;/p&gt;

&lt;p&gt;변위 주소지정 방식에서 사용하는 레지스터 R의 종류에 따라 여러가지 변위 주소지정 방식들이 정의되는데, 대표적으로는 3가지가 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;a) 상대 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;레지스터로 프로그램 카운터 PC가 사용된다. 유효주소 EA = A + (PC)이다.&lt;/p&gt;

&lt;p&gt;이 방식은 주로 분기에 사용된다. PC의 내용은 다음에 인출될 명령어의 주소이다. 즉, 유효주소 EA는 다음에 실행할 명령어 주소(PC의 값)를 기준으로 A만큼 움직인 값이다. A가 음수면 이전으로, 양수면 이후로 분기한다.&lt;/p&gt;

&lt;p&gt;아래 그림은 상대 주소지정 방식이 분기에 사용된 경우이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/relative_addressing_mode.png&quot; alt=&quot;relative_addressing_mode&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;PC의 내용과 A가 더해진 결과가 PC에 다시 적재된다. 따라서 이후 명령어에서 해당 주소로 분기하게 된다.&lt;/p&gt;

&lt;p&gt;일반적인 경우 분기를 위해 전체 분기목적지 주소가 필요하지만, 상대 주소지정 방식을 사용하면 PC의 내용을 기준으로 하는 변위만 알면 되기에 더 적은수의 비트만 필요하다는 장점이 있다. 또한 분기의 경우에는 PC의 내용을 사용하므로 레지스터 번호 R을 지정해줄 필요가 없어 A필드와 R필드가 모두 주소필드로 사용될 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;b) 인덱스 주소지정 방식&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;레지스터로 인덱스 레지스터 IX가 사용된다. 유효주소 EA = A + (IX)이다.&lt;/p&gt;

&lt;p&gt;이 방식은 주로 배열에 접근하는 용도로 사용된다. 따라서 A는 보통 배열의 시작주소이다. 이렇게 되면 유효주소는 A에서 시작되는 배열의 (IX)번째 내용이 된다. 가령 (IX)가 0이라면 A에 있는 배열의 0번째 원소의 주소를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/2/index_addressing_mode.png&quot; alt=&quot;index_addressing_mode&quot; width=&quot;60%&quot; height=&quot;60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;명령어 사이클동안 인덱스 레지스터의 내용이 자동적으로 증가,감소되도록 하는 자동 인덱싱(auto-indexing) 방식을 사용하면 배열의 데이터들에 순차적으로 연속 접근할 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-4-상용-프로세서들의-명령어-형식&quot;&gt;4-4. 상용 프로세서들의 명령어 형식&lt;/h3&gt;</content><author><name>nobbaggu</name></author><category term="CPU" /><category term="구조" /><category term="기능" /><category term="명령어" /><category term="인출" /><category term="해독" /><category term="fetch" /><category term="decode" /><category term="ALU" /><category term="산술논리연산장치" /><category term="레지스터" /><summary type="html">목차 CPU의 구조 명령어 실행 명령어 파이프라이닝 명령어 세트 0.Intro CPU는 프로그램 실행을 하는 가장 핵심적인 부품이다. CPU는 아래의 동작들을 차례로 수행함으로써 프로그램을 실행한다. 1. 명령어 인출(fetch) : 메모리에서 명령어 가져오기 2. 명령어 해독(decode) : 명령어를 해석하여 연산 수행 및 결과를 저장 3. 데이터 인출 4. 데이터 처리 5. 데이터 저장 명령어를 실행하기 위해 필요한 데이터가 있고, 그 결과를 저장할 필요가 있다면 3,4,5가 실행된다. 이러한 CPU의 동작을 세부적으로 알기위해 생겨먹은 구조를 간단히 파악할 필요가 있다. 1. CPU의 구조 ALU 각종 산술연산(4칙연산) 및 논리연산(AND, OR, NOT 등) 수행 레지스터(Register) CPU내부에 위치한 기억장치로 명령어 실행도중 발생하는 데이터들을 임시 저장 메인 메모리보다 CPU가 더 빨리 접근할 수 있음 부피가 커 많은 수를 포함시키지는 못함 제어(Control) 유닛 명령어 해석 명령어 실행을 위한 신호 발생 2. 명령어 실행 명령어 사이클(instruction cycle) CPU가 한 개의 명령어를 실행하는 전체 과정으로 [인출+실행] 단계로 구성 프로그램 시작부터 종료까지 명령어 사이클이 반복적으로 실행된다. 위 그림은 명령어 사이클에 사용되는 CPU 내부 레지스터들이다. 각 레지스터의 역할은 아래와 같다. 프로그램 카운터(Program Counter: PC) 다음에 인출(fetch)될 명령어가 존재하는 메모리 주소가 저장된다. 마지막 명령어 인출 후 ‘명령어 주소 크기 단위’만큼 자동으로 증가하거나 혹은 분기(if나 switch와 같은)문의 경우 목적지 주소로 업데이트된다. 이 주소는 주소버스를 통해 내보내진다. 누산기(Accumulator: AC) 연산 과정에 필요한 데이터를 일시적으로 저장한다. 따라서 비트 수는 워드 크기와 같다. 명령어 레지스터(Instruction Register: IR) 가장 최근에 인출된 명령어를 저장한다. 이후에 여기에 저장된 명령어가 실행된다. 기억장치 주소 레지스터(Memory Address Register: MAR) PC의 주소값을 주소버스에 내보기전 일시적으로 저장하는 곳이다. MAR이 주소버스와 직접 연결된다. 즉 인출할 명령어의 주소는 PC → MAR → 주소버스 → 메모리를 거친다. 기억장치 버퍼 레지스터(Memory Buffer Register: MBR) 메모리에 저장할 데이터 혹은 메모리로부터 읽은 데이터(인출된 명령어 포함)를 임시적으로 저장하기 위한 버퍼 레지스터이다. 따라서 데이터 버스와 접속되어 있다. 예를들어 다음에 실행할 명령어를 인출한다면 메모리 → 데이터버스 → MBR → IR → 제어유닛 순으로 데이터가 이동한다. 위에서 설명한 CPU의 내부구조를 기반으로 명령어 인출 및 실행 사이클에서 일어나는 동작에 대해 살펴보자. 2-1. 인출 사이클 프로그램 카운터가 가리키는 주소를 통해 메모리에서 명령어를 인출한다. 이후 PC의 값이 다음 메모리주소값으로 증가한다(혹은 분기의 경우 목적지 주소로 갱신한다). 인출 사이클은 더 작게는 마이크로 연산(micro-operation)들로 나타낼 수 있다. 인출 사이클은 위에서 보는바와 같이 3개의 마이크로 연산으로 이루어져있다. 각 마이크로 연산은 CPU 클럭 주기에 하나씩 실행된다. 즉, 인출사이클이 실행되기 위해서는 총 3 CPU 클럭이 필요하다. 첫 번째 주기에서는 다음 인출 명령어가 존재하는 주소가 PC에서 MAR로 이동한다. 곧바로 해당 주소가 주소버스를 타고 메모리로 전달된다. 두 번째 주기에서는 메모리의 해당 번지수에 있던 명령어가 데이터버스를 타고 MBR로 들어온다. 이 과정이 진행되는 동시에 PC값이 명령어 주소 크기 단위만큼 증가한다. 가령 메모리주소에 8bit가 사용되고 명령어가 16bit로 이루어져있다면 하나의 명령어는 2개의 번지수를 차지하게 된다. 따라서 PC값은 2가 증가한다. 마지막 주기에서는 MBR에서 IR로 명령어가 이동한다. 여기까지가 인출 사이클이다. 이후 IR에 저장된 명령어가 실행되는 단계가 실행 단계이다. 아래 그림은 인출 사이클이 실행되는 흐름도이다. 2-2. 실행 사이클 IR에 저장된 명령어를 해독하고 실행한다. 실행의 종류는 크게 4가지로 분류된다. 데이터 읽기 CPU와 메모리, 혹은 I/O장치 사이의 데이터 교환 데이터 쓰기 연산결과 혹은 입력장치에서 읽은 데이터를 메모리나 보조기억장치에 저장 데이터 처리 산술연산과 논리연산 프로그램 제어 프로그램의 실행순서 결정 위에서 말한 실행 종류들별로 마이크로 연산 과정이 다르다. 명령어 종류별로 예시를 보겠다. 그 전에 명령어는 연산 종류를 나타내는 연산코드와 연산에 필요한 연산과 관련된 메모리 주소를 나타내는 오퍼랜드로 구성되어있다는 것을 상기하자. a)데이터 읽기 예제 메모리의 특정 주소에서 데이터를 읽어서 AC에 저장(LOAD addr) 첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 읽을 메모리 주소)가 MAR로 이동한다. 두 번째 주기에서 해당 주소의 데이터(M[MAR])가 데이터 버스를타고 MBR로 이동한다. 세 번째 주기에서는 MBR에 임시로 저장되었던 데이터가 AC로 이동한다. b)데이터 쓰기 예제 AC의 값을 메모리의 특정 주소에 저장(STA addr) 첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 저장할 메모리 주소)가 MAR로 이동한다. 두 번째 주기에서 AC의 데이터가 MBR로 이동한다. 세 번째 주기에서 해당 메모리 주소(M[MAR])와 MBR의 데이터가 각각 주소버스와 데이터버스를 타고 메모리로 전송된 후 데이터가 저장된다. c)데이터 처리 예제 메모리의 특정 주소에서 데이터를 읽어 AC값과 더해서 AC에 저장(ADD addr) 첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 읽을 메모리 주소)가 MAR로 이동한다.(곧바로 주소버스를 타고 메모리로 이동한다.) 두 번째 주기에서 메모리로부터 값이 들어와 MBR에 저장된다. 세 번째 주기에서 AC값과 MBR값이 더해져 AC에 저장된다. d)프로그램 제어 예제 PC가 아닌 다른 주소로의 분기 명령어(JUMP addr) 이 경우에는 명령어 실행 마이크로 오퍼레이션이 한 주기만에 실행된다. 예를들어 if문이 만족하여 if문의 블럭을 실행하는 경우이다. 명령어의 오퍼랜드(분기할 목적지 주소)를 PC로 보내버리면 된다. 그러면 다음 명령어를 메모리의 해당 주소에서 인출할 것이다. 2-3. 인터럽트 사이클 1) 인터럽트란? 인터럽트(interrupt)란 현재 진행중인 명령어 실행 사이클을 즉시 중단하고 다른 동작을 처리하도록 요구하는 매커니즘이다. 순차적인 명령어에 포함되지는 않지만 CPU 외부로부터 요구가 들어오면 실행된다. 인터럽트 발생시 실행해야 하는 동작을 인터럽트 서비스 루틴(ISR - Interrupt Service Routine)이라고 부른다. 인터럽트 서비스 루틴에대한 처리가 끝나면 CPU는 원래 루틴으로 복귀하여 계속 프로그램을 실행한다. 사실 명령어 인출 및 실행 단계에서 설명하지 않은 추가 동작이 더 있다. 실행 사이클이 끝난 뒤 새로운 인출 사이클이 시작되기 전에 인터럽트 요구신호가 대기중인지 검사하는 것이다. 만약 인터럽트 비트가 SET 되어있다면 아래의 동작을 수행한다. 2) 인터럽트 사이클 실행 순서 a) ISR수행이 끝난 후 복귀를 위해 PC의 값을 스택(stack)에 저장 b) ISR의 시작 주소를 PC에 로드한다. 이 주소는 인터럽트를 요구한 장치로부터 받거나 미리 계획된 인터럽트일경우 메모리에서 가져온다. 요약하자면 인터럽트 사이클은 아래의 순서대로 실행된다. [인터럽트 요구신호 검사 → (인터럽트 비트가 SET이면)현재 내용을 스택에 저장 → 인터럽트 시작주소를 PC에 로드] 인터럽트 시작 주소를 PC에 로드하는 것 까지가 인터럽트 사이클이다. ISR의 시작주소가 PC에 적재되었기 때문에 다음 사이클에서는 ISR에 대해 명령어 인출-실행 단계를 거친다. 이를 마이크로연산으로 분리해보면 아래 그림과 같다. 첫 번째 주기에서는 현재 PC의 내용이 시스템버스를 타고 MBR을 통해 메모리로 이동한다. 두 번째 주기에서는 스택포인터(SP)가 가르키는 스택의 마지막 주소를 MAR를 통해 메모리로 내보낸다. 동시에 ISR의 시작 주소를 PC에 올린다. 마지막 주기에서는 MBR에 저장되어있던 원래의 PC내용이 데이터버스를 타고 메모리로 이동하면 두 번째 주기에서 메모리가 받았던 스택의 마지막 주소에 이 내용이 저장된다.(이로써 원래의 순차적 프로그램 순서에서 다음에 인출할 명령어 주소가 스택에 저장된 것이다.) 그리고 동시에 스택포인터 SP의 값이 1 감소한다. 결론적으로 PC에 있던 내용이 스택에 저장되고, PC에 ISR의 시작주소가 적재되었기 때문에 다음 사이클에는 ISR이 수행되는 것이다. 그리고 ISR이 끝나면 스택에 저장되어있던 원래 PC의 내용을 가져와 계속 수행하게된다. 스택포인터인 SP는 CPU 내부에 있는 특수목적 레지스터들 중의 하나이다. SP는 항상 스택의 최상위 주소(Top Of Stack - TOS)를 가리킨다. 또한 일반적으로 스택 영역은 메모리의 끝 부분이 사용되므로 스택에 내용이 쌓일수록 SP는 1씩 감소하게 된다. 아래 그림은 인터럽트가 포함된 전체 명령어 사이클을 표현한다. 외부 장치의 인터럽트 요구가 있다고해서 항상 실행중인 사이클을 중단하고 ISR이 실행되는것은 아니다. CPU 설정값에서 INTERRUPT_ENABLE 비트와 같이 인터럽트 가능 여부를 설정할 수 있는 값이 SET 되어있어야한다. 3) 인터럽트 도중 레지스터 내용의 변경을 방지하는 방법 인터럽트 사이클 도중에 원래 사이클이 사용하던 값들이 저장된 레지스터의 값이 변경된다면? 예를들어 연산 중간 결과가 AC에 저장되어있었는데 ISR 수행 도중 AC값을 변경한다면 인터럽트 후 원래의 사이클로 복귀했을때 문제가 발생한다. 이를 해결하기 위해 ISR 시작 단계에서는 CPU 레지스터들의 내용을 스택에 저장하였다가 ISR 수행 후 다시 가져오는 절차가 수행된다. 4) 다중 인터럽트 ISR 수행도중 다른 외부장치가 또 다른 인터럽트를 요구하는 경우를 다중 인터럽트(Multiple Interrupt)라고 부른다. 다중 인터럽트를 처리하는 방법에는 2가지가 있다. a) interrupt disable 상태로 변경 ISR 수행 도중에는 interrupt를 disable하여 다른 인터럽트가 끼어들지 못하게 한다. 현재 처리중인 ISR이 끝나고 다시 interrupt enable 상태가 되면 대기중인 인터럽트가 인식된다. b) 인터럽트 우선순위 설정 ISR 수행도중 우선순위가 더 높은 인터럽트 요구가 들어올 경우에는 해당 인터럽트로 새로 분기하고 우선순위가 낮은 인터럽트에 대해서는 대기를 시켜놓는 것이다. 이 내용을 그림으로 표현하면 아래와 같다. 이 경우 PC와 다른 인터럽트 내용을 저장하고 ISR이 끝난 후 갱신하는 내용은 앞에서 설명한 절차와 동일하다. 2-4. 간접 사이클 연산이 필요한 경우(더하기, 빼기같은) 명령어의 오퍼랜드는 데이터가 있는 메모리의 주소를 나타낸다고 했었다. 그런데 데이터의 주소가 아닌 데이터의 주소를 내용으로 가지고있는 메모리의 주소 경우가 있다. 다시말하면 메모리에서 데이터가 저장된 곳의 주소를 받아와 다시 그 주소로 찾아가 데이터를 가져와야한다. 이 경우 데이터의 실제 주소를 가지고 있는 주소를 가져오는 과정을 간접 사이클이라고 하는데, 간접 사이클은 인출 사이클과 실행 사이클 사이에 위치한다. 이 사이클은 간접주소방식(이후 내용에서 설명한다)에서 사용된다. 간접 사이클에서는 IR의 오퍼랜드를 MAR로 내보내고 메모리의 해당 주소에서 데이터가 저장된 곳의 주소를 가져와 MBR에 저장한다. 여기까지는 일반적인 실행 사이클과 같다. 그런데 여기사 MBR의 값을 IR의 오퍼랜드와 바꿔치기하는 과정이 한번 더 일어난다. 이제야 IR에 있는 명령어의 오퍼랜드가 데이터의 실제 주소를 가지게 되어 데이터를 가져올 수 있게된 것이다. 이를 마이크로 연산으로 나타내면 아래 그림과 같다. 3. 명령어 파이프라이닝 명령어 파이프라닝(instruction pipelining)은 명령어 실행에 사용되는 하드웨어를 여러 단계(stage)로 분할하고 각각이 동시에 서로 다른 명령어들을 처리하도록 하여 속도를 향상시키는 기술이다. 일반적으로 분할 단계가 많아질수록 처리 속도가 높아진다. 3-1. 2-단계 명령어 파이프라인 인출 사이클과 실행 사이클을 처리하는 하드웨어를 독립적인 모듈로 분리하여 두 사이클을 동시에 처리하는 기술이다. 인출된 명령어가 실행되는 동시에 다음 명령어를 인출하는 것이다. 그림으로 나타내면 아래와 같다. 이처럼 명령이 실행되는 동안 다음 명령어를 미리 인출하는 것을 명령어 선인출(instruction prefetch)라고 부른다. 각 클럭 주기마다 인출된 명령어의 실행과 다음 명령어의 인출이 동시에 일어나기때문에 2번째 명령어부터는 한 클럭 주기만에 완료되는 효과를 얻을 수 있다. 이러한 단계가 반복되면 전체 프로그램 실행 시간은 절반으로 수렴할 것이다. 하지만 위 그림에서는 인출 단계과 실행 단계의 실행이 각각 한 클럭 주기에 일어난다는 것을 가정한 것이다. 실제로는 각 사이클은 여러 마이크로 연산으로 분리될 수 있고 실제로는 각각의 마이크로 연산의 실행에 한 클럭 주기가 소요된다. 또한 일반적으로 인출단계보다는 실행단계가 더 많은 마이크로 연산으로 이루어져있고 따라서 더 많은 클럭주기가 소요된다. 결과적으로 명령어 인출이 끝나더라도 다음 명령어 선인출을 위해서 현재 진행중인 실행 사이클이 종료될 때 까지 기다려야 하므로 시간 낭비가 발생한다. 이러한 이유때문에 2단계 명령어 파이프라이닝은 실제 프로그램 처리 속도를 2배까지 올리지 못한다. 3-2. 4단계 명령어 파이프라인 1) 4단계 파이프라이닝의 동작 방식 2단계 파이프라인의 한계를 극복하기 위해 아래 그림과 같이 처리 단계를 더 세부적인 4단계로 나누는 방법이 4단계 명령어 파이프라이닝이다. a)명령어 인출(IF) b)명령어 해독(ID) c)오퍼랜드 인출(OF) d)실행(EX) 편의상 각 단계가 같은 시간을 소요한다는 가정하면(여기서는 1 클럭 주기) 아래 그림과 같은 명령어 사이클의 시간 흐름도를 생각할 수 있다. 위 그림에 따르면 1개의 명령어 사이클이 수행되는데 4 클럭주기가 소요된다. 10개 명령어의 경우 : 파이프라이닝이 없다면 40클럭주기, 4단계 파이프라이닝에서 13클럭주기가 소요된다. → 약 3.08배 속도향상 100개 명령어의 경우 : 파이프라이닝이 없다면 400 클럭주기, 4단계 파이프라이닝에서 103 클럭주기가 소요된다. → 약 3.89배 속도향상 이런 식으로 계산했을 때 명령어가 100만개인 경우는 약 3.99999배가 향상된다. 명령어가 많아질수록 4배의 속도향상에 수렴한다. 이것을 일반화 시켜서 파이프라이닝 단계 수를 k(즉, 하나의 명령어 사이클이 수행되는데 걸리는 클럭주기)로 하고 처리해야할 명령어의 수가 N개라고 했을때 총 소요되는 클럭주기는 *\k + (N-1)*이 된다. 즉, 첫 번째 명령어만 k주기가 소요되고 이후부터는 1주기마다 1개씩 실행되므로 나머지 N-1개에 대해서는 1주기만 소요되는것과 같다. 2) 4단계 파이프라이닝의 문제점 앞서 설명한 4단계 파이프라이닝은 상황을 매우 단순화시킨 이상적인 경우이다. 그러나 실제 4배의 속도향상이 되지못하게 하는 여러가지 문제점들이 존재한다. a) 불필요한 시간 소모 앞에서는 모든 명령어가 4개의 파이프라인을 거친다고 가정하였으나 꼭 그렇지는 않다. 오퍼런드 인출단계는 필요한 경우에는 수행되지만 항상 수행되는것은 아니다. 그러나 파이프라인 하드웨어 단순화를 위해 모든 명령어가 항상 4단계를 거치도록 해야하므로 불필요한 시간 소모가 발생한다. (b) 각 단계가 항상 같은 시간을 소모하지 않는다 파이프라인 클록은 처리시간이 가장 긴 단계를 기준으로 정해진다. 일반적으로는 EX가 가장 긴 시간을 소모한다. 그러나 IF, ID, OF 단계의 결과는 EX가 완료될때까지 기다렸다가 보내져야하므로 불필요한 시간소모가 발생한다. (c) 기억장치 충돌 실제 메모리에는 한 번에 하나의 모듈만 접근할 수 있다. 그러나 IF와 OF 단계에서는 모두 인출을 위한 메모리 접근이 필요하다. 따라서 둘 중 하나는 나머지 하나의 처리를 기다리느라 지연될 수 밖에 없다. (d) 조건 분기 명령어 EX단계의 처리 결과에 따라 선인출되어 처리되고있던 명령어들이 무효화되어 제거될 수가 있다. 예를들어 EX 처리 중 조건문이 만족되어 특정 명령어로의 분기해야하는 경우 앞 단계들이 이미 처리된 명령어들이 필요가 없어지게 된다. (b)를 해결하기 위해 명령어 사이클을 더욱 세부적으로 분기하는 슈퍼파이프라이닝(superpipelining) 기술을 사용한다. 최근에는 대부분의 프로세서들이 10단계 이상의 파이프라인 구조를 사용한다. (c)기억장치 충돌을 해결하기 위해 명령어 캐시와 데이터 캐시로 분리하여 IF와 OF가 동시에 처리될 수 있는 방법을 사용한다. (d)의 해결을 위해서도 여러 방법이 존재한다. 최근 분기 결과를 저장해두는 분기역사표(branch history table)을 사용하여 어떤 명령어를 선인출할지를 확률적으로 계산하는 모델인 분기 예측이 가장 널리 사용된다. 또한 추가적인 버퍼를 두어 다음 명령어와 분기 목적지의 명령어를 모두 인출하는 방법인 분기 목적지 선인출도 있다. 이외에도 루프버퍼, 지연분기라는 방법도 존재한다. 3-3. 슈퍼스칼라 슈퍼스칼라(superscalar)는 CPU 내부에 여러개의 파이프라인 하드웨어를 포함시킨 구조이다. 그림에서 아래의 2-way 슈퍼스칼라 파이프라인의 명령어 실행 시간 흐름도를 보면 알 수 있듯이 단순히 파이프라인의 갯수가 높아진만큼 한 번에 2개의 명령어를 처리할 수 있도록하여 프로그램 처리 속도를 높이는 것이다. 기본적으로 파이프라인 구조는 4단계 파이프라이닝이다. 여기서 파이프라인 갯수를 m(m-way 슈퍼스칼라)라고 했을 때 전체 명렁어 갯수 N에 대한 처리 시간을 계산해보자. 처음 명령어는 항상 k(위 그림에서는 4) 클럭주기가 소요되고 남은 (N-m)개에 대해서는 한번에 m개씩 처리되므로 (N-m)/m 클럭주기가 소요된다. 따라서 소요되는 전체 시간은 T = k + (N-m)/m이다. 명령어 수가 매우 많아질 경우 m-way 스칼라 파이프라이닝은 1-way 스칼라 파이프라이닝에 비해 처리속도가 m배 빨라질 수 있다. 그러나 여기서도 이론상의 m배를 달성하지 못하는 문제점들이 존재한다. 예를들어 두 명령어 사이에 의존성(한 명령어가 다른 명령어의 결과를 데이터로 사용하는 경우같은)이 있을경우이다. 이 경우에 파이프라인의 일부 단계들이 유휴(idle) 상태가 되어 놀게된다. 따라서 이론상의 m배를 달성하지 못한다. 이러한 한계에도 불구하고 여러 이점들로 최근 개발되는 대부분의 프로세서들은 슈퍼스칼라 파이프라인 구조를 사용하고 있다. 3-4. 듀얼코어 및 멀티코어 CPU 코어(core)란 프로세서 내에서 명령어 사이클에 반드시 필요한 핵심 모듈들을 의미한다. 즉, 명령어 파이프라인들로 이루어진 슈퍼스칼라 모듈, ALU, 레지스터 세트 등이 코어다. 멀티코어 프로세서란 코어를 한 프로세스안에 여러개 집어넣은 프로세서이다. 멀티코어를 통해 슈퍼스칼라를 구현하면 동시에 여러개의 명령어를 처리할 수 있다. 멀티코어에서는 각 CPU코어가 내부캐시와 버스 인터페이스만을 공유하며 동시에 여러 프로그램을 처리할 수 있다. 즉, 동시에 여러 명령어 사이클을 수행하는 슈퍼스칼라와 달리 동시에 여러 태스크 프로그램을 처리할 수 있으므로 독립성이 더 높다. 이를 두고 멀티 태스킹(multi-tasking)이라고 부른다. 추가적으로 하나의 코어 내에 상태 레지스터 세트를 여러개 두어 하나의 코어에서 여러 스레드를 실행시키는 것을 멀티 스레딩(multi-threadiing) 기법이라 부르며, 이를통해 CPU의 처리 성능을 향상시킬 수도 있다. 4. 명령어 세트 CPU 종류마다 다른 명령어 종류와 수를 가지고 있다. 하나의 CPU를 위해 정의되어있는 명령어들의 집합을 명령어 세트(instruction set)라 한다. 명령어 세트의 설계에는 다음 사항들이 고려되어야한다. 1) 연산 종류 수행할 연산의 수, 종류 2) 데이터 유형 연산이 수행될 데이터 유형. 즉, 데이터 길이나 표현방식(정수, 부동소수점) 등 3) 명령어 형식 명령어의 길이, 오퍼랜드의 필드 개수와 길이 등 4) 주소지정 방식 오퍼랜드의 주소를 지정하는 방식 4-1. 연산의 종류 CPU가 수행할 수 있는 ‘일’을 의미한다. 아래가 가장 기본적인 것들이다. a) 데이터 전송 레지스터와 메모리 사이에서 데이터를 전달하는 일 b) 산술 연산 정수와 실수같은 데이터의 사칙연산 b) 논리 연산 AND, OR, NOR 등의 논리연산 d) 입출력 CPU와 외부장치들 사이의 데이터 교환 e) 프로그램 제어 분기나 서브루틴 호출과 같은 명령의 실행 순서를 결정하고 변경하는 연산이다. 원래 실행하던 프로그램을 메인 프로그램이라하고 그 흐름을 메인 루틴이라 한다면 서브루틴은 메인 프로그램에서 사이사이에 존재하는 보조적인 실행 흐름이다. 프로그래밍 언어상에서 main()함수의 본체(메인 루틴)가 실행되다가 함수를 만나면 함수의 몸통에 해당하는 명령어가 실행되고 이것이 기계에서의 서브루틴 호출이다. 서브루틴의 실행을 위해서는 두 가지 연산이 필요한데, CALL과 RET이다. CALL 명령어가 실행되면 잠시 메인 프로그램이 중지되고 서브루틴으로 이동한다. 서브루틴의 마지막에 RET 명령어를 만나면 자신을 호출한 메인 프로그램의 위치로 복귀한다. 위 그림에서 메인 루틴이 실행되다가 SUB1이라는 루틴이 호출되어 해당 루틴으로 이동한다. SUB1이 실행되는 도중에 SUB2가 두 번 호출된다. 이후 RET 명령어를 만나면 자신을 호출한 상위 루틴으로 복귀한다. 서브루틴이 시작되기 전 현재 위치를 메모리의 스택에 저장해두는데, 이유는 서브루틴의 실행이 종료되고 원래의 위치로 복귀하기 위함이다. 서브루틴의 실행 순서를 마이크로 연산으로 나타내면 아래와 같다. PC의 내용과 SP의 내용이 각각 MBR과 MAR을 타고 메모리로 나가서 SP가 가르키는 스택 주소에 PC의 내용이 저장된다. 이와 더불어 서브루틴 X의 주소가 PC에 업로드되고 스택포인터의 값이 1 감소한다. 서브루틴이 종료될 때의 실행순서를 마이크로 연산으로 나타내면 아래와 같다. 서브루틴이 종료될 때는 기존 프로그램의 실행을 위해 스택에 저장해두었던 PC의 값을 가져와야한다. SP의 값을 1 증가시켜 PC내용이 저장된곳을 가르키게 한 후 이 주소를 MAR로 내보내면 메모리의 해당 주소에서 내요을 꺼내어 PC로 전달한다. 이제 PC에서 다음 명령어의 주소를 인출하면 원래의 프로그램 명령어가 인출된다. 4-2. 명령어 형식 명령어는 CPU가 무엇을 해야할지 충분히 알 수 있도록 필요한 모든 정보를 제공해야 한다. 명령어는 아래와 같은 필드들로 구성된다. a) 연산코드 LOAD, ADD, CALL과 같은 연산의 종류를 지정한다. b) 오퍼랜드 연산에 필요한 데이터 혹은 데이터의 주소이다. 각 연산은 한개 혹은 두개의 입력 오퍼랜드와 한개의 출력 오퍼랜드를 가질 수 있다. c) 다음 명령어 주소 분기나 서브루틴 호출과 같이 실행 순서를 변경하는 경우에 필요한 명령어의 주소이다. 순차적인 프로그램 실행시에는 필요하지 않다. 명령어 형식은 위에서 설명한 필드의 수와 배치방식, 각 필드에 할당할 비트수에 의해 결정된다. 아래 그림은 워드가 2바이트(16비트)인 경우의 명령어 형식 예시이다. 오퍼랜드는 데이터, 메모리 주소 및 레지스터 번호를 저장하는 용도로 사용할 수 있다. 위 그림에서는 연산코드가 4bit인만큼 사용할 수 있는 연산의 종류는 2^4 = 16가지이다. 예를들어 오퍼랜드1은 레지스터 번호를, 오퍼랜드2는 메모리 주소를 지정하는 용도일 수 있다. 결과적으로 레지스터 번호는 4비트를 사용하므로 16가지를, 메모리 주소는 256개(0번지~255번지)를 지정할 수 있다. 또다른 예로 오퍼랜드가 1개만 필요하다면 12비트를 모두 사용할 수 있다. 이 때 오퍼랜드가 부호가 없는 정수 데이터의 저장 용도로 쓰인다면 0~4095의 범위를 표현할 수 있고 메모리 주소 저장 용도로 쓰인다면 4096개(0번지~4095번지)의 주소를 지정할 수 있다. ※ 명령어 형식의 설계 오퍼랜드 수를 기준으로 명령어의 종류를 아래와같이 나눌 수 있다. a) 1-주소 명령어 오퍼랜드가 1개인 명령어 형식 LOAD X : AC ← M[X] 위 어셈블리 코드는 메모리의 X번지에서 데이터를 가져와 AC에 적재하기위한 것이다. 이 경우 메모리의 주소만 필요하므로 1-주소 명령어 형식으로도 가능하다. b) 2-주소 명령어 오퍼랜드가 2개인 명령어 형식 ADD R1,R2 : R1 ← R1 + R2 위 어셈블리 코드는 2-주소 명령어형식으로 표현한 것이다. 레지스터 R1의 값과 R2의 값을 더해서 R1에 저장하라는 명령이다. 1-주소 명령어형식을 사용해서 같은 일을 하려면 여러번의 연산이 필요하고 따라서 연산코드가 한줄보다 길어지게 된다. c) 3-주소 명령어 오퍼랜드가 3개인 명령어 형식 MUL X,R1,R2 : M[X] ← R1 × R2 3-주소 명령어 형식을 사용하면 R1과 R2를 더해서 메모리의 X번지에 저장하는 코드를 위와같이 한 줄로 작성할 수 있다. 만약 2주소 형식을 사용한다면 아래의 과정들이 필요하다. MUL R1,R2 : R1 ← R1 × R2 STOR X,R1 : M[X] ← R1 코드가 두 줄로 늘어났다. 위 예시들에서 보았듯이 명령어 형식은 프로그램 작성 코드 길이에 영향을 미친다. 그러나 명령어 해독 과정이 복잡하다는 단점도 존재한다. 4-3. 주소지정 방식 명렁어의 비트 수는 일반적으로 CPU가 한 번에 처리할 수 있는 데이터의 길이, 즉 CPU의 워드(word)와 같다. 제한된 명령어 길이에서 우리는 제한된 오퍼랜드 길이를 사용할 수 밖에없다. 이에따라 지정할 수 있는 메모리 주소의 수에는 한계가 있고 더 큰 용량의 메모리사용을 위해 여러가지 주소지정 방식이 생겨났다. 주소지정 방식은 매우 다양하고 CPU에따라 다르지만 기본적인 방식들을 살펴본다. 주소지정 방식에대해 보기전에 기본적인 용어를 정하면 아래와 같다. EA : 유효주소(Effective Address), 데이터가 저장된 실제 주소 A : 명령어 내의 주소필드 내용(오퍼랜드가 메모리 주소인 경우) R : 명령어 내의 레지스터 번호(오퍼랜드가 레지스터 번호인 경우) (A) : 메모리 A번지의 내용 (R) : 레지스터 R의 내용 주소지정 방식의 목적은 명령어 실행과정에서 유효주소인 EA를 결정하는 것이다. 이 유효주소 EA가 최종적으로 데이터에 접근하기 위한 주소로 사용된다. 1) 직접 주소지정 방식 오퍼랜드의 내용을 그대로 유효주소 EA로 사용한다. 즉, EA=A 이다. 직접 주소지정 방식에서는 유효 주소 EA를 결정하기 위한 다른 절차나 계산이 없다는 장점이 있다. 그러나 연산코드를 제외한 부분의 비트수에 따라 지정할 수 있는 주소의 수가 제한된다는 단점이 있다. 2) 간접 주소지정 방식 명렁어의 오퍼랜드 필드가 가리키는 주소에 실제 데이터가 저장된 주소를 지정하는 방식이다. 즉, EA = (A) 이다. 다시말해, 오퍼랜드의 내용이 A이고, 메모리의 A번지에 저장된 주소를 통해 실제 데이터가 있는 주소로 한번 더 찾아가는것이다. 오퍼랜드의 길이로 10비트만 사용했던 경우에 2^10 = 1024개의 주소만 사용할 수 있었다면 간접 주소지정방식에서는 메모리의 단어길이만큼의 주소를 사용할 수 있다. 만약 메모리의 단어 길이가 16비트라면 2^16 = 65,536개의 주소를 지정할 수 있다. 직접주소지정방식과 간접주소지정방식을 구분하기 위해 명령어에는 아래 그림과 같이 ‘간접비트’ I가 포함되어야한다. 예를들면 I가 0이면 직접주소지정방식이고 1이면 간접주소지정 방식이라고 CPU에게 알려주는 것이다. 간접주소지정방식의 단점은 두 번의 메모리 액세스가 필요하다는 것이다. 또한 간접 주소지정이 여러번 중복되어 사용되는 경우도 있다. 이 경우 메모리 액세스가 여러번 필요하다는 단점이 존재한다. 3) 묵시적 주소지정 방식 묵시적 관형사·명사 직접적으로 말이나 행동으로 드러내지 않고 은연중에 뜻을 나타내 보이는. 또는 그런 것. (네이버 국어사전 - https://ko.dict.naver.com/) 묵시적 주소지정은 오퍼랜드가 아니더라도 이미 사용할 데이터가 있는곳의 위치를 안다는 것이다. 예를들어 ‘PUSH R1’과 같이 레지스터 R1의 내용을 스택에 저장하라는 명령어의 실행을 위해서는 스택 포인터 SP가 사용되어야한다. 이와같이 사용할 주소를 묵시적으로 알 수 있는 경우 해당 주소가 유효주소로 사용된다. 4)즉시 주소지정 방식 즉시 주소지정방식을 사용하는 명령어는 연산에 필요한 데이터가 오퍼랜드에 포함되어 있다. 이 경우 아무런 데이터 인출을 위한 주소가 필요하지 않다. 주의해야할 점은 데이터의 표현 범위가 오퍼랜드의 길이에 의해 제한된다는 점이다. 5) 레지스터 주소지정 방식 레지스터 주소지정 방식에서는 오퍼랜드 필드의 내용이 레지스터 번호이다. 즉, EA = R이 된다. 오퍼랜드로 사용할 수 있는 비트 길이가 k라면 2^k개의 레지스터 번호를 지정할 수 있다. 이 방식을 사용하면 CPU가 메모리보다 레지스터로 접근하는 시간이 훨씬 짧기 때문에 더 빨리 명령을 실행할 수 있다. 그러나 데이터 저장이 레지스터로 제한된다는 단점 또한 존재한다. 6) 레지스터 간접 주소지정 방식 오퍼랜드 필드가 가리키는 레지스터가 유효주소를 가지고 있다. 즉, EA = (R)이다. 레지스터에서 유효주소를 인출하고 메모리의 해당 주소로 이동하여 데이터를 인출한다. 7) 변위 주소지정 방식 ‘직접 주소지정 방식’과 ‘레지스터 간접 주소지정 방식’을 결합하여 만든 주소지정 방식이다. 여기서 오퍼랜드 필드는 2개를 사용하는데, 하나는 변위를 나타내는 주소 A이고 다른 하나는 레지스터 번호 R이다. 레지스터의 내용 (R)을 A에 더함으로써 유효주소 EA가 결정된다. 즉, EA = A + (R) 이다. 변위 주소지정 방식에서 사용하는 레지스터 R의 종류에 따라 여러가지 변위 주소지정 방식들이 정의되는데, 대표적으로는 3가지가 있다. a) 상대 주소지정 방식 레지스터로 프로그램 카운터 PC가 사용된다. 유효주소 EA = A + (PC)이다. 이 방식은 주로 분기에 사용된다. PC의 내용은 다음에 인출될 명령어의 주소이다. 즉, 유효주소 EA는 다음에 실행할 명령어 주소(PC의 값)를 기준으로 A만큼 움직인 값이다. A가 음수면 이전으로, 양수면 이후로 분기한다. 아래 그림은 상대 주소지정 방식이 분기에 사용된 경우이다. PC의 내용과 A가 더해진 결과가 PC에 다시 적재된다. 따라서 이후 명령어에서 해당 주소로 분기하게 된다. 일반적인 경우 분기를 위해 전체 분기목적지 주소가 필요하지만, 상대 주소지정 방식을 사용하면 PC의 내용을 기준으로 하는 변위만 알면 되기에 더 적은수의 비트만 필요하다는 장점이 있다. 또한 분기의 경우에는 PC의 내용을 사용하므로 레지스터 번호 R을 지정해줄 필요가 없어 A필드와 R필드가 모두 주소필드로 사용될 수 있다. b) 인덱스 주소지정 방식 레지스터로 인덱스 레지스터 IX가 사용된다. 유효주소 EA = A + (IX)이다. 이 방식은 주로 배열에 접근하는 용도로 사용된다. 따라서 A는 보통 배열의 시작주소이다. 이렇게 되면 유효주소는 A에서 시작되는 배열의 (IX)번째 내용이 된다. 가령 (IX)가 0이라면 A에 있는 배열의 0번째 원소의 주소를 나타낸다. 명령어 사이클동안 인덱스 레지스터의 내용이 자동적으로 증가,감소되도록 하는 자동 인덱싱(auto-indexing) 방식을 사용하면 배열의 데이터들에 순차적으로 연속 접근할 수도 있다. 4-4. 상용 프로세서들의 명령어 형식</summary></entry><entry><title type="html">(컴퓨터구조) 1. 컴퓨터 시스템 개요</title><link href="http://localhost:4000/2020/02/07/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EC%9A%94/" rel="alternate" type="text/html" title="(컴퓨터구조) 1. 컴퓨터 시스템 개요" /><published>2020-02-07T13:37:19+09:00</published><updated>2020-02-07T13:37:19+09:00</updated><id>http://localhost:4000/2020/02/07/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EA%B0%9C%EC%9A%94</id><content type="html" xml:base="http://localhost:4000/2020/02/07/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B0%9C%EC%9A%94/">&lt;h2 id=&quot;목차&quot;&gt;목차&lt;/h2&gt;
&lt;hr /&gt;

&lt;ol&gt;
  &lt;li&gt;컴퓨터의 기본구조&lt;/li&gt;
  &lt;li&gt;정보의 표현과 저장&lt;/li&gt;
  &lt;li&gt;시스템의 구성&lt;/li&gt;
  &lt;li&gt;컴퓨터 구조의 발전 과정&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-intro&quot;&gt;0. Intro&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/1/computer_system_architecture.png&quot; alt=&quot;computer_system_architecture&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;컴퓨터-시스템&quot;&gt;컴퓨터 시스템&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;프로그램 형태로 주어진 작업을 수행하는 주체로서 하드웨어(HW)와 소프트웨어(SW)로 구성&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;하드웨어&quot;&gt;하드웨어&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;전기적 신호들로 표현되는 정보를 전달하는 물리적 실체로 CPU, 메모리, 모니터, 네트워크 카드, 키보드 등으로 구성된다. 아래는 가장 중요한 핵심 모듈들이다.&lt;/p&gt;

    &lt;p&gt;** a) 메인보드(main board) **&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  주요 IC칩, 메모리, 입출력(I/O)장치 슬롯들이 장착되는 회로 기판
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;** b) 중앙처리장치(CPU- Central Processing Unit) **&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  명령의 실행 및 연산을 담당하는 컴퓨터의 핵심 부품으로 사람의 뇌에 해당
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;** c) 주기억 장치(Main Memory) **&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  프로그램이 구동되면서 올라가는 메모리로 프로그램이 실행되기 위해 필요한 데이터들의 임시 저장소
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;** d) 입/출력 장치(Input/Output) **&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  키보드, 마우스와 같이 정보의 입력과 출력을 담당하는 부품
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;소프트웨어&quot;&gt;소프트웨어&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;컴퓨터가 실행해야 할 &lt;strong&gt;명령어들의 집합&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;소프트웨어는 하드웨어가 제공하는 기능들을 사용하여 프로그램을 실행한다. 그러나 소프트웨어의 설계 수준에 따라 하드웨어의 사용 효율이 달라지므로 HW와 SW는 상호 보완적인 존재이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-컴퓨터의-기본-구조&quot;&gt;1. 컴퓨터의 기본 구조&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;컴퓨터는 프로그램(명령어 집합, 즉 코드)를 정해진 순서대로 처리하고 실행하는데 이 과정에서 읽기(read), 처리(process), 저장(store)가 발생하며 이 기능들은 아래 그림과 같은 구성요소에 의해 실행&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/1/program_execution.png&quot; alt=&quot;program_execution&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1) CPU&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어들을 직접 처리하는 유닛으로 컴퓨터 성능에 가장 큰 영향을 미치는 부품&lt;/li&gt;
  &lt;li&gt;한 번에 처리하는 정보량에 따라 8비트, 32비트, 64비트 컴퓨터로 분류&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2) 메모리&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU가 처리할 프로그램의 명령어(코드)와 데이터(자료)가 저장되는 장소로 여기서는 메인 메모리(주기억장치)를 지칭&lt;/li&gt;
  &lt;li&gt;고속의 읽기(Read)/쓰기(Write)&lt;/li&gt;
  &lt;li&gt;프로그램 실행 중에 관련 데이터를 임시로 사용하는 용도로서 프로그램이 종료되면 데이터가 메모리에서 내려감&lt;/li&gt;
  &lt;li&gt;보조 메모리(보조기억장치)는 하드디스크, SSD, CD-ROM과 같이 데이터를 영구적으로 저장하는 기억장치로서 메인 메모리보다 R/W 속도가 떨어지지만 가격이 저렴. 또한 메인 메모리처럼 CPU가 직접 접근하는 방식이 아닌 별도의 제어기를 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3) 입출력장치&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;키보드와 마우스와 같은 입력장치와 모니터, 프린터, 스피커 같은 출력장치로 구성&lt;/li&gt;
  &lt;li&gt;CPU와 직접 데이터를 교환하지 않고 별도의 제어기를 사용하며 따라서 주변장치라고 불림&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-정보의-표현과-저장&quot;&gt;2. 정보의 표현과 저장&lt;/h2&gt;
&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;컴퓨터를 통해 이동하는 모든 정보(프로그램 코드, 데이터)는 2진수(binary number)의 형태로 저장되며 이러한 정보저장 단위를 &lt;strong&gt;비트(bit)&lt;/strong&gt;라고 함&lt;/li&gt;
  &lt;li&gt;응용프로그램이 고급 언어(C++, Java, Python과 같은 프로그래밍 언어)로 작성된 후 컴파일러에 의해 &lt;strong&gt;기계어(2진수의 나열)&lt;/strong&gt;로 번역되고 컴퓨터가 기계어로 번역된 명령어들을 실행&lt;/li&gt;
  &lt;li&gt;기계어는 CPU에 의존적이며 이는 CPU마다 내부 회로를 구성하는 소자들의 종류나 갯수, 연결방식 등이 다르기 때문&lt;/li&gt;
  &lt;li&gt;고급언어와 기계어 사이에 어셈블리어(assembly language)를 두어 프로그래머가 작성한 코드가 CPU에 따라 다른 기계어로 번역된다. 어셈블리 언어를 기계어로 번역해주는 프로그램을 어셈블러(assembler)라고 한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/1/assembly.png&quot; alt=&quot;assembly&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;명령어-형식&quot;&gt;명령어 형식&lt;/h3&gt;

&lt;p&gt;위 그림에서 하나의 명령어는 8bit로 구성된다. 명령어는 CPU마다 다른 포맷을 가질 수 있다.&lt;/p&gt;

&lt;p&gt;명령어 형식(instuction format)은 명령어의 비트 수, 용도 및 필드 구성방식을 지정해주는 형식으로 명령어 포맷이라 보면 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/1/instruction_field.png&quot; alt=&quot;instruction_field&quot; width=&quot;30%&quot; height=&quot;30%&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) 연산코드 필드 : 연산의 종류 결정
b) 오퍼랜드 : 기억장치 주소
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 그림의 예제는 아래 내용을 표현한다.&lt;/p&gt;

&lt;p&gt;‘001’ -&amp;gt; 레지스터 A로 적재하라는 명령&lt;/p&gt;

&lt;p&gt;‘00101’ -&amp;gt; 00101은 10진수로 5이므로 기억장치의 5번지를 가르킨다.&lt;/p&gt;

&lt;p&gt;즉, 기억장치 5번지의 데이터를 레지스터 A에 적재하라는 내용이다. 위 예에서 연산코드는 3bit를 사용하므로 2^3 = 8 가지의 연산을 지정해줄 수 있으며 오퍼랜드는 5bit를 사용하므로 2^5 = 32 개의 메모리 번지를 지정할 수 있다.&lt;/p&gt;

&lt;p&gt;컴퓨터 CPU는 이러한 기계어 코드를 순차적으로 한 줄씩 처리하며, 이 처리 단위를 워드(word)라고 부른다. CPU종류에따라 word는 8bit, 32bit, 64bit 등으로 다양하다. 위 예에서는 word는 8bit, 즉 1byte이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-시스템-구성&quot;&gt;3. 시스템 구성&lt;/h2&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;시스템-버스system-bus&quot;&gt;시스템 버스(System Bus)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;시스템 버스는 CPU와 다른 모듈들 간의 정보 교환 통로이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/1/system_bus.png&quot; alt=&quot;system_bus&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;a) 주소 버스(Address Bus)
	- CPU에서 연산 중 발생하는 주소정보를 외부로 전달하기 위한 신호선들의 집합(단방향성, uni-directional)
	- 각 주소선은 하나의 주소 비트를 전달하며 주소선의 갯수를 주소 버스의 폭(width)라 부름
	- 예를 들어 주소선이 16개라면 16bit(2^16 = 65,536개)의 주소지정 가능
	- 주소선의 폭에따라 사용할 수 있는 메모리 번지의 갯수, 사용할 수 있는 기억장치의 크기가 결정됨&lt;/p&gt;

&lt;p&gt;b) 데이터 버스(Data Bus)
	- CPU와 메모리 사이의 데이터 교환(액세스, access라고도 함) 통로(양방향성, bi-directional)
	- 한 번에 교환될 수 있는 데이터의 비트 수를 데이터선의 폭이라 부름
	- 예를 들어 32bit 크기의 데이터버스는 한 번에 32bit, 즉 4byte 크기의 데이터 교환이 가능&lt;/p&gt;

&lt;p&gt;c) 제어 버스(Control Bus)
	- CPU가 시스템 모듈들의 동작을 제어하는데 필요한 신호선
	- CPU와 주변장치들의 구성요소에 따라 제어버스의 폭이 결정
	- 메모리 읽기/쓰기 혹은 모니터 출력, 키보드 입력 등의 명령/처리를 위해 사용&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ex1) 메모리 데이터 읽기&lt;/p&gt;

&lt;p&gt;데이터를 읽기 위해서는 주소 버스를 통해 불러들일 데이터가 저장된 메모리 번지 주소와 제어버스를 통해 읽기신호를 보내면 기억장치에서 데이터버스를 통해 해당 주소에 저장된 데이터를 CPU로 전송한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/1/memory_read.png&quot; alt=&quot;memory_read&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ex2) 키보드 입력 읽기&lt;/p&gt;

&lt;p&gt;키보드의 키가 눌리면 대응되는 아스키(ASCII)코드 8bit가 키보드 제어기의 데이터 레지스터(data register)에 저장되며, 동시에 상태 레지스터에 입력 준비(In_RDY) 비트가 SET 된다. CPU는 반복적으로 키보드 제어기의 상태 레지스터를 점검하는데 In_RDY 비트가 세트되어있는것을 확인하면 데이터 레지스터에 저장된 데이터를 가져간다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/1/keyboard_read.png&quot; alt=&quot;keyboard_read&quot; width=&quot;70%&quot; height=&quot;70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;CPU는 여러 주변 장치들을 구분하기 위해 각 주변장치 제어기의 상태 레지스터와 데이터 레지스터를 기억장치로 간주하고 주소를 배정하는 방식을 사용한다.&lt;/p&gt;

&lt;p&gt;정리하자면 프로그램을 실행시키면 프로그램 명령어들과 데이터들이 메인 메모리에 적재되고 CPU는 시스템 버스를 통해 명령어와 데이터들을 가져와 처리하고 실행 명령 및 결과물을 시스템 버스를 통해 메인메모리로 보내며, 이 과정에서 들어오는 입력과 출력들도 CPU와 I/O장치들 사이의 시스템버스를 통해 이동한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-컴퓨터-구조의-발전-과정&quot;&gt;4. 컴퓨터 구조의 발전 과정&lt;/h2&gt;
&lt;hr /&gt;

&lt;p&gt;초기의 기계식 컴퓨터, 진공관을 이용한 1세대 컴퓨터부터 반도체와 IC를 활용한 현재 컴퓨터 구조에 오기까지 수많은 혁신의 역사가 존재한다. 그러나 가장 중요하다고 생각되는 현대 컴퓨터가 대부분 따르는 기초 모델이 된 폰 노이만 컴퓨터 구조는 아래와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/computer_architecture/1/vonneumann_architecture.png&quot; alt=&quot;vonneumann_architecture&quot; width=&quot;50%&quot; height=&quot;50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;폰 노이만(Von Neumann) 구조의 설계 개념은 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 2진수 체계 사용
- 프로그램과 데이터를 내부에 저장
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;폰 노이만이 위 설계개념을 적용하여 만든 EDVAC은 1945년에 처음 발표하였고 이후 ISA를 개발하였는데, 이 ISA가 현대 일반목적용 컴퓨터들의 기본형이다. 위 그림이 바로 이 ISA컴퓨터의 기본 구조이다. 여기서 놀라운점은 주기억장치에서 한 번에 두 개의 명령어(워드)를 읽어와 하나는 실행하고 나머지 하나는 명령어 버퍼에 저장하였다가 다음 명렁어 실행 사이클에서 실행한다는 점이다. 명령어 인출을 위한 기억장치 액세스 시간을 단축시킨 선인출(instruction prefetch) 개념은 현대 컴퓨터들에서도 사용된다. 그리고 내부에 저장된 프로그램 명령어들은 순차적으로 실행이되는데, 실행해야 할 명령어 주소를 지정하는 PC 레지스터(Program Counter 레지스터)가 이 부분을 담당한다.&lt;/p&gt;</content><author><name>nobbaggu</name></author><category term="데이터버스" /><category term="제어버스" /><category term="주소버스" /><category term="명령어" /><category term="하드웨어" /><category term="소프트웨어" /><category term="CPU" /><category term="중앙처리장치" /><category term="메모리" /><category term="기억장치" /><category term="주기억장치" /><category term="보조기억장치" /><summary type="html">목차 컴퓨터의 기본구조 정보의 표현과 저장 시스템의 구성 컴퓨터 구조의 발전 과정 0. Intro 컴퓨터 시스템 프로그램 형태로 주어진 작업을 수행하는 주체로서 하드웨어(HW)와 소프트웨어(SW)로 구성 하드웨어 전기적 신호들로 표현되는 정보를 전달하는 물리적 실체로 CPU, 메모리, 모니터, 네트워크 카드, 키보드 등으로 구성된다. 아래는 가장 중요한 핵심 모듈들이다. ** a) 메인보드(main board) ** 주요 IC칩, 메모리, 입출력(I/O)장치 슬롯들이 장착되는 회로 기판 ** b) 중앙처리장치(CPU- Central Processing Unit) ** 명령의 실행 및 연산을 담당하는 컴퓨터의 핵심 부품으로 사람의 뇌에 해당 ** c) 주기억 장치(Main Memory) ** 프로그램이 구동되면서 올라가는 메모리로 프로그램이 실행되기 위해 필요한 데이터들의 임시 저장소 ** d) 입/출력 장치(Input/Output) ** 키보드, 마우스와 같이 정보의 입력과 출력을 담당하는 부품 소프트웨어 컴퓨터가 실행해야 할 명령어들의 집합 소프트웨어는 하드웨어가 제공하는 기능들을 사용하여 프로그램을 실행한다. 그러나 소프트웨어의 설계 수준에 따라 하드웨어의 사용 효율이 달라지므로 HW와 SW는 상호 보완적인 존재이다. 1. 컴퓨터의 기본 구조 컴퓨터는 프로그램(명령어 집합, 즉 코드)를 정해진 순서대로 처리하고 실행하는데 이 과정에서 읽기(read), 처리(process), 저장(store)가 발생하며 이 기능들은 아래 그림과 같은 구성요소에 의해 실행 1) CPU 명령어들을 직접 처리하는 유닛으로 컴퓨터 성능에 가장 큰 영향을 미치는 부품 한 번에 처리하는 정보량에 따라 8비트, 32비트, 64비트 컴퓨터로 분류 2) 메모리 CPU가 처리할 프로그램의 명령어(코드)와 데이터(자료)가 저장되는 장소로 여기서는 메인 메모리(주기억장치)를 지칭 고속의 읽기(Read)/쓰기(Write) 프로그램 실행 중에 관련 데이터를 임시로 사용하는 용도로서 프로그램이 종료되면 데이터가 메모리에서 내려감 보조 메모리(보조기억장치)는 하드디스크, SSD, CD-ROM과 같이 데이터를 영구적으로 저장하는 기억장치로서 메인 메모리보다 R/W 속도가 떨어지지만 가격이 저렴. 또한 메인 메모리처럼 CPU가 직접 접근하는 방식이 아닌 별도의 제어기를 사용 3) 입출력장치 키보드와 마우스와 같은 입력장치와 모니터, 프린터, 스피커 같은 출력장치로 구성 CPU와 직접 데이터를 교환하지 않고 별도의 제어기를 사용하며 따라서 주변장치라고 불림 2. 정보의 표현과 저장 컴퓨터를 통해 이동하는 모든 정보(프로그램 코드, 데이터)는 2진수(binary number)의 형태로 저장되며 이러한 정보저장 단위를 비트(bit)라고 함 응용프로그램이 고급 언어(C++, Java, Python과 같은 프로그래밍 언어)로 작성된 후 컴파일러에 의해 기계어(2진수의 나열)로 번역되고 컴퓨터가 기계어로 번역된 명령어들을 실행 기계어는 CPU에 의존적이며 이는 CPU마다 내부 회로를 구성하는 소자들의 종류나 갯수, 연결방식 등이 다르기 때문 고급언어와 기계어 사이에 어셈블리어(assembly language)를 두어 프로그래머가 작성한 코드가 CPU에 따라 다른 기계어로 번역된다. 어셈블리 언어를 기계어로 번역해주는 프로그램을 어셈블러(assembler)라고 한다 명령어 형식 위 그림에서 하나의 명령어는 8bit로 구성된다. 명령어는 CPU마다 다른 포맷을 가질 수 있다. 명령어 형식(instuction format)은 명령어의 비트 수, 용도 및 필드 구성방식을 지정해주는 형식으로 명령어 포맷이라 보면 된다. a) 연산코드 필드 : 연산의 종류 결정 b) 오퍼랜드 : 기억장치 주소 위 그림의 예제는 아래 내용을 표현한다. ‘001’ -&amp;gt; 레지스터 A로 적재하라는 명령 ‘00101’ -&amp;gt; 00101은 10진수로 5이므로 기억장치의 5번지를 가르킨다. 즉, 기억장치 5번지의 데이터를 레지스터 A에 적재하라는 내용이다. 위 예에서 연산코드는 3bit를 사용하므로 2^3 = 8 가지의 연산을 지정해줄 수 있으며 오퍼랜드는 5bit를 사용하므로 2^5 = 32 개의 메모리 번지를 지정할 수 있다. 컴퓨터 CPU는 이러한 기계어 코드를 순차적으로 한 줄씩 처리하며, 이 처리 단위를 워드(word)라고 부른다. CPU종류에따라 word는 8bit, 32bit, 64bit 등으로 다양하다. 위 예에서는 word는 8bit, 즉 1byte이다. 3. 시스템 구성 시스템 버스(System Bus) 시스템 버스는 CPU와 다른 모듈들 간의 정보 교환 통로이다. a) 주소 버스(Address Bus) - CPU에서 연산 중 발생하는 주소정보를 외부로 전달하기 위한 신호선들의 집합(단방향성, uni-directional) - 각 주소선은 하나의 주소 비트를 전달하며 주소선의 갯수를 주소 버스의 폭(width)라 부름 - 예를 들어 주소선이 16개라면 16bit(2^16 = 65,536개)의 주소지정 가능 - 주소선의 폭에따라 사용할 수 있는 메모리 번지의 갯수, 사용할 수 있는 기억장치의 크기가 결정됨 b) 데이터 버스(Data Bus) - CPU와 메모리 사이의 데이터 교환(액세스, access라고도 함) 통로(양방향성, bi-directional) - 한 번에 교환될 수 있는 데이터의 비트 수를 데이터선의 폭이라 부름 - 예를 들어 32bit 크기의 데이터버스는 한 번에 32bit, 즉 4byte 크기의 데이터 교환이 가능 c) 제어 버스(Control Bus) - CPU가 시스템 모듈들의 동작을 제어하는데 필요한 신호선 - CPU와 주변장치들의 구성요소에 따라 제어버스의 폭이 결정 - 메모리 읽기/쓰기 혹은 모니터 출력, 키보드 입력 등의 명령/처리를 위해 사용 ex1) 메모리 데이터 읽기 데이터를 읽기 위해서는 주소 버스를 통해 불러들일 데이터가 저장된 메모리 번지 주소와 제어버스를 통해 읽기신호를 보내면 기억장치에서 데이터버스를 통해 해당 주소에 저장된 데이터를 CPU로 전송한다. ex2) 키보드 입력 읽기 키보드의 키가 눌리면 대응되는 아스키(ASCII)코드 8bit가 키보드 제어기의 데이터 레지스터(data register)에 저장되며, 동시에 상태 레지스터에 입력 준비(In_RDY) 비트가 SET 된다. CPU는 반복적으로 키보드 제어기의 상태 레지스터를 점검하는데 In_RDY 비트가 세트되어있는것을 확인하면 데이터 레지스터에 저장된 데이터를 가져간다. CPU는 여러 주변 장치들을 구분하기 위해 각 주변장치 제어기의 상태 레지스터와 데이터 레지스터를 기억장치로 간주하고 주소를 배정하는 방식을 사용한다. 정리하자면 프로그램을 실행시키면 프로그램 명령어들과 데이터들이 메인 메모리에 적재되고 CPU는 시스템 버스를 통해 명령어와 데이터들을 가져와 처리하고 실행 명령 및 결과물을 시스템 버스를 통해 메인메모리로 보내며, 이 과정에서 들어오는 입력과 출력들도 CPU와 I/O장치들 사이의 시스템버스를 통해 이동한다. 4. 컴퓨터 구조의 발전 과정 초기의 기계식 컴퓨터, 진공관을 이용한 1세대 컴퓨터부터 반도체와 IC를 활용한 현재 컴퓨터 구조에 오기까지 수많은 혁신의 역사가 존재한다. 그러나 가장 중요하다고 생각되는 현대 컴퓨터가 대부분 따르는 기초 모델이 된 폰 노이만 컴퓨터 구조는 아래와 같다. 폰 노이만(Von Neumann) 구조의 설계 개념은 아래와 같다. - 2진수 체계 사용 - 프로그램과 데이터를 내부에 저장 폰 노이만이 위 설계개념을 적용하여 만든 EDVAC은 1945년에 처음 발표하였고 이후 ISA를 개발하였는데, 이 ISA가 현대 일반목적용 컴퓨터들의 기본형이다. 위 그림이 바로 이 ISA컴퓨터의 기본 구조이다. 여기서 놀라운점은 주기억장치에서 한 번에 두 개의 명령어(워드)를 읽어와 하나는 실행하고 나머지 하나는 명령어 버퍼에 저장하였다가 다음 명렁어 실행 사이클에서 실행한다는 점이다. 명령어 인출을 위한 기억장치 액세스 시간을 단축시킨 선인출(instruction prefetch) 개념은 현대 컴퓨터들에서도 사용된다. 그리고 내부에 저장된 프로그램 명령어들은 순차적으로 실행이되는데, 실행해야 할 명령어 주소를 지정하는 PC 레지스터(Program Counter 레지스터)가 이 부분을 담당한다.</summary></entry></feed>