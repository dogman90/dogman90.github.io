---
title: 21. 배열(1) - 배열의 구조
date: 2018-10-07T02:01:00+09:00
author: SWnomad
layout: post
categories: C
image: /images/2018/09/C-썸네일.jpg
tags:
  - array
  - C언어
  - index
  - 길이
  - 배열
  - 선언
  - 초기화
---
배열은 포인터(pointer)와 밀접한 관계를 가지고 있으며 포인터를 제대로 이해하기 위해서 꼭 충분히 이해하고 넘어가야하는 부분입니다. 사실 배열 자체가 포인터이기도 합니다. 무슨 말인지는 나중에 포인터를 공부하신 이후에 이해하실 수 있을겁니다. 배열과 포인터를 사용하여 다양한 방법으로 쉽게 데이터를 다룰 수 있습니다.

배열이란 것은 이름이 의미하듯이 어떠한 것들의 나열입니다. C언어에서는 데이터들의 나열이 되겠습니다. 예를 들어 어떤 학교 모든 학생의 이름, 성별, 전화번호를 데이터로 저장할 때에 각 학생마다 별개의 변수로 선언하려면 지루한 작업이 될겁니다. 하지만 배열을 배우고 나면 이러한 데이터를 하나로 묶어서 처리할 수 있게 되고 코드의 작성이 훨씬 간편해집니다.

&nbsp;

&nbsp;

# 1. 배열 구조

* * *

가장 기본이 되는 배열의 선언 방법부터 알려드리겠습니다.

~~~ c
#include <stdio.h>

int main(void)
{
<span style="color: #ff0000;">//방법 1 : 선언 & 초기화</span>
int arr[4] = {11,22,33,44};

printf("%d\n",arr[0]);
printf("%d\n",arr[1]);
printf("%d\n",arr[2]);
printf("%d\n",arr[3]);

return 0;
}
~~~

실행결과

11


22


33


44


계속하려면 아무 키나 누르십시오 . . . 

[4]라는 대괄호[ ]안의 숫자와, 한 번에 여러 숫자가 중괄호{ }에 쌓여서 대입이 됩니다.

<img class="aligncenter wp-image-970" src="/images/2018/09/1-8.jpg" alt="" width="448" height="121" srcset="/images/2018/09/1-8.jpg 818w, /images/2018/09/1-8-300x81.jpg 300w, /images/2018/09/1-8-768x207.jpg 768w" sizes="(max-width: 448px) 100vw, 448px" /> 

배열이 선언이 되기 위해서는 3가지의 정보가 필요합니다.

**1. 배열의 자료형 : 배열에 담길 변수들의 자료형을 결정**

**2. 배열의 길이 : 배열에 담길 데이터의 갯수**

**3. 배열의 이름 : 배열이 할당되는 메모리공간에 접근하기 위해 변수와 같이 이름 필요**

배열의 각 원소(element)에 접근하기 위한 **index값은**** 1이 아닌 0부터 시작합니다. 따라서 길이가 n인 배열은0부터 n-1의 index값까지 가지고 있습니다.** arr는 길이가 4인 배열이므로 첫 번째 원소는 arr[0]으로 접근하고,두 번째 원소는 arr[1], 이후로 arr[2], arr[3] 까지 있습니다. arr배열에 대해 정리하자면 '_int 자료형의 원소를 가지는 길이가 4인 배열 arr_' 입니다. 그림으로 표현하면 다음과 같이 됩니다.

<img class="aligncenter wp-image-971" src="/images/2018/09/2-2.jpg" alt="" width="473" height="142" srcset="/images/2018/09/2-2.jpg 900w, /images/2018/09/2-2-300x90.jpg 300w, /images/2018/09/2-2-768x230.jpg 768w" sizes="(max-width: 473px) 100vw, 473px" /> 

각 데이터는 첫 번째 원소인 11부터 차례대로 44까지 연속하여 메모리공간을 차지합니다. 각 변수들은 int형이므로 4byte = 32bit씩을 차지합니다.

메모리 공간에는 **1byte크기의 공간당 하나의 번지수가 할당**이 됩니다. 위와 같은 케이스에서는 크기가 4byte인 int형 변수를 사용하므로 11, 22, 33, 44 각 원소는 4개의 번지수에 걸쳐서 메모리에 할당되어 있을겁니다. 그리고 어떤 변수가 메모리공간의 어떤 번지수에 있는지 말을 할 때는 그 변수가 할당되어있는 메모리공간의 가장 첫 번째 번지수를 말합니다. 가령 int형 변수는 4byte를 차지하는데, 이 변수의 주소를 말할 때는 가장 첫 번째 바이트의 주소를 말합니다.

&nbsp;

&nbsp;

# 2. 배열의 여러가지 선언방법

* * *

C언어는 배열을 선언함에 있어 조금 더 유연한 방법들을 제공합니다. 위와같은 방법 말고도 배열을 선언하는 다른 방법들이 있습니다.

~~~ c
#include <stdio.h>

int main(void)
{
    <span style="color: #ff0000;">//방법 2 : 선언을 먼저 하고 이후에 초기화 (초기화 전까지는 쓰레기값이 담겨있다.)</span>
    int arr[3];
    
    printf("%d\n", arr[0]);
    printf("%d\n", arr[1]);
    printf("%d\n", arr[2]);
    
    arr[0] = 1; //index는 0부터 시작
    arr[1] = 2;
    arr[2] = 3;
    
    printf("%d\n", arr[0]);
    printf("%d\n", arr[1]);
    printf("%d\n", arr[2]);
    
    return 0;
}
~~~

&nbsp;

실행결과

-858993460


-858993460


-858993460


1


2


3


계속하려면 아무 키나 누르십시오 . . . 

위와 같이 일단 배열을 선언만 해주는 방법도 있습니다. 단, 이 때 초기화를 시키지 않았기 때문에 각 배열의 원소에는 임의의 쓰레기값이 저장됩니다. 이후 배열의 각 원소마다 초기화를 시켜줄 수 있습니다. 이처럼 우리는 **배열의 각 원소를 하나의 변수처럼 취급할 수 있게 됩니다.**

~~~ c
#include <stdio.h>

int main(void)
{
    <span style="color: #ff0000;">//방법 3 : 길이정보 주지않고 나열하면 길이정보 자동 생성</span>
    int arr[] = {1,2,3,4,5,6,7,8};
    printf("The length of arr : %d\n", sizeof(arr)/sizeof(int)); //sizeof 연산자는 변수나 배열의 byte크기를 return
    
    return 0;
}
~~~

&nbsp;

실행결과

The length of arr : 8


계속하려면 아무 키나 누르십시오 . . . 

길이정보를 주지 않고 초기화를 하면서 배열을 선언하면 우리가 { }안에 담은 데이터의 갯수만큼 길이가 결정이 됩니다.

**sizeof 연산자는 변수나 배열의 byte 크기를 알려주는 연산자 입니다.** sizeof(arr)/sizeof(int)의 계산결과를 이용해 arr의 길이(데이터의 갯수)를 구했습니다. sizeof(arr)는 배열 arr의 총 byte크기이고 sizeof(int)는 배열 arr의 각 원소의 byte 크기입니다. 따라서 위의 계산결과는 배열 arr의 길이, 즉 데이터의 갯수를 반환합니다.

~~~ c
#include <stdio.h>

int main(void)
{
    <span style="color: #ff0000;">//방법 4 : 길이보다 작은 갯수만 초기화시키면 나머지 값에는 0이 저장</span>
    int arr[10] = {1,2,3};
    int i;
    
    for(i = 0; i < (sizeof(arr)/sizeof(int)); i++)
    {
        printf("arr[%d] = %d\n", i, arr[i]);
    }
    
    return 0;
}
~~~

실행결과

arr[0] = 1


arr[1] = 2


arr[2] = 3


arr[3] = 0


arr[4] = 0


arr[5] = 0


arr[6] = 0


arr[7] = 0


arr[8] = 0


arr[9] = 0


계속하려면 아무 키나 누르십시오 . . .

위에서 길이는 10인 배열을 선언하면서 { }안에 초기화 데이터는 3개밖에 넣어주지 않았습니다. 그러자 앞의 원소부터 차례대로 1, 2, 3이 담기고 나머지 원소의 값은 모두 0이 되었습니다. **배열의 길이보다 초기화 데이터의 갯수를 작게 넣어주면 앞에서부터 차례대로 초기화 시키고 나머지 원소들의 값은 자동으로 0으로 초기화 됩니다.**

가장 편한 선언 방법이나 상황에 따라서 유연하게 사용하시면 됩니다.

그리고 한 가지 주의할게 있습니다. 가령 우리는 길이가 5인 배열을 선언해놓았다고 새봅시다. 그리고 난 후 배열의 각 index마다 초기화를 시켜주는데 배열의 길이를 초과해서 초기화를 시켜주었다고 생각해봅시다. 다음의 코드처럼요.

~~~ c
#include <stdio.h>

int main(void)
{
    int i;
    int arr[5];
    
    arr[0]=0;
    arr[1]=1;
    arr[2]=2;
    arr[3]=3;
    arr[4]=4;
    arr[5]=5;
    arr[6]=6;
    arr[7]=7;
    arr[8]=8;
    arr[9]=9;
    
    for(i = 0; i<10; i++)
    {
        printf("arr[%d] = %d\n",i, arr[i]);
    }
    
    return 0;
}
~~~

&nbsp;

실행결과

arr[0] = 0


arr[1] = 1


arr[2] = 2


arr[3] = 3


arr[4] = 4


arr[5] = 5


arr[6] = 6


arr[7] = 7


arr[8] = 8


arr[9] = 9


계속하려면 아무 키나 누르십시오 . . .

배열의 길이를 초과한 index를 사용하여 배열에 접근을 시도했습니다. 컴파일러가 이러한 오류를 잡아줄 것이라 예상할 수도 있습니다. 하지만 **기본적으로 컴파일러는 배열에 관해서는 유효성검사를 진행하지 않습니다.** 따라서 이러한 오류를 잡아내지 못합니다. 프로그램이 arr[5]~arr[9]의 번지수에 해당하는 메모리공간을 딱히 활용하지 않는다면 큰 문제가 되지 않습니다. 하지만 최대한 이러한 실수는 피해야 할 것입니다.