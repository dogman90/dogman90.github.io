---
title: (C언어) 8.자료형(3) - 형 변환
date: 2018-10-01T01:30:12+09:00
author: SWnomad
layout: post
categories: C
image: /images/2018/09/C-썸네일.jpg
tags:
  - C언어
  - type casting
  - 강제 형변환
  - 자료형
  - 형 변환
  - 형변환
---
# 1. 자동 형변환

* * *

다음과 같이 변수를 선언합니다.

float num = 10; //int형 리터럴상수를 float형 변수에 저장

10은 정수형 리터럴상수이기때문에 float형 변수에 저장되려면 먼저 실수 10.0으로 바뀝니다. 이게 형 변환입니다. <span style="text-decoration: underline;"><b>형 변환은 대입연산자(=)의 왼쪽에 있는 자료형을 기준으로 일어납니다.</b></span> 대입연산자(=)의 오른쪽에 있는 숫자의 자료형이 왼쪽에 있는 변수의 자료형으로 자동으로 바뀝니다. 지금의 경우 자동으로 자료형이 바뀐다하여 자동 형변환이라고 합니다.

하지만 형 변환에 관해서 주의해야할 점이 있습니다.

~~~ c
#include <stdio.h>

int main(void)
{
    char charnum = 200;
    int intnum = 1.413;
    printf("charnum is %d\n", charnum);
    printf("intnum is %d\n", intnum);

   return 0;
}
~~~

&nbsp;

실행결과를 봅시다.

charnum is -56


intnum is 1


계속하려면 아무 키나 누르십시오 . . . 

왜 이런 어처구니 없는 결과가 나왔을까요?

먼저 charnum의 출력이 200이 아닌 -56이 나온 이유부터 살펴봅시다.

일단 200은 정수형 리터럴상수이기때문에 기본적으로 int형으로 저장이되어요. int형 정수는 4byte의 메모리를 차지합니다. 다음과 같이요.

00000000 00000000 00000000 11001000 ← 10진수 200의 2진수 표현

자, 그럼 이 200이라는 정수형 리터럴상수가 char형으로 형변환되면서 어떻게 바뀔까요? 더 작은 크기의 자료형으로 형변환이 될 때는 상위 비트들을 날리고 하위 비트들을 남겨놓습니다. 그럼 char는 1byte 크기의 자료형이므로 11001000만 남게되겠죠. 그런데 가장 최상위비트 0은 양의 정수, 1은 음의 정수를 표현할 때 씁니다. 그렇다면 11001000 = -128 + 64 + 8 = -56이 됩니다.

<span style="text-decoration: underline;"><b>더 작은 크기의 자료형으로 형 변환을 할 때는 데이터 자체가 변해버릴 가능성이 있다</b></span>는 것입니다. 따라서 막무가내로 자료형을 정하기보다는 최소한 저장하려는 수를 표현할 수 있는 자료형으로 선언해 주어야합니다.

두 번째로, intnum의 값이 1이 나온 이유는 간단합니다. <span style="text-decoration: underline;"><b>실수 자료형을 정수 자료형으로 형변환 할 때에는 소수점 이하 부분을 날려버린다</b></span>는 간단한 규칙입니다.

그리고 형 변환이 일어나는 또다른 경우가 있습니다. 다음의 코드를 보세요.

~~~ c
short num1 = 10;

int num2 = 20;

int num3 = num1 + num2;
~~~
위의 코드에서 우리는 short형 정수와 int형 정수를 연산하고 있습니다. 이럴 때에는 short 자료형이 int 자료형으로 형 변환되어서 int 자료형끼리 더하여 num3에 담기게 됩니다.

하나 더 봅시다.
~~~ c
short num1 = 10;

int num2 = 20;

short num3 = num1 + num2;
~~~
이런 경우에는 어떻게 될까요? short 자료형 num1이 int 자료형으로 변환되어 num2와의 연산이 일어나고 int형 정수가 나온다는것까지는 확실합니다. 이후에 대입연산자 =의 왼쪽을 기준으로 int형인 연산의 결과값이 short형으로 변환되어 num3에 저장이 됩니다.

이 두 가지 코드에서 공통적으로 말하고자 하는것은 <span style="text-decoration: underline;"><b>연산과정에서 자료형의 불일치는 더 큰 범위를 가지는 자료형으로의 형변환을 일으킨다</b></span>는 사실입니다.


 2. 강제  형변환

* * *

강제로 자료형을 변환시킬 수도 있습니다.

~~~ c
#include <stdio.h>

int main(void)
{
    double result = 1/2;
    printf("The result is %f\n", result);
    
    return 0;
}
~~~

&nbsp;

참고로 %f는 실수의 출력을 담당하는 서식문자입니다.

위 코드의 실행결과는 다음과 같습니다.

The result is 0.000000


계속하려면 아무 키나 누르십시오 . . .

1과 2는 각각 정수형 리터럴상수이므로 int형일것입니다. int형끼리 피연산이 일어날 때에는 서로 자료형이 같기때문에 형 변환은 일어나지 않아요. 그리고 그 결과값 역시 같은 int형이라는 겁니다. 따라서 소수점 이하를 날려버리고 0이 되는겁니다. 이후 double형 변수 result에  저장되면서 0.000000이 되는 것입니다.

먼저 1을 1.0으로 바꾼다고 가정해봅시다. 1.0은 실수형 리터럴상수이므로 double형이겠죠? 그럼 2는 연산과정에서 자동으로 double로의 형 변환이 일어나고 그 결과값 역시 같은 double이 될 것이기때문에 0.5의 결과가 나옵니다.

하지만 이미 정수로 선언이 된 변수들을 가져다가 연산을 할 경우에는 저렇게 마음대로 바꿀 수 없습니다. 그럴 때 쓰는 방법이 바로 강제형변환입니다. 강제 형변환은 다음과 같이 합니다.


~~~ c
#include <stdio.h>

int main(void)
{
    int num1 = 1;
    int num2 = 2;
    double result = (double)num1/num2; // 혹은 double result = num1/(double)num2;
    
    return 0;
}
~~~

&nbsp;

간단히 형 변환을 하려는 대상앞에 '변환시키고자 하는 자료형'을 쓰면 됩니다. 그럼 위의 코드의 실행순서는 먼저 num1이 double형인 1.0으로 바뀌고 연산이 진행되면서 num2도 자동형변환에 의해 2.0으로 바뀌어 연산이 되고 결과값이 double형이 되는것입니다.

여기서 한 가지 생각해볼만 재미있는 질문이 있습니다.

double result = (double)(num1/num2); 를 실행하면 어떤 결과가 나올까요? 여러분이 직접 이 코드를 넣어서 한번 실행해 보시고 결과에 대해 생각해보시기 바랍니다.

결과는 0.0000이 나옵니다. 천천히 실행순서를 하나하나 살펴보세요. 먼저 num1/num2를 실행할 때에는 int형 끼리의 연산이므로 결과 역시 int형으로 저장될 수 밖에 없기 때문에 0이 나와버립니다. 0을 double로 형변환 해봐야 0.0000일 뿐입니다. 이것을 물은 이유는 처음에는 헷갈릴 수 있지만, 결국 연산의 순서를 생각하며 차례차례 짚어보면 쉽게 결과를 예측할 수 있다는것을 말씀드리기 위해서입니다.

<table style="height: 115px; width: 50.64%; border-collapse: collapse; background-color: #ebebeb;" border="1">
  <tr>
    <td style="width: 100%;">
      1. 형 변환은 대입연산자(=)의 왼쪽에 있는 자료형을 기준으로 일어난다.

 2. 더 작은 크기의 자료형으로 형 변환 시킬때에는 데이터 손실에 대한 주의가 필요하다.

 3. 연산과정에서 자료형의 불일치는 더 큰 범위를 가지는 자료형으로의 형변환을 일으킨다.

 (char → short → int → long → long long → float → double)

 4. 우리가 원하는 결과값을 얻기위해 강제 형변환을 할 수 있다.
    </td>
  </tr>
</table>