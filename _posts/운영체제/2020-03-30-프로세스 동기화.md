---
title: (운영체제) 5. 프로세스 동기화
date: 2020-03-30T16:37:19+09:00
author: nobbaggu
layout: post
categories: 운영체제(OS)
tags:
  - 운영체제
  - os
  - 프로세스
  - 스레드
  - CPU
  - 동기화
---

## 목차 ##
---

- [1. 프로세스 간 통신](#1)
- [2. 공유 자원과 임계구역](#2)
- [3. 임계구역 해결 방법](#3)
- [4. 파일, 파이프, 소켓 프로그래밍](#4)

<br>
<a name="1"/>
## 1. 프로세스 간 통신 ##
----

**(1) 프로세스 간 통신의 개념**

+ 프로세스 간 통신(Inter Process Communication - IPC)
	+ 같은 컴퓨터에 있는 다른 프로세스와의 통신
	+ 네트워크로 연결된 다른 컴퓨터 프로세스와의 통신
	
+ 프로세스 내부 통신
	+ 프로세스 내 스레드끼리의 통신
	+ 전역변수, 파일을 이용하여 데이터 교환
	
+ 프로세스 간 데이터 통신
	+ 같은 컴퓨터의 프로세스 간 통신
	+ 공용파일, 운영체제가 제공하는 파이프를 통해 데이터 교환

+ 네트워크 데이터 통신
	+ 원격 컴퓨터 프로세스 간 통신
	+ 소켓을 통해 데이터 교환
	+ ex) RPC(원격 프로시저 호출)
	
<br>
**(2) 프로세스 간 통신의 분류**

+ 방향에 따른 분류
	+ 양방향 통신 : 동시에 양쪽 방향으로 전송 가능. 일반적인 통신 방법이다. ex) 소켓
	+ 반양방향 통신 : 양쪽 방향으로 전송할 수 있지만 동시 전송은 불가능. ex) 무전기
	+ 단방향 통신 : 한쪽 방향으로만 전송 가능. 프로세스간 통신에서 전역변수와 파이프가 여기에 해당한다.
	+ ex) 1개의 전역변수에 두 프로세스가 데이터를 동시에, 혹은 차례로 전송하면 하나는 지워지기때문에 이는 단방향 통신에 해당한다.
	
+ 통신 구현에 따른 분류
	+ 동기화 통신
		+ 데이터가 도착했음을 알려주는 기능이 있는 통신
		+ 
		+ ex) 파이프, 소켓
	+ 비동기 통신
		+ 반복루프 등을 통해 데이터가 도착했는지를 주기적으로 확인하는 바쁜 대기(busy wait) 방식을 사용하는 통신
		+ ex) 전역변수, 파일
		
<br>
**(3) 프로세스 간 통신의 종류**

+ 전역변수
	+ 데이터를 보내는 쪽에서 전역변수에 값을 write
	+ 데이터를 받는 쪽에서 전역변수의 값을 read
	+ 부모 프로세스가 전역변수 선언 후 자식 프로세스를 만들면 통신을 할 수 있다.
	+ 쓰기 프로세스가 데이터를 언제 쓸지 알 수 없어 반복루프를 통해 계속 확인해야 한다.(바쁜 대기)
	
+ 파일
	+ open : 파일 기술자(file descriptor) 획득(파일 열기)
	+ read/write : 파일 기술자를 통해 파일 입출력
	+ close : 파일 기술자 반납(파일 닫기)
	+ 이 방식은 부모-자식 관계의 프로세스들 사이에 많이 사용된다.
	+ 부모 프로세스가 wait()함수를 사용하여 자식 프로세스를 기다려주는 자체 동기화 방식 사용
	
+ 파이프
	+ 운영체제가 제공하는 동기화 통신 방식
	+ 파일과 비슷하게 open() 함수로 기술자 획득
	+ close() 함수로 마무리
	+ 이름 없는 파이프
		+ 일반적인 파이프
		+ 부모-자식, 형제 프로세스와 같이 관련 있는 프로세스 간 통신에 사용
	+ 이름 있는 파이프
		+ FIFO라 불리는 특수 파일을 사용
		+ 관련 없는 프로세스 간 통신에 사용

+ 소켓
	+ 주로 원격에 있는 프로세스와의 통신에 사용
	+ 자신의 소켓과 상대 프로세스의 소켓을 바인딩(binding)
	+ 프로세스가 자신의 소켓에 데이터를 쓰면 바인딩 된 프로세스가 소켓을 통해 읽을 수 있다.
	+ 운영체제 동기화 지원

<br>
<a name="2"/>
## 2. 공유 자원과 임계구역 ##
----

**(1) 공유 자원 접근**

+ 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황
	+ 경쟁 조건이라고 한다.
	+ 공유자원 접근 순서에 따라 실행 결과가 달라질 수 있다.	
![race_condition](/images/operating_systems/5/race_condition.png){: width="50%" height="50%"}
	+ 두 번째 프로세스가 실행한 결과를 첫 번째 프로세스가 다시 덮어쓴다.
	
<br>
**(2) 임계구역**

+ 임계구역(critical section)
	+ 공유자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역
	+ 임계 구역에서는 프로세스들이 동시에 작업하면 안된다.
	+ 한 프로세스가 임계구역에서 작업 중일때는 다른 프로세스는 기다려야한다.
	
<br>
**(3) 생산자-소비자 문제**

+ 생산자 프로세스, 소비자 프로세스는 독립적으로 작업
	+ 생산자 프로세스는 데이터를 버퍼에 쓰기
	+ 소비자 프로세스는 버퍼에서 데이터를 읽기
	+ 전역변수 sum은 버퍼에 있는 데이터의 갯수
	
![producer_consumer_problem](/images/operating_systems/5/producer_consumer_problem.png){: width="50%" height="50%"}

+ 현재 sum이 3인 상태에서 생산자가 1개를 추가, 소비자가 1개를 빼가려 하는 상황을 가정해보자.
	+ 현재 sum=3 → 생산자 sum=4 계산 → 소비자 sum=2 계산 → 소비자 sum=2 저장 → 생산자 sum=4 저장
	+ 위와 같은 순서로 일어나면 실제 데이터는 3개인데 sum이 4가 된다.
	
+ 하드웨어 자원들은 임계 구역이다.

<br>
**(4) 임계구역 해결 조건**

+ 상호 배제(mutual exclusion)
	+ 한 프로세스가 임계구역 내에 있을때 다른 프로세스는 임계구역에 들어갈 수 없다.

+ 한정 대기(bounded waiting)
	+ 임계구역을 진입하려는 프로세스가 무한대기하지 않아야한다.
	
+ 진행의 융통성(progress flexibility)
	+ 한 프로세스가 다른 프로세스의 진행을 방해하면 안된다.
	+ 임계구역이 비어있으면 어떤 프로세스는 항상 임계구역에 진입할 수 있다.
	
<br>
<a name="3"/>
## 3. 임계구역 해결 방법 ##
----

임계구역 문제를 해결하는 단순한 방법은 잠금(lock)이다. 하나의 프로세스가 임계구역에 진입해있는 동안 빠져나오기 전까지 lock을 걸어 다른 프로세스의 진입을 막는 것이다.

**(1) 기본 코드 소개**

+ 임계구역 코드 진입 전 lock인지 확인 후 lock이면 대기

+ 임계구역에 진입할 대는 lock을 걸고 임계구역에서 빠져나올때는 lock을 해제한다.
~~~ java
...
while(lock == true); //lock이면 대기
lock = true; // 락
//임계구역
lock = false; // 락 해제
...
~~~

<br>
**(2) 임계구역 해결 조건을 고려한 코드 설계**

+ 상호 배제 문제

~~~ java
while(lock == true);
//여기서 프로세스1 타임아웃 -> 프로세스2가 lock == false 확인 후 임계구역 진입 -> 프로세스 2 타임아웃 -> 프로세스 1 임계구역 진입
lock = true;
//임계구역
lock = false;
~~~
위 코드는 상호 배제를 충족하지 않는다. 두 프로세스가 동시에 임계구역에 진입할 가능성이 존재한다.

<br>
+ 한정 대기 문제

프로세스1 코드
~~~ java
lock1 = true;
while(lock2 == true);
//임계구역
lock1 = false;
~~~

<br>
프로세스2 코드
~~~ java
lock2 = true;
while(lock1 == false);
//임계구역
lock2 = false;
~~~

위 코드는 잠금을 하고 다른 프로세스의 진입을 확인하므로 상호 배제가 보장된다.

만약 프로세스1이 `lock1 = true;`를 실행하고 타임아웃 된 다음 문맥교환 후 프로세스2가 `lock2 = true;`를 실행하고 타임아웃 된다면? 이후로는 두 프로세스 모두 while문을 벗어나지 못한다. 따라서 위 코드는 한정대기 문제를 충족하지 못한다. 이러한 상황을 **교착상태(deadlock)**라고 한다. 즉, 프로세스가 살아있으나 진행되지 못함을 의미한다.

<br>
+ 진행의 융통성 문제

프로세스1 코드
~~~ java
while(lock == 2);
//임계구역
lock = 2;
~~~

<br>
프로세스2 코드
~~~ java
while(lock == 1);
//임계구역
lock = 1;
~~~

한 프로세스가 사용후에는 항상 lock을 다른 프로세스의 숫자로 바꾸어놓는다. 따라서 다른 하나의 프로세스가 임계구역 진입 후 lock 값을 바꾸기 전까지는 임계구역에 진입할 수 없다. 항상 번갈아가며 실행될 수밖에 없다. 이러면 임계구역이 사용중이지 않더라도 다른 프로세스가 사용할 때까지 기다려야한다. 따라서 진행의 융통성 문제를 보장하지 못한다.

<br>
**(3) 피터슨 알고리즘**

프로세스1
~~~ java
lock1 = true;
turn = 2;
while(lock2 == true && turn == 2);
//임계구역
lock1 = false;
~~~

<br>
프로세스2
~~~ java
lock2 = true;
turn = 1;
while(lock1 == true && turn == 1);
//임계구역
lock2 = false;
~~~

두 프로세스 모두 락을 걸었더라도 turn 변수로 다른 프로세스에 차례를 양보하게 된다. turn 변수는 1 혹은 2중 하나만 가질 수 있으므로 두 프로세스 중 1개는 항상 임계구역에 진입할 수 있어 한정 대기 문제를 해결한다.

+ 피터슨 알고리즘은 임계구역 조건 3가지를 모두 충족한다.
	+ 프로세스가 추가되면 공유변수를 추가하고 코드를 변경해야한다.
	+ 구조가 복잡하여 현재 잘 사용하지 않는다.
	+ 반복루프로 바쁜대기를 사용하여 자원을 낭비한다.
	
<br>
**(4) 데커 알고리즘**

+ 데커 알고리즘은 임계구역 조건 3가지를 모두 만족한다.
	+ 프로세스가 추가되면 공유변수를 추가하고 코드를 변경해야한다.
	+ 구조가 복잡하여 현재 잘 사용하지 않는다.
	+ 반복루프로 바쁜대기를 사용하여 자원을 낭비한다.
	
<br>
**(5) 세마포어**



<br>
<a name="4"/>
## 4. 파일, 파이프, 소켓 프로그래밍 ##
----