---
title: (운영체제) 10 - 입출력 시스템과 저장장치
date: 2020-04-08T15:37:19+09:00
author: nobbaggu
layout: post
categories: 운영체제(OS)
tags:
  - 운영체제
  - os
  - 프로세스
  - 스레드
  - CPU
  - 메모리
  - 가상
---

## 목차 ##
---

- [1. 입출력 시스템](#1)
- [2. 디스크 장치](#2)
- [3. 디스크 스케줄링](#3)
- [4. RAID](#4)


<br>
<a name="1"/>
## 1. 입출력 시스템 ##
----

**(1) 입출력장치와 채널**

+ 입출력 속도가 비슷한 장치끼리 묶어 버스 채널을 할당하면 데이터 전송속도를 향상시킬 수 있다.

<br>
**(2) 입출력 버스의 구조**

+ 초기의 버스 구조
	+ 주변 장치가 적고 CPU와 메모리 속도가 느렸다.
	+ 폴링 방식으로 직접 입출력 장치와 통신
	+ 모든 모듈이 하나의 버스로 연결
	
+ 입출력 제어기 사용
	+ 모든 I/O를 제어기에 맡긴다.
	+ 입출력 버스를 따로 분리
	+ 메인 버스는 CPU와 메모리가 사용
	+ 입출력 버스는 주변장치가 사용
	
+ 속도에 따른 입출력 버스 단계별 분리
	+ 랜카드, 디스크와 같은 고속 입출력 장치
	+ 키보드, 마우스, 프린터 등의 저속 입출력 장치
	+ 그래픽 카드의 경우는 특이한 케이스로 그래픽 버스를 따로 사용한다.
	
<br>
**(3) DMA**

+ 직접 메모리 접근
	+ 메모리 접근 권한을 부여한 DMA 제어기를 두어 I/O장치와 직접 데이터 교환을 가능하게 하는 방식
	+ CPU가 해야할 일을 DMA 제어기가 대신 함으로써 CPU는 그동안 다른 일을 할 수 있다.
	+ 메모리 영역 중 일부를 DMA 제어기에 할당한다.(memory mapped I/O)

![systembus_with_dma_controller3](https://nobbaggu.github.io/images/operating_systems/10/systembus_with_dma_controller3.png){: width="50%" height="50%"}

<br>
**(4) 인터럽트**

+ 인터럽트
	+ 입출력 요구, 하드웨어 이상 등을 CPU에 알려주는 신호
	+ 내부 인터럽트, 외부 인터럽트, 시그널
	
+ 외부 인터럽트 : 입출력 요구, 전원 이상, 기계적 오류 때문에 발생하는 인터럽트
	+ 장치별로 인터럽트 번호(IRQ)가 있고 이를 확인하여 어떤 장치에서 발생한 인터럽트인지 확인

+ 내부 인터럽트 : 프로세스 실행 중에 발생하는 오류
	+ 프로세스의 잘못된 연산으로 발생하기 때문에 프로세스가 강제 종료된다.

+ 시그널 : Unix 시스템에서의 Ctrl+C 혹은 kill 등 사용자가 직접 발생하는 인터럽트
	+ 모든 시그널에 인트럽트 번호 128번 할당
	+ 세부 시그널 번호를 따로 명시하고 이를 통해 시그널 종류 확인
	
+ 인터럽트 벡터
	+ 여러 인터럽트 중 어떤 인터럽트가 발생했는지 확인하기 위한 자료구조
	+ 비트가 1이면 해당 인터럽트가 발생
	+ 벡터의 element별로 인터럽트 핸들러(함수) 매칭
	
+ 인터럽트 핸들러
	+ 인터럽트가 발생했을 때 수행되는 함수
	+ 사용자가 인터럽트 핸들러를 직접 작성하고 재등록할 수 있다.

<br>
**(5) 버퍼링**

+ 버퍼(buffer)
	+ 속도가 다른 두 장치의 속도 차이를 완화하기 위해 사용하는 저장 공간
	+ 장치는 버퍼에 데이터를 담아두고 다른일을 하면 다른 장치가 알아서 버퍼에서 데이터를 꺼내간다.
	+ 버퍼가 다 차기전에는 데이터 전송이 일어나지 않는다. flush()로 강제로 버퍼의 데이터를 전송할 수 있다.

<br>
<a name="2"/>
## 2. 디스크 ##
----

디스크의 구조에 대한 내용은 아래 링크에 나와있다.

[디스크](https://nobbaggu.github.io/2020/03/04/보조저장장치/)

<br>
**(1) 디스크 장치 관리**

+ 파티션(partition)
	+ 디스크를 논리적으로 분할한 공간
	+ 하나의 디스크를 여러 파티션으로 나누거나 여러개의 디스크를 노리적인 하나의 파티션으로 묶을 수도 있다.
	+ UNIX 운영체제는 여러 디스크를 하나의 파티션으로 묶어서 관리한다.
	
+ 포맷(format)
	+ 디스크에 파일 시스템을 탑재하고 디스크 표면을 초기화한 후 파일테이블 탑재

+ 파일 테이블
	+ 디스크에 저장된 파일의 위치와 크기 정보를 저장하는 자료구조

+ 조각모음
	+ 파일을 쓰고 지우는 과정에서 중간중간 조각이 많이 생긴다.
	+ 조각때문에 큰 파일이 여러 조각으로 나뉘어 저장되면 여러 트랙을 오가기 때문에 탐색 시간이 늘어난다.
	+ 주기적으로 조각모음을 해주는 것이 디스크 성능에 좋다.

<br>
<a name="3"/>
## 3. 디스크 스케줄링 ##
----

+ 트랙(track)의 이동을 최소화하여 탐색 시간을 줄이기 위한 방법

<br>
**(1) FCFS 스케줄링**

+ First Come, First Service

+ 가장 단순

+ 요청이 들어온 트랙 순서대로 serve

<br>
**(2) SSTF 스케줄링**

+ Shortest Seek Time First

+ 현재 헤드 위치에서 가장 가까운 트랙부터 serve
	+ 거리가 같다면 먼저 요청받은 트랙부터
	+ 거리가 낮은 순으로 큐에 배치
	
+ 공평성을 위배하며 아사 현상 유발 가능성
	+ 이를 완화하기 위한 블록 SSTF 스케줄링 방식이 있다.
	+ SSTF 큐를 여러 블록으로 나누고 큐 재배치 시 블록 내에서만 내배치 

<br>
**(3) SCAN 스케줄링**

+ SSTF 스케줄링의 공평성 위배 문제를 완하하기 위한 방식

+ 헤드가 한 방향으로만 움직임
	+ 움직이면서 요청받은 트랙에 도착하면 serve
	+ 끝에 닿으면 반대 방향으로 이동 시작
	
+ 성능은 SSTF에 비해 떨어지나 FCFS보다는 우수하다.

+ 공평성 위배
	+ 동일한 트랙이나 실린더 요청이 연속적으로 발생하면 헤드가 더 이상 나아가지 못하고 머물게된다.
	+ 중간 부근 트랙들이 serve 받을 기회가 더 많고 안쪽이나 바깥쪽 트랙일수록 기회가 적다.
	
+ 많이 사용하는 기법 중 하나

<br>
**(4) C-SCAN

+ 한 쪽 방향으로 움직일때는 서비스하고 반대 방향으로 움직일때는 서비스 없이 이동만 한다.

+ SCAN의 공평성 위배 문제를 해결한다.

+ 작업 없이 이동만 하는 작업 때문에 탐색시간이 늘어나고 비효율적

+ 잘 사용되지 않는다.

<br>
**(5) LOOK 스케줄링**

+ SCAN의 불필요한 부분 제거

+ 트랙 요청이 없으면 끝에 도착하지 않았어도 방향을 바꾼다.

+ 많이 사용되는 기법 중 하나

<br>
**(6) C-LOOK 스케줄링**

+ C-SCAN의 LOOK 버전

+ C-SCAN과 같이 한 쪽 방향에서만 서비스하지만 서비스할 트랙이 없으면 중간에서 헤드가 방향을 바꾼다.

<br>
**(7) SLTF 스케줄링**

+ Shortest Latency Time First

+ 모든 트랙 혹은 실린더마다 헤드가 달린 드럼에서 사용하는 디스크 스케줄링 기법

+ 큐로 요청이 들어오면 디스크 회전시 만나게 되는 섹터 순서로 큐를 재배치하여 서비스한다.

<br>
<a name="4"/>
## 4. RAID ##
----

**(1) RAID 개요**

+ RAID란?
	+ Redundant Array Of Independent Disks
	+ 작은 디스크 여러개를 배열구조로 연결하여 패키징한 유닛
	
+ 하나의 대형디스크보다는 여러개의 소형 디스크를 연결하는것이 저렴한 가격으로 더 큰 용량의 디스크를 구성할 수 있게 해준다.

+ 데이터를 다수의 디스크에 분산하여 저장함으로써 여러 디스크 동시 액세스 및 데이터 병렬 전송이 가능

![disk_interleaving](https://nobbaggu.github.io/images/operating_systems/10/disk_interleaving.png){: width="50%" height="50%"}

<br>
+ IBM3390 대형 디스크, IBM0061 소형 디스크, IBM0061을 배열구조로 연결하여 IBM3390과 동일한 용량을 가지도록한 RAID방식 디스크 비교
![disk_comparison](https://nobbaggu.github.io/images/operating_systems/10/disk_comparison.png){: width="50%" height="50%"}

<br>
+ 스트라이핑(striping)
	+ 데이터를 여러 조각으로 나누어 분산하여 저장
	+ 데이터 인터리빙(data interleaving)
	+ RAID0은 순수 스트라이핑 지원
	
+ 미러링(mirroring)
	+ RAID 패키지의 유닛들 중 일부는 원본 데이터를 저장하고 일부는 백업용으로 사용한다.
	+ 같은 내용을 여러번 저장하기 때문에 디스크가 2배 필요하여 비용이 비싸다.
	+ 일부 유닛이 고장나면 미러 유닛으로 복원 가능
	+ RAID1은 순수 미러링 지원
	+ 미러 수만큼 디스크가 추가적으로 필요하기에 비용 발생
	
+ 그 외
	+ RAID 2,3,4,5,6,50,60 등은 오류 교정 코드 등을 사용하여 추가되는 디스크 양을 줄이는 방식

아래 링크로 이어지는 포스팅에 RAID 종류별 특징을 정리해놓았다.

[디스크](https://nobbaggu.github.io/2020/03/04/보조저장장치)