---
title: (운영체제) 4. CPU 스케줄링
date: 2020-03-29T16:37:19+09:00
author: nobbaggu
layout: post
categories: 운영체제(OS)
tags:
  - 운영체제
  - os
  - 프로세스
  - 스레드
  - CPU
  - 스케줄링
---

## 목차 ##
---
- [1. 스케줄링의 개요](#1)
- [2. 스케줄링 시 고려사항](#2)
- [3. 다중 큐](#3)
- [4. 스케줄링 알고리즘](#4)
- [5. 인터럽트 처리](#5)

<br>
<a name="1"/>
## 1. 스케줄링의 개요 ##
----

CPU 스케줄러는 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원을 어떻게 분배할지 결정하는 일을 한다.

**(1) 스케줄링의 단계**

CPU 스케줄링은 규모에 따라 고수준, 중간수준, 저수준으로 구분된다.

+ 고수준 스케줄링
	+ 시스템 내의 전체 작업(일반적으로 프로세스) 수를 조절하는 것
	+ 어떤 작업을 시스템이 받아들일지 거부할지를 결정한다. 이러한 이유로 고수준 스케줄링을 승인 스케줄링이라고도 한다.
	+ 고수준 스케줄링에 따라 시스템에서 동시에 실행 가능한 프로세스 수(멀티프로그래밍 수준)가 결정된다.
	
+ 저수준 스케줄링
	+ 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 것
	+ 준비 상태의 프로세스 중 하나를 골라 실행시키고, 실행 상태의 프로세스를 대기 상태로 보내며, 대기 상태의 프로세스를 준비 상태로 보내는 것 등
	+ 프로세스의 상태를 제어하는 것이 저수준 스케줄링이다.
	
+ 중간수준 스케줄링
	+ 프로세스의 중지(보류상태), 활성화를 통해 프로세스 수를 조절하여 과부하를 막는 것
	+ 과부하가 걸리면 일부 활성화 프로세스를 보류상태로 보내고 여유가 생기면 다시 활성화 시킨다.
	+ 저수준 스케줄링이 원만하게 이루어지도록 하는 완충 역할을 한다.

![scheduling_level](/images/operating_systems/4/scheduling_level.png){: width="50%" height="50%"}


<br>
**(2) 스케줄링의 목적**

+ 공평성
	+ 모든 프로세스가 공평하게 자원을 배정받아야 한다.
	+ 특정 프로세스의 독점이 일어나면 안된다.
	
+ 효율성
	+ 시스템 자원이 유휴 시간 없이 최대한 사용되도록 해야한다.

+ 안정성
	+ 우선순위에 따라 중요한 프로세스가 먼저 실행되도록 해야한다.
	
+ 확장성
	+ 프로세스 수가 증가해도 시스템이 안정적으로 작동해야한다.
	+ 시스템 자원이 늘어나는 경우 시스템에 반영되어야한다.
	
+ 반응 시간 보장
	+ 적절한 시간 안에 프로세스의 요구에 반응해야 한다.
	
+ 무한 연기 방지
	+ 특정 프로세스의 작업이 너무 오래 연기되어서는 안된다.

<br>
<a name="2"/>
## 2. 스케줄링 시 고려사항 ##
----

**(1) 선점형 스케줄링과 비선점형 스케줄링**

+ 선점형 스케줄링
	+ 프로세스가 실행중이더라도 OS가 강제로 CPU를 빼앗을 수 있는 스케줄링 방식
	+ 대표적으로 인터럽트 처리가 있다.
	+ 문맥교환에 따른 부가적인 오버헤드가 생기는 것이 단점이다.
	+ 하나의 프로세스가 CPU를 독점할 수 없기때문에 빠른 응답시간을 요구하는 시분할 시스템, 대화형 시스템에 적합하다.
	+ 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용한다.
	
+ 비선점형 스케줄링
	+ 프로세스가 CPU를 점유중이면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
	+ 문맥교환에 따른 부가적인 오버헤드가 없다.
	+ CPU 사용시간이 긴 프로세스 때문에 다른 프로세스들이 오랫동안 기다릴 수 있어 전체 시스템 처리율이 떨어질 수 있다.
	+ 과거 배치 시스템에서 사용하던 방식

<br>	
**(2) 프로세스 우선순위**

+ 커널 프로세스는 사용자 프로세스보다 높다.

+ 우선순위가 높으면 더 빨리 더 자주 실행된다.

+ 커널 프로세스 사이에서도, 사용자 프로세스 사이에서도 우선순위가 존재한다.
	+ ex) 실시간으로 영상 데이터를 처리하는 비디오 플레이어는 사람이 타이핑하는 것을 처리하는 워드 프로세서보다 우선순위가 높다.
	+ UNIX 운영체제에서는 사용자 프로세스의 우선위가 조절이 가능하다.
	
<br>
**(3) CPU 집중 프로세스와 입출력 집중 프로세스**

+ 프로세스 상태 중에 실제 작업이 일어나는 것은 실행 상태와 대기 상태이다.
	+ 실행 상태에서는 CPU를 사용하여 작업을 한다. -> CPU 버스트
	+ 대기 상태에서는 입출력을 요청하여 완료되기까지 기다린다. -> 입출력 버스트
	
+ CPU 집중 프로세스
	+ 수학 연산과 같이 CPU를 많이 사용하는 프로세스
	+ CPU 버스트가 많은 프로세스
	
+ 입출력 집중 프로세스
	+ 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 일으키는 프로세스
	+ 입출력 버스트가 많은 프로세스
	
+ 입출력 집중 프로세스가 CPU 집중 프로세스보다 우선순위가 높은것이 유리하다.
	+ 입출력 버스트는 입출력 요구 후 대기상태로 접어들기 때문에 다른 프로세스가 CPU를 사용할 수 있기 때문이다.
	
<br>
**(4) 전면 프로세스와 후면 프로세스**

+ 전면 프로세스
	+ 화면의 맨 앞에 놓인 프로세스
	+ 현재 입력과 출력을 사용하는 프로세스이며 사용자와 상호작용이 가능하다.
	
+ 후면 프로세스
	+ 사용자와 상호작용이 없는 프로세스이다.
	
+ 전면 프로세스의 우선순위가 후면 프로세스의 우선순위보다 높다.
	+ 전면 프로세스는 사용자의 요구에 즉각 반응해야 하기 때문이다.

<br>
<a name="3"/>
## 3. 다중 큐 ##
----

**(1) 준비상태 다중 큐**

![ready_multi_queue](/images/operating_systems/4/ready_multi_queue.png){: width="50%" height="50%"}

<br>
+ 프로세스 우선순위는 각 프로세스의 제어 블록에 표시된다.

+ 프로세스는 준비상태에 들어올 때 자신의 우선순위에 해당하는 큐의 마지막에 삽입된다.

+ 준비 큐를 몇 개로 나눌지, 어떤 프로세스에 CPU를 할당할지는 스케줄링 알고리즘에 따라 다르다.



+ 프로세스에 우선순위를 배정하는 방식
	+ 고정 우선순위 방식
		+ 운영체제가 프로세스에 우선순위를 부여하면 프로세스 종료 시 까지 바뀌지 않는다.
		+ 시스템 변화에 대응하기 어려워 작업 효율이 떨어질 수 있다.
	+ 변동 우선순위 방식
		+ 구현하기 어렵지만 시스템 변화에 대응하여 작업 효율성을 높일 수 있다.

<br>
**(2) 대기상태 다중 큐**

![wait_multi_queue](/images/operating_systems/4/wait_multi_queue.png){: width="50%" height="50%"}

<br>
+ 대기 상태에 있는 프로세스들 중 같은 입출력을 요구한 프로세스끼리 같은 큐에 모아놓는다.
	+ 입출력 완료 인터럽트가 발생했을 때 대기상태의 모든 큐를 검색하지 않아도 된다.

+ 입출력 완료 인터럽트를 받은 프로세스는 준비 큐로 이동한다.
	+ 준비 큐와는 다르게 대기상태 큐에서는 여러 프로세스가 한 번에 준비상태로 옮겨질 수 있다.
	+ 동시에 끝나는 인터럽트를 처리하기 위해 인터럽트 벡터를 사용한다.

+ 대기상태 큐에 있는 프로세스들은 보통 순서대로 처리되지만 나중에 들어온 프로세스가 먼저 처리되는 경우가 있다.
	+ 작업 속도를 높이기 위해 입출력장치가 작업 순서를 바꾸는 일이 있기 때문이다.

<br>

아래 그림은 프로세스 제어 블록이 준비 큐와 대기 큐 사이를 이동하는 모습이다.

![process_multi_queue](/images/operating_systems/4/process_multi_queue.png){: width="50%" height="50%"}

<br>
<a name="4"/>
## 4. 스케줄링 알고리즘 ##
----



<br>
<a name="5"/>
## 5. 인터럽트 처리 ##
----

