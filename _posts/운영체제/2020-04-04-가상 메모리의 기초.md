---
title: (운영체제) 8. 가상 메모리의 기초
date: 2020-04-06T11:37:19+09:00
author: nobbaggu
layout: post
categories: 운영체제(OS)
tags:
  - 운영체제
  - os
  - 프로세스
  - 스레드
  - CPU
  - 메모리
  - 가상
---

## 목차 ##
---

- [1. 가상 메모리 개요](#1)
- [2. 페이징 기법](#2)
- [3. 세그먼테이션 기법](#3)
- [4. 세그먼테이션-페이징 혼용 기법](#4)
- [5. 캐시 매핑 기법](#5)

<br>
<a name="1"/>
## 1. 가상 메모리 개요 ##
----

**(1) 가상 메모리 시스템**

+ 가상 메모리(virtual memory)란?
	+ 물리 메모리의 크기보다 큰 메모리 공간을 지원하는 기술
	+ 보조 저장장치를 메인 메모리와 함께 추상화 시켜 실제 메인메모리 보다 큰 메모리 공간을 사용할 수 있다.
	+ 물리 메모리와 마찬가지로 주소(가상 주소)가 할당된다.
	
![virtual_memory](/images/operating_systems/8/virtual_memory.png){: width="50%" height="50%"}

+ 가상 메모리의 크기
	+ 메모리 관리자가 사용할 수 있는 가상 메모리의 최대 크기는 물리 메모리와 스왑 영역을 합친 크기이다.

+ 가상 메모리의 주소
	+ 물리 메모리와 스왑 영역 전체를 추상적인 하나의 메모리로 보고 가상 주소를 할당(동적 주소 변환)
	
+ 가상 메모리의 메모리 분할 방식
	+ 물리 메모리처럼 고정 분할 방식(페이징)과 가변 분할 방식(세그멘테이션) 사용
	+ 세그멘테이션은 외부 단편화 등의 문제로 잘 사용하지 않는다.
	+ 페이징은 페이지 관리의 어려움으로 잘 사용하지 않는다.
	+ 세그멘테이션-페이징 혼용 기법을 주로 사용한다.

<br>
**(2) 매핑 테이블의 필요성과 역할**

+ CPU가 만드는 논리 주소(logical address)가 매핑 테이블(mapping table)을 통해 물리 주소(physical address)로 변환
	+ 동적 주소 변환이라고 한다.
	+ 세그멘테이션 기법 -> 세그멘테이션 테이블
	+ 페이징 기법 -> 페이지 테이블

<br>
<a name="2"/>
## 2. 페이징 기법 ##
----

**(1) 페이징 기법의 구현**

+ 프로세스 고정 분할 방식
	+ 물리 주소 공간을 같은 크기로 나누어 사용한다.
	+ 가상 주소 영역 각각의 분할 영역을 페이지(page)라고 한다.
	+ 물리 주소 영역 각각의 분할 영역을 프레임(frame)이라고 한다.
	+ 페이지와 프레임의 크기는 같으며 1대1 매칭된다.

+ 페이지 테이블
	+ 페이지-프레임 연결(매핑) 정보를 담고 있는 자료구조
	+ 색인(페이지 번호)와 내용(매핑된 프레임의 시작 주소)
	+ 프로세스마다 페이지 테이블 1개 존재
	+ 접근이 빨라야 하므로 메모리의 운영체제 영역에 존재한다.

![page_table](/images/operating_systems/8/page_table.png){: width="50%" height="50%"}

<br>
**(2) 페이징 기법의 주소 변환**

+ 페이지 크기에 따라 페이지가 가지는 주소의 수가 다르다.
	+ ex) 메모리 워드가 1바이트인 컴퓨터에서 페이지와 프레임 크기가 128바이트이면 128개의 주소를 가진다.

+ 가상주소 VA = <P,D>를 물리주소 FA = <F,D>로 변환
	+ P는 페이지 번호, D는 오프셋(페이지의 시작 처음 위치에서 해당 위치까지의 거리), F는 프레임 번호이다.
	+ ex) 페이지 크기=1024byte일 경우 CPU가 가상주소 2000번지를 발생시키면 VA = <1, 976> FA=<PTBL(1), 976>
	+ 페이지 테이블 miss인 경우 스왑 영역에 존재
	
![page_address_translation](/images/operating_systems/8/page_address_translation.png){: width="50%" height="50%"}

<br>
**(3) 페이지 테이블 관리**

+ 프로세스의 수가 늘어날수록 페이지 테이블 수가 많아지고 이들이 차지하는 메모리가 커진다.
	+ ex) 32bit CPU에서 512바이트 페이징 시스템의 경우 프로세스 1개당 페이지 테이블의 최대 크기는 약 24MB, 프로세스가 40개라면 약 1GB
	
+ 페이지 테이블의 크기가 커지면 운영체제 영역이 늘어나 사용가능한 사용자 영역이 줄어든다.

+ 페이지 테이블 기준 레지스터(PTBR)
	+ 프로세스의 페이지 테이블 시작 주소를 보관하는 레지스터
	+ 프로세스 제어 블록에 PTBR 번호 저장

+ 페이지 테이블 크기가 커지면 페이지 테이블의 일부는 메모리에, 나머지는 스왑 영역에 저장될 수 있다.
	
<br>
**(3) 페이지 테이블 매핑 방식**

+ 직접 매핑, 연관 매핑, 세트-연관 매핑, 역매핑

![page_table_mapping_methods](/images/operating_systems/8/page_table_mapping_methods.png){: width="50%" height="50%"}

<br>
+ 직접 매핑
	+ 페이지 테이블 전체가 메모리에 존재
	+ 페이지 번호만 알면 프레임 번호를 즉시 획득할 수 있어 속도가 빠르다.
	+ 물리 메모리가 충분할 때 사용

![direct_mapping](/images/operating_systems/8/direct_mapping.png){: width="50%" height="50%"}


<br>	
+ 연관 매핑
	+ 직접 매핑 페이지 테이블 전체를 스왑 영역에 두고 일부만 메모리에 무작위로 올려 사용
	+ 메모리에 올라온 일부 테이블을 변환 색인 버퍼(TLB)라 부른다.
	+ TLB는 직접 매핑 페이지와 다르게 페이지 번호, 프레임 번호 2개의 열을 가지고 있다.
	+ TLB를 순차 탐색 후 없으면 스왑 영역의 직접 매핑 테이블을 통해 프레임 번호 획득
	+ TLB 히트(hit)인 경우 곧바로 물리 주소로 변환하고 TLB 미스(miss)인 경우 스왑 영역을 탐색한다.
	+ TLB를 모두 탐색한 후에야 TLB miss임을 알 수 있어 TLB 미스가 자주나면 탐색 속도가 느려진다.

![associative_mapping](/images/operating_systems/8/associative_mapping.png){: width="50%" height="50%"}

<br>
+ 세트-연관 매핑(디렉터리 매핑)
	+ 연관 매핑 방식을 개선한 방식
	+ 페이지 테이블을 여러 집합으로 자르고, 자른 덩어리 단위로 물리 메모리에 가져온다.
	+ 집합 테이블(디렉터리 테이블)을 추가로 관리한다.
	+ 집합 테이블을 통해 페이지 테이블 엔트리가 물리메모리, 스왑영역 중 어디에 있는지 확인 후 탐색
	+ 직접 메모리의 물리 메모리 낭비와 연관 매핑의 탐색 속도 문제를 완화

![set_associative_mapping](/images/operating_systems/8/set_associative_mapping.png){: width="50%" height="50%"}

<br>
+ 역매핑
	+ 프레임 번호를 기준으로 페이지 테이블을 구성
	+ 프레임 번호를 인덱스로 하고 프로세스 ID(PID)와 페이지 번호 열을 가진다.
	+ 전체 프로세스를 통틀어 하나의 페이지 테이블만 가지므로 크기가 아주 작다.
	+ 페이지 테이블의 행 수가 실제 프레임 수와 같다.
	+ 특정 프로세스의 페이지 번호를 찾으려면 모든 테이블을 검색해야 하므로 매우 느리다.
	+ 페이지에서 <PID, 페이지 번호>를 찾지 못하면 스왑 영역에서 직접 매핑 테이블을 사용해 프레임 번호를 획득한다.

<br>
<a name="3"/>
## 3. 세그먼테이션 기법 ##
----

+ 가변 분할 방식을 이용한 가상 메모리 구현

<br>
**(1) 세그먼테이션 기법의 구현**

+ 세그먼테이션 테이블 사용
	+ 세그먼트의 크기를 나타내는 limit과 물리 메모리상 주소의 시작주소 address 2개의 열을 가진다.
	+ 물리 메모리가 부족하면 스왑영역 사용
	+ 메모리를 프로세스 단위로 관리하므로 페이지 테이블이 작고 단순
	+ 외부 단편화로 인해 물리 메모리 관리가 복잡

![segmentation_table](/images/operating_systems/8/segmentation_table.png){: width="50%" height="50%"}

<br>
**(2) 세그먼테이션 기법의 주소 변환**

+ 가상주소 VA = <S,D>를 물리주소로 변환
	+ S는 세그먼트 번호, D는 오프셋(세그먼트 시작 주소에서 해당 위치까지의 거리)
	+ ex) CPU가 가상주소 VA = <3,5>(세그먼트 3의 5번지)를 발생시키면 메모리의 물리주소 STBL(3) + 5번지로 이동
	+ 계산된 물리 주소가 세그먼트에 할당된 영역을 벗어나면 트랩(주소 오류)를 발생시키고 프로세스를 강제 종료한다.

<br>
<a name="4"/>
## 4. 세그먼테이션-페이징 혼용 기법 ##
----

+ 페이징 기법과 세그먼테이션 기법의 장점만을 취한 가상 메모리 관리 기법

<br>
**(1) 메모리 접근 권한**

+ 읽기,쓰기,실행 권한의 조합
	+ 코드영역 : 읽기,실행 가능
	+ 데이터 영역 : 읽기는 항상 가능하며 변수, 상수에 따라 쓰기 권한 부여 결정

+ 가상 주소가 물리 주소로 변환될 때 마다 메모리 접근 권한을 검사
	+ 권한을 벗어난 시도는 트랩 발생
	+ 매핑 테이블은 메모리 접근 권한 정보를 가지고 있어 주소 변환시에 유효한 접근인지 검사한다.
	
<br>
**(2) 페이징-세그먼테이션 혼용 기법의 도입**

+ 페이지 테이블에서 페이지마다 권한 비트를 추가하면 테이블 크기가 커져 메모리 낭비 발생
	+ 인접한 페이지의 메모리 접근 권한은 같은 경우가 많다.
	+ 페이지로 분할된 가상 주소 공간에서 관련 있는 영역을 하나의 세그먼트로 묶어 세그먼테이션 테이블로 관리
	+ 세그먼테이션 테이블은 세그먼트별 페이지의 시작 주소를 가진다.
	+ 대부분의 OS가 이 방식을 사용한다.

<br>
**(3) 페이징-세그먼테이션 혼용 기법의 주소 변환**

+ CPU가 발생시킨 가상주소 VA = <S,P,D>를 물리주소로 변환

![paing_segmentation_address_translation](/images/operating_systems/8/paing_segmentation_address_translation.png){: width="50%" height="50%"}

<br>

	(a) CPU가 가상주소 VA = <S,P,D> 발생
	(b) 세그먼테이션 테이블에서 권한을 검사하고 통과하면 페이지 테이블 시작 주소를 획득
	(c) 페이지 테이블로 찾아가 해당 페이지의 프레임 번호를 획득
	(d) 물리 메모리에서 해당 프레임의 처음 위치에서 D만큼 떨어진 데이터 획득

<br>
+ 메모리에 원하는 데이터가 없으면 스왑 영역에서 해당 페이지 검색

<br>
<a name="5"/>
## 5. 캐시 매핑 기법 ##
----

