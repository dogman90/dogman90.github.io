---
title: (운영체제) 2. 컴퓨터의 구조와 성능 향상
date: 2020-03-28T18:37:19+09:00
author: nobbaggu
layout: post
categories: 운영체제(OS)
tags:
  - 운영체제
  - os
---

## 목차 ##
---
- [1. 컴퓨터의 기본 구성](#1)
- [2. CPU와 메모리](#2)
- [3. 컴퓨터 성능 향상 기술](#3)
- [4. 병렬 처리](#4)
- [5. 무어의 법칙과 암달의 법칙](#5)

<br>
이번 장에서는 운영체제(OS)를 공부하는데 도움이되는 컴퓨터구조의 내용들을 매우 간략하게 살펴본다. 컴퓨터구조를 공부한 사람이면 굳이 필요없을 것이다.

<br>
<a name="1"/>
## 1. 컴퓨터의 기본 구성 ##
----

**(1) 하드웨어의 구성**

컴퓨터는 CPU, 메인메모리, 입출력장치, 보조저장장치로 구성된다. 이 중 컴퓨터라는 정의를 만족시키기 위한 최소한의 장치는 CPU와 메모리이다. 따라서 CPU와 메모리를 필수장치, 나머지를 주변장치라고 한다.

+ CPU와 메모리
	+ CPU는 명령어를 인출, 해독, 실행한다. 인간의 두뇌에 해당
	+ 메모리는 실행되는 프로그램이 올라가고 프로그램 실행중에 필요한 데이터를 저장하는 장소이다. 메모리는 휘발성으로 컴퓨터 전원이 OFF되면 데이터가 지워진다.
	
+ 입출력장치
	+ 입력장치는 데이터를 입력하는 장치이다. 마우스, 키보드 등이 대표적인 예다.
	+ 출력장치는 프로그램의 실행 결과 혹은 데이터를 출력하는 장치이다. 모니터, 프린터, 스피커 등이 대표적인 예다.

+ 저장장치
	+ 메모리처럼 데이터를 저장하기 위한 용도로 사용된다.
	+ 메모리보다 데이터의 입출력이 느리다.
	+ 비휘발성으로 컴퓨터 전원이 꺼져도 데이터가 보존된다.
	+ 하드디스크, SSD, CD 등이 대표적인 예다.
	
+ 메인보드
	+ 컴퓨터의 부품들은 데이터의 이동 통로인 버스를 통해 연결된다.
	+ 메인보드는 CPU와 메모리 및 주변장치를 버스를 통해 연결한 커다란 PCB 판이다.
	+ 메인보드에는 주변장치를 연결하기 위한 접속 단자들이 있다.
	
<br>
**(2) 폰노이만 구조**

오늘날 대부분의 컴퓨터는 폰노이만 구조를 사용한다.

+ CPU, 메모리, 입출력 장치 및 기타 주변장치들이 버스로 연결되어 있다.

+ 폰노이만 이전의 컴퓨터는 전선을 연결하여 회로를 구성하는 하드와이어링 방식을 사용했다.

+ 폰노이만 구조 이후로 메모리에 올리는 프로그램만 교체하면 나머지는 그대로 두고 다른 프로그램을 실행할 수 있게 되었다. 즉, 프로그래밍 가능한 컴퓨터 구조의 시초이다.

+ 폰노이만 구조의 가장 큰 특징은 **모든 프로그램은 메모리에 올라와야 실행할 수 있다**는 것이다.

+ 프로그램 실행 코드와 데이터가 구분되지 않고 모두 메모리에 저장된다.

<br>
**(3) 하드웨어 사양 관련 용어**

+ 클럭(clock)
	+ CPU의 모든 작업이 일어나는 기본 단위이다.
	+ 펄스(pulse)를 만들어낸다.
	+ 클록이 펄스를 만들면 거기에 맞추어 CPU안의 모든 구성부품이 한 가지 기본 작업을 수행한다.
	+ 버스상의 데이터 이동도 클럭의 펄스 한 번당 발생한다.
	+ 클럭의 속도 단위는 헤르츠(Hz)를 사용한다.
	+ ex) 인텔의 i7 모델은 클럭 속도가 3.4GHz로 1초에 약 34억번의 연산을 할 수 있다.

+ CPU 내부 버스
	+ CPU 내부 모듈(ALU, 레지스터, 제어유닛 등) 사이의 버스
	+ CPU 클럭 속도로 작동한다.
	
+ 시스템 버스
	+ CPU와 외부 장치(메모리, 입출력 장치 등)를 연결하는 버스
	+ 메인보드 클럭 속도로 작동한다.

<br>
<a name="2"/>
## 2. CPU와 메모리 ##
----

**(1) CPU의 구성과 동작**

+ CPU의 기본 구성
	+ 산술.논리 연산유닛(ALU - Arithmetic Logical Unit)
		+ 데이터의 4칙연산, 시프트 연산, 논리연산 등을 담당한다.
	
	+ 제어유닛(CU - Control Unit)
		+ 명령어를 인출, 해독하여 필요한 연산 및 데이터의 저장과 같은 일들을 '명령'한다.
	
	+ 레지스터
		+ CPU 내에서 데이터를 임시로 보관하는 곳이다.
		+ 크기가 작고 CPU안에 위치하여 메모리보다 접근이 빠르다.

+ CPU의 명령어 처리과정
	+ 제어장치가 명령어를 인출
	+ 제어장치가 명령어를 해독
	+ 필요한 연산을 수행하는 제어신호(명령)을 발생
	+ 결과값 저장(레지스터, 혹은 메모리)
	
+ 레지스터의 종류
	+ 범용(일반) 레지스터
		+ 데이터 레지스터 : 데이터를 임시로 보관
		+ 주소 레지스터 : 주소를 임시로 보관
	+ 특별한 용도로 사용되는 레지스터이다. 사용자가 값을 변경할 수 없고 철저히 제어유닛(Control Unit)에 의해 관리된다.
		+ 프로그램 카운터(PC) : 현재 실행중인 명령어 다음에 실행해야할 명령어가 있는 메모리의 주소. 명령어 포인터라고도 한다.
		+ 명령어 레지스터(IR) : 실행해야 할 명령어가 인출되어 저장되는 레지스터. 제어유닛에 의해 해독되고 실행된다.
		+ 메모리 주소 레지스터(MAR) : 메모리의 특정 주소를 지정하기 위해 내보낼 주소가 임시로 머무는 곳. 메모리 관리자가 이 레지스터에 담긴 주소를 가져간다.
		+ 메모리 버퍼 레지스터(MBR) : 메모리로 내보낼 데이터, 메모리에서 읽어온 데이터가 임시로 머무르는 레지스터. 항상 MAR와 함께 동작한다.
		
+ 버스의 종류
	+ 제어버스
		+ 작업을 위한 제어신호(읽기/쓰기 같은 명령 혹은 주변장치가 작업을 완료했다는 확인 신호 등)가 이동한다.
		+ 양방향
		+ CPU의 제어유닛에 연결되어있다.

	+ 주소버스
		+ 메모리, 디스크에 데이터를 읽기/쓰기할 때 주소를 내보내는 버스이다.
		+ 내보내기만 하므로 단방향이다.
		+ CPU의 주소 레지스터(MAR)와 연결되어 있다.
	
	+ 데이터 버스
		+ 데이터가 나가고 들어오는 통로이다.
		+ 양방향
		+ CPU의 메모리 버퍼 레지스터(MBR)과 연결되어 있다.
		
<br>
**(2) 메모리의 종류와 부팅**

+ 메모리의 종류
	+ 휘발성 메모리
		+ PC 전원이 꺼지면 데이터가 사라진다.
		+ CPU 레지스터 및 캐시(cache)는 SRAM으로 되어있다.
		+ 메인 메모리는 DRAM으로 되어있다.
		+ 현재는 DRAM을 향상시킨 SDRAM, DDR SDRAM이 메인 메모리로 사용되며 SDRAM보다 대역폭이 16배 큰 DDR4 SDRAM까지 나왔다.
		
	+ 비휘발성 메모리
		+ PC 전원이 꺼져도 데이터가 사라지지 않는다.
		+ 하드디스크(HDD), 플래시 메모리로 이루어진 SSD(Solid State Drive)

+ 메모리 보호
	+ 프로세스(프로그램)이 실행될 때 프로그램의 시작주소와 마지막 주소를 각각 경계(base) 레지스터와 한계(limit) 레지스터에 저장한다.
	+ CPU와 운영체제는 프로그램이 실행될 때 해당 프로그램의 메모리 읽기/쓰기가 범위 안에서 일어나는지 검사한다.
	+ 범위를 벗어나는 주소로 접근하면 CPU가 인터럽트를 발생시키고 운영체제를 깨워 인터럽트 서비스 루틴(ISR)을 처리하도록 한다.
	+ 메모리 범위를 벗어난 인터럽트의 경우 운영체제가 해당 프로그램을 강제로 종료시킨다.
	
![base_limit_register](/images/operating_systems/2/base_limit_register.png){: width="50%" height="50%"}

<br>
+ 부팅
	+ 운영체제 역시 응용프로그램과 다르지 않게 하나의 소프트웨어 프로그램이다.
	+ 운영체제가 실행되기 위해 메모리에 올라가는 과정을 부팅(booting)이라고 한다.
	
+ 부팅순서
	+ PC 전원 ON(이 순간 CPU의 PC는 초기화 상태로, 0번지를 가르키고 있다.)
	+ ROM의 0번지에 저장된 BIOS(Basic Input Output System)를 실행하여 시스템에 이상이 있는지 확인
	+ BIOS가 **마스터 부트 레코드**(MBR, 하드디스크의 0번째 섹터)에 있는 **부트스트랩**(bootstrap) 코드를 실행
	+ 부트스트랩이 운영체제를 메모리에 로드
	+ 만약 운영체제가 2개 이상이면 부트스트랩 코드가 실행되고 어떤 운영체제를 불러올 것인지 물어보는 화면이 나타난다.

<br>
<a name="3"/>
## 3. 컴퓨터 성능 향상 기술 ##
----

컴퓨터 구조상의 가장 큰 문제는 CPU와 메모리의 작업 속도가 다르다는 것이고 심지어 메모리와 보조저장장치 사이에는 더 큰 속도 갭이 존재한다. CPU가 아무리 빨리 작업을 처리해도 메모리와 저장장치가 이를 따라오지 못한다.

여기서는 CPU와 다른 장치간의 속도차에서 오는 성능저하를 개선하여 작업 처리속도를 올리는 기술 중 운영체제와 관련된 기술들을 소개한다.

<br>
+ 버퍼(buffer)
	+ 데이터 읽기/쓰기가 일어날때마다 하나씩 전송하면 비효율적이다.
	+ 버퍼를 두어 일정량을 모아서 전송함으로써 속도차이를 완화할 수 있다.
	+ ex) 하드디스크의 버퍼가 32BM이면 메모리로 데이터를 32MB씩 모아서 전송한다.
	+ 하드웨어적인 버퍼뿐 아니라 소프트웨어적인 버퍼도 있다. 유튜브 스트리밍의 경우도 영상 데이터를 일정량 모아서 출력시킨다.
	+ 버퍼는 여러 응용프로그램이 공유하여 사용한다.

+ 스풀(spool)
	+ 일종의 버퍼이지만 프로그램간 공유가 되지않고 한 프로그램의 스풀 사용이 끝나야 다른 프로그램이 이를 사용할 수 있다.
	+ ex) 워드프로세서가 작성한 내용을 프린터로 출력하기 위해 프린터의 스풀러로 모든 내용을 전송한다. 프린터가 시작되면 스풀러의 내용이 인쇄되는데 인쇄 완료전까지는 다른 출력작업을 할 수 없다.
	
+ 캐시(cache) 메모리
	+ CPU와 메모리 사이에 있는 메모리의 일종이다.
	+ 메인메모리가 DRAM을 사용하는것과 다르게 더 빠른 SRAM을 사용한다.
	+ 메모리에서 최근 가져온 데이터, 앞으로 사용될 확률이 높은 데이터 등이 저장되어 있다.
	+ 메모리보다 캐시 접근 속도가 월등히 빠르다.
	+ CPU가 데이터를 가져올 때 메모리보다 앞서 캐시를 먼저 검사한다. 캐시에 있으면 이를 사용하고 없으면 메모리에서 가져온다.
	
+ 캐시 적중률
	+ 필요한 데이터를 캐시에서 찾는 비율
	+ 캐시 히트율이 높으면 그만큼 프로그램 성능이 향상된다.
	+ 데이터 지역성에 근거하여 캐시 적중률을 높이는 다 수의 알고리즘이 존재한다.

+ 데이터 일관성 문제
	+ 버퍼나 캐시를 사용할 때 발생할 수 있는 문제
	+ 캐시의 내용이 변하면 메모리에도 이를 반영해야 한다.
	+ 버퍼에 있는 모든 데이터가 전송되지 않았는데 장치 연결을 해제하거나 PC가 OFF되면 데이터를 잃는다.
	+ 이러한 문제는 병렬 컴퓨터나 분산 컴퓨팅 시스템에서도 발생할 수 있다.
	
+ 인터럽트
	+ CPU가 입출력장치에 작업지시 신호를 보내놓으면 입출력장치의 제어기가 알아서 처리한다. CPU는 그 시간에 다른 일을 할 수 있다.
	+ 작업이 완료되면 입출력장치가 CPU에 인터럽트 신호를 보낸다.
	+ 인터럽트가 오기 전까지 CPU는 다른 작업을 처리한다.
	+ 폴링(polling)방식에서 CPU가 직접 입출력장치의 데이터 이동에 관여하는 것과 달리 인터럽트 방식에서는 이러한 비용이 사라져 성능이 좋아진다.
	+ CPU가 완료 인터럽트 신호를 받으면 옮겨진 데이터를 처리한다.
	
+ 직접 메모리 접근(DMA - Direct Memory Access)
	+ 인터럽트를 사용하더라도 데이터는 CPU를 거친다.
	+ 메모리와 입출력장치간에 직접 데이터 이동이 가능하도록 DMA 제어기를 두면 CPU는 말그대로 데이터 입출력 명령만 내릴 수 있다.
	
![systembus_with_dma_controller](/images/operating_systems/2/systembus_with_dma_controller.png){: width="50%" height="50%"}

<br>
<a name="4"/>
## 4. 병렬 처리 ##
----

**(1) 병렬처리의 개념**

+ 여러개의 명령을 동시에 처리하는 것
	+ 슈퍼스칼라(멀티 코어)
	+ 파이프라이닝(멀티 스레딩)

+ 병렬처리 시 고려사항
	+ 명령간 의존성이 없어야 동시에 처리가 가능하다.
	+ 명령어를 세분화했을 때 각 부분의 시간이 비슷해야한다.
	+ 병렬처리의 깊이(작업을 N개로 쪼개는 것)가 클수록 동시에 처리할 수 있는 작업이 많아지지만 이에따른 작업 이동의 오버헤드가 너무 클 것이다. 적절한 깊이를 정해야한다.
	
+ 파이프라이닝 기법
	+ 명령어를 여러 단계로 세분화하여 동시에 처리할 수 있는 부분을 동시에 처리하는 방법
	+ 하나의 코어에서 여러개의 스레드를 사용하는 것
	+ 한 명령어의 실행에 다른 명령어의 결과가 필요하면, 즉 의존성이 없어야한다.
	+ 갑자기 분기가 일어나면 이미 인출(IF)이 끝난 명령어들이 필요없어져 버리게 되는 낭비가 생긴다.(분기 예측으로 해결)
	+ 동시에 실행중인 두개 이상의 명령어에서 같은 자원에 접근하려하면 충돌이 발생할 수 있다.
	
![4-stage-pipeline](/images/operating_systems/2/4-stage-pipeline.png){: width="60%" height="60%"}

![4_stage_pipeline_with_branch](/images/operating_systems/2/4_stage_pipeline_with_branch.png){: width="60%" height="60%"}

<br>
+ 슈퍼스칼라 기법
	+ 하드웨어적으로 코어를 여러 개 두는 것(멀티코어)
	+ 명령어 사이 상호 의존성이 없어야한다.
	
![superscalar.png](/images/operating_systems/2/superscalar.png){: width="60%" height="60%"}
