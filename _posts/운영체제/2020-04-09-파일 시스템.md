---
title: (운영체제) 11 - 파일 시스템
date: 2020-04-09T15:37:19+09:00
author: nobbaggu
layout: post
categories: 운영체제(OS)
tags:
  - 운영체제
  - os
  - 프로세스
  - 스레드
  - CPU
  - 메모리
  - 가상
  - 파일시스템
---

## 목차 ##
---

- [1. 파일과 파일 시스템](#1)
- [2. 디렉터리의 구조](#2)
- [3. 디스크 파일 할당](#3)
- [4. 유닉스 파일의 특징](#4)


<br>
<a name="1"/>
## 1. 파일과 파일 시스템 ##
----

**(1) 파일 시스템 개요**

+ 파일 시스템(File System)
	+ 파일을 보관하고 관리하는 파일 관리자
	+ 사용자가 파일을 직접 보관하거나 접근하지 못하도록 한다.

+ 파일 시스템의 기능
	+ 파일 구성
	+ 파일 관리
	+ 접근 권한 관리
	+ 접근 방법 제공
	+ 무결성 보장
	+ 백업과 복구
	+ 암호화
	
+ 블록(Block)
	+ 디스크에서 데이터는 볼록 단위로 전송
	+ 블록 마다 하나의 주소와 번호를 가진다.
	
+ 파일 테이블(File Table)
	+ 모든 파일의 메타 데이터를 기록하는 자료구조
	+ 각 파일은 메타 데이터를 저장하는 파일 헤더를 가지고 파일 테이블은 이러한 파일 헤더들을 기록한다.
	+ 윈도우는 파티션별로 파일 테이블 존재하고 UNIX 계열 운영체제는 하나의 파일 테이블로 모든 파티션을 관리한다.
	
<br>
**(2) 파일 분류와 확장자**

+ 실행 파일
	+ 운영체제가 메모리로 가져와 CPU를 이용한 작업을 하는 파일
	+ 사용자의 요청으로 프로세스가 된다.
	
+ 데이터 파일
	+ 데이터를 모아놓고 보관만 하는 파일
	+ 프로세스가 될 수 없다.
	+ 실행시키면(엄밀히 말하면 실행이 아니다) 해당 파일을 사용하는 응용 프로그램이 실행되고 OS가 데이터 파일을 응용 프로그램에 넘겨준다.

+ 파일 헤더
	+ 이름, 버전, 크기, 만든 날짜, 접근 권한 등을 저장
	+ 모든 파일은 헤더를 가진다.
	+ 파일 테이블에서 관리


<br>
**(3) 파일 구조**

+ 순차 파일 구조
	+ 파일 내용이 하나의 긴 줄로 늘어선 형태
	+ 순차 접근 이용
	+ 파일을 생성하거나 열어 파일 디스크립터(file descriptor) 획득하는데, 파일 디스크립터는 파일의 가장 앞부분에 존재
	+ 읽기, 쓰기를 하면 파일 디스크립터가 앞으로 전진한다.
	+ 데이터가 순서대로 기록되므로 저장 공간 낭비가 없다.
	+ 중간에 데이터 삽입, 중간 데이터 삭제 시에는 데이터를 밀거나 당겨야하므로 데이터 변경이 잦은 경우 순차 파일 구조는 적합하지 않다.
	+ 특정 위치로 이동 시 앞에서부터 순서대로 움직이므로 데이터 검색에 적합하지 않다.

+ 인덱스 파일 구조
	+ 순차 파일 구조에 인덱스 테이블 추가
	+ 순차 접근, 직접 접근 가능
	+ 빠른 검색이 가능
	+ 현대의 파일 시스템, 데이터베이스가 사용하는 구조

+ 직접 파일 구조
	+ 키(key)를 가지고 해시값을 계산하여 물리적 주소로 변환하는 파일 구조

+ 파일 디스크립터(File Descriptor)
	+ 시스템으로부터 할당 받은 파일을 대표하는 0이 아닌 정수 값
	+ 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값
	+ 프로세스에서 열린 파일의 목록을 관리하는 테이블의 인덱스
	+ 프로세스가 파일을 open하면 해당 프로세스가 가진 파일 디스크립터 숫자 중 가장 작은 값을 할당
	+ 파일 디스크립터를 통해 프로세스가 파일에 access한다.

<br>
<a name="2"/>
## 2. 디렉터리 구조 ##
----

**(1) 디렉터리의 개념

+ 관련 있는 파일을 모아놓은 곳
	+ 자식 디렉터리를 가질 수 있다.

+ 최상 디렉터리 = 루트 디렉터리

<br>
**(2) 디렉터리 파일**

+ 디렉터리도 파일이다.
	+ 파일 정보가 저장된 파일
	+ 헤더를 가진다.

<br>
**(3) 경로**

+ 절대 경로(absolute path)
	+ 루트 디렉터리에서 시작하는 절대적인 위치
	
+ 상대 경로(relative path)
	+ 현재 위치를 기준으로 시작하는 파일의 위치

<br>
**(4) 디렉터리 구조**

+ 1단계 디렉터리 구조
	+ 루트 디렉터리 안에 디렉터리 생성 가능
	+ 하지만 디렉터리들은 자식 디레터리를 가질 수 없고 파일만 만들 수 있다.
	
+ 트리 디렉터리 구조
	+ 루트 디렉터리 하위 모든 디렉터리가 자식 디렉터리와 파일 생성 가능
	+ 비순환 그래프
	+ 바로가기 링크를 사용하면 순환 그래프를 만들 수 있다.
	
<br>
**(5) 마운트**

+ 여러 파티션을 통합하는 명령어

+ 마운팅 포인트(mounting point)
	+ 파티션 사이의 연결 지점
	+ ex) mnt 디렉터리 생성 후 여기에 다른 파티션을 이어붙이면 mnt 디렉터리가 마운팅 포인트이다.
	+ ex) UNIX계열 운영체제에서는 /dev 디렉터리에 외부 장치를 마운트하여 사용한다.
	
![mount](https://nobbaggu.github.io/images/operating_systems/11/mount.png){: width="50%" height="50%"}

<br>
<a name="3"/>
## 3. 디스크 파일 할당 ##
----

**(1) 연속 할당과 불연속 할당**

+ 연속 할당
	+ 파일을 구성하는 여러 블록을 연속적인 배열로 구성
	+ 파일의 시작만 알면 전체 파일을 찾을 수 있다.
	+ 단편화로 인해 실제로는 사용하지 않는다.
	
+ 불연속 할당
	+ 비어 있는 블록에 파일의 데이터를 분산하여 저장
	+ 연결 리스트를 사용하는 연결 할당
	+ 인덱스를 사용하는 인덱스 할당
	
+ 연결 할당(Linked Allocation)
	+ 파일 테이블에는 파일의 시작 블록만 기록하고 나머지 데이터는 연결하여 저장한다. NULL을 만나면 끝
	+ 연결 정보를 저장하는 테이블 형태의 자료구조(파일 제어 테이블)를 사용하여 관리
	+ 파티션이 사용할 수 있는 디스크 용량이 테이블의 주소 크기로 제한
	+ FAT16, FAT32
	
![linked_allocation](https://nobbaggu.github.io/images/operating_systems/11/linked_allocation.png){: width="50%" height="50%"}

<br>
+ 인덱스 할당(Indexed Allocation)
	+ 파일 제어 테이블의 블록 포인터가 데이터의 인덱스를 담고 있는 인덱스 블록을 연결한다.
	+ 인덱스 블록에 실제 블록 위치가 순서대로 나열되어있고 이를 통해 파일을 찾는다.
	+ 인덱스 블록이 꽉 차면 간접 인덱스 블록(indirect index block)을 통해 테이블을 무한히 확장할 수 있다.

![indexed_allocation](https://nobbaggu.github.io/images/operating_systems/11/indexed_allocation.png){: width="50%" height="50%"}
