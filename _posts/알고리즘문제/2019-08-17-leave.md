---
title: (백준 14501)-퇴사
date: 2019-08-17T17:18:34+09:00
author: SWnomad
layout: post
categories: 알고리즘문제
tags:
  - 브루트포스
  - brute force
  - 자바
  - java
  - 백준
  - 재귀
  - recursion
  - 14501
  - 퇴사
---

[백준 14501 - 퇴사](https://www.acmicpc.net/problem/14501){: target="_blank" }

## 1. 풀이 전략
* * *

1번째 날부터 N번째 날까지 세어가면서 i번째 날의 일을 할 경우와 하지 않을 경우 각각으로 나누어 생각하면 된다. 일을 하는 경우는 수익을 합계에 더하고 T[i]만큼의 날을 건너뛰고, 일을 하지 않는 경우에는 수익은 그대로 두고 다음 날로 건너뛰면 된다. 이러한 방식은 재귀호출을 사용해 구현할 수 있다.

<br>

재귀호출 알고리즘은 크게 세 과정으로 분할하여 짜면 된다.

>1. 더 이상 진행해도 정답일 가능성이 없는 경우
>2. 정답 후보를 찾은 경우
>3. 아직 정답을 찾지 못하여 다음 순서를 호출하는 경우

각각의 과정으로 나누어 생각하면 비교적 쉽게 재귀호출 알고리즘을 짤 수 있다.

조금 더 자세한 내용은 아래의 링크로 이어지는 포스팅에서 볼 수 있다. 그렇게 길지 않으므로 시간적 여유가 된다면 한 번 봐두어 같은 유형의 문제에 계속해서 적용할 수 있다.

<br>
[재귀](https://swnomad.github.io/2019/08/11/recursion/){: target="_blank" }

<br>

## 2. 소스 코드
* * *

~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main{
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//퇴사일까지 남은 일수 N 입력
		N = Integer.parseInt(br.readLine());
		
		//T,P 입력
		T = new int[N+1];
		P = new int[N+1];
		for(int i=1; i<=N; i++) {
			StringTokenizer tk = new StringTokenizer(br.readLine());
			T[i] = Integer.parseInt(tk.nextToken());
			P[i] = Integer.parseInt(tk.nextToken());
		}
		
		recursion(1, 0);
		System.out.print(max);
	}
	
	static int N; //퇴사까지 남은 일 수
	static int[] T; //일 하는데 걸리는 시간
	static int[] P; //일을 했을 때 수당
	static int max = 0; //최대 수익
	
	static void recursion(int i, int money) {
		
		//정답 조건
		//어떠한 일을 했을 때 N+1번째 날이 된다면 할 수 있는 일이다
		if(i<=N+1 && money > max)
			max = money;
		
		//종료 조건
		if(i>N)
			return;
		
		//다음 호출 진행
		//1)i일 째 일을 하지 않을 경우
		//다음 날로 건너 뜀
		recursion(i+1, money);
		
		//2)i일 째 일을 할 경우
		//T[i]일 동안 일을 했으므로 i+T[i]날부터 다시 일을 할 수 있다
		recursion(i+T[i], money+P[i]);
	}
	
}
~~~