---
title: (백준 9095)-1,2,3 더하기
date: 2019-08-10T17:28:34+09:00
author: SWnomad
layout: post
categories: 알고리즘문제
tags:
  - 브루트포스
  - brute force
  - 자바
  - java
  - 백준
  - 9095
---

[백준 9095 - 1,2,3 더하기](https://www.acmicpc.net/problem/9095){: target="_blank" }

## 1. 풀이 전략
* * *

1, 2, 3 각각의 갯수 모든 경우에 대한 다중 for문을 돌린다.

말하자면 1,2,3 각각은은 아무리 많아도 n/1개, 2는 n/2개, 3은 n/3개보다 많을 수는 없다. 그렇게 되면 n보다 커지기 때문이다.

따라서 각각의 경우에 대해 중복된 for문을 구성하여 합이 n이 되는 경우 count를 증가시키면 된다.

만약 1을 a개, 2를 b개, 3을 c개 더하여 n이 된다하면 이 조합에서 나오는 모든 경우의 수는 factorial(a+b+c)/(factorial(a)*factorial(b)*factorial(c)) 개이다.

<br>

## 2. 소스 코드
* * *

~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

class Main{
	public static void main(String[] args) throws NumberFormatException, IOException {
		//입력을 받기 위한 BufferedReader객체 생성
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//테스트 케이스의 갯수 t
		int t = Integer.parseInt(br.readLine());
		
		//각 테스트 케이스에 대한 알고리즘
		for(int i=0; i<t; i++) {
			int n = Integer.parseInt(br.readLine());

			int result = 0;//총 갯수 0으로 선언 및 초기화
			
			//l,j,k는 각각 1의 갯수, 2의 갯수, 3의 갯수
			for(int l=0; l<=n/1; l++) {
				for(int j=0; j<=n/2; j++) {
					for(int k=0; k<=n/3; k++) {
						
						//1이 l개, 2가 j개, 3이 k개 있을 때 합이 n이면 이 조합으로 만들 수 있는 경우의 수를 result에 더하기
						if(l*1 + j*2 + k*3 == n) {
							result += factorial(l+j+k) / (factorial(l)*factorial(k)*factorial(j));
						}
					}
				}
			}
			
			System.out.println(result);
			
		}
		
	}
	
	//팩토리얼 계산 함수
	public static int factorial(int n) {
		int result = 1;
		for(int i=2; i<=n; i++) {
			result *= i;
		}
		
		return result;
	}
}
~~~