---
title: (백준 7576)-토마토
date: 2019-09-01T17:18:34+09:00
author: SWnomad
layout: post
categories: 알고리즘문제
tags:
  - 그래프
  - bfs
  - dfs
  - 완전탐색
  - 단지번호
  - 백준
  - boj
---

[백준 7576 - 토마토](https://www.acmicpc.net/problem/7576){: target="_blank" }

## 1. 풀이 전략
* * *

익은 토마토에서 인접한 토마토로 탐색을 하며 익지않은 토마토(0)을 익은 토마토(1)로 바꾸면 된다. 단, 주의할 점은 한 번에 하나의 토마토의 인접한 곳을 탐색하는게 아닌 익은 모든 토마토 주변을 탐색해야 한다. 익은 토마토의 인접한 모든 토마토를 익히고 걸리는 기간 day를 1 증가시키면 된다. 새로 익힌 토마토를 q에 저장하고 다음날에 q에 있는 모든 토마토의 인접한 토마토를 익게 한다. 그리고 모든 토마토가 익었는지 확인한 후 익지 않은 토마토가 있으면 이 과정을 다시 실행한다. 그런데, q가 비어있음에도(인접한 곳에 익혀야 할 토마토가 없음에도) 모든 토마토가 익지 않았다는 것은 빈 공간으로 막혀있어 애초에 익을 수 없는 토마토가 있는 것이므로 -1을 출력해주면 된다.


## 2. 소스 코드
* * *

~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer tk = new StringTokenizer(br.readLine());
		
		M = Integer.parseInt(tk.nextToken());
		N = Integer.parseInt(tk.nextToken());
		
		map = new int[N][M];
		for(int i=0; i<N; i++) {
			tk = new StringTokenizer(br.readLine());
			for(int j=0; j<M; j++) {
				map[i][j] = Integer.parseInt(tk.nextToken());
			}
		}

		System.out.print(bfs());
	}
	
	static int N, M;
	static int[][] map;
	
	static int bfs() {
		Queue<Pair> q = new LinkedList<>();
		
		//익은 과일 q에 저장
		for(int i=0; i<N; i++) {
			for(int j=0; j<M; j++) {
				if(map[i][j]==1) {
					q.add(new Pair(i,j));
				}
			}
		}
		
		boolean allDone = true; //모든 과일이 익었는지 확인하기 위한 변수
		//익지 않은 과일이 있는지 확인
		for(int i=0; i<N; i++) {
			for(int j=0; j<M; j++) {
				if(map[i][j]==0) { //익지 않은 과일이 있으면
					allDone = false; //allDone = false
					i=N; j=M; //2중 for문 탈출
				}
			}
		}
		
		int day = 0; //과일이 다 익는데 걸리는 시간
		while(!allDone) { //과일이 다 익지 않는 한 실행
			int num = q.size(); //어제 익은 과일의 갯수
			
			//어제 익은 과일에 인접한 과일의 주변에 있는 과일 익게 하기
			for(int i=0; i<num; i++) {
				Pair cur = q.remove();
				
				int[] dr = {0,0,-1,1};
				int[] dc = {-1,1,0,0};
				
				//상하좌우에 안익은 토마토가 있으면 익도록 하기
				for(int j=0; j<4; j++) {
					Pair ncur = new Pair(cur.r+dr[j], cur.c+dc[j]);
					if(isInRange(ncur) && map[ncur.r][ncur.c]==0) {
						q.add(ncur);
						map[ncur.r][ncur.c] = 1; 
					}
				}
			}
			
			allDone = true; //모든 토마토가 익었다고 과정
			//맵을 탐색해 익지않은 과일이 있으면 allDone false로 바꾸고 2중 for문 탈출
			for(int i=0; i<N; i++) {
				for(int j=0; j<M; j++) {
					if(map[i][j]==0) {
							allDone = false;
							i=N; j=M; //2중 for문 탈출
							
							//익지 않은 과일이 있는데 q가 비어있으면 익을 수 없는 과일이 있다
							if(q.isEmpty()) {
								return -1;
							}
					}
				}
			}
			
			day++; //1일 증가
		}
		
		return day;
	}
	
	static boolean isInRange(Pair pos) {
		if(pos.r>=0 && pos.r<N && pos.c>=0 && pos.c<M)
			return true;
		
		return false;
	}
}

class Pair{
	int r;
	int c;
	
	public Pair(int r, int c) {
		this.r = r;
		this.c = c;
	}
}
~~~