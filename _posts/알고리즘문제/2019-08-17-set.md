---
title: (백준 11723)-집합
date: 2019-08-18T12:18:34+09:00
author: SWnomad
layout: post
categories: 알고리즘문제
tags:
  - 브루트포스
  - brute force
  - 자바
  - java
  - 백준
  - 집합
---

[백준 11723 - 집합](https://www.acmicpc.net/problem/11723){: target="_blank" }

## 1. 풀이 전략
* * *

<br>
### 1) 시뮬레이션

문제에서 설명하는 조건을 차근차근 빠짐없이 구현하면 끝이다. 특별히 요구하는 특정 알고리즘은 없다. 이런 문제를 시뮬레이션 문제라고 한다. 아무튼 문제의 조건에 따르면 집합 내부 원소의 순서가 상관이 없다. 또한 연산들의 성질에 따르면 중복 또한 생기지 않는다. 따라서 집합 S를 만들기 위해 HashSet을 사용한다.

그리고 한 줄의 연산을 입력받기 위해 StringBuilder와 StringTokenizer를 사용하면 된다. 이후에 연산자에 따라 집합 S에 원소를 추가, 삭제, 체크 등등을 하면 되는 간단한 알고리즘이다.

<br>

### 2) 비트 마스크

이 문제는 비트마스크를 사용해서도 풀 수 있다. 비트마스크에 관한 내용은 아래의 링크로 이어지는 포스팅에 설명해놓았으니, 읽어보기 바란다.

[비트마스크](https://swnomad.github.io/2019/08/19/bitmask/){: target="_blank" }

## 2. 소스 코드
* * *

### 1) 시물레이션

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.StringTokenizer;

class Main{
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//입력받을 연산의 수
		int M = Integer.parseInt(br.readLine());
		
		//중복 허용하지 않는 HashSet 객체 생성
		HashSet<Integer> S= new HashSet<>();
		
		//모든 출력 한 번에 모아서 출력하기위한 StringBuffer 객체 생성
		StringBuilder sb = new StringBuilder();
		
		//연산하기
		for(int i=0; i<M; i++) {
			StringTokenizer tk = new StringTokenizer(br.readLine());
			String op = tk.nextToken();//연산 읽어오기
			
			if(op.equals("add")) {// "add"면 set에 추가
				int num = Integer.parseInt(tk.nextToken());
				S.add(num);
			}else if(op.equals("remove")){// "remove"면 set에서 제거
				int num = Integer.parseInt(tk.nextToken());
				S.remove(num);
			}else if(op.equals("check")) {// "check"면 set에 있는지 체크
				int num = Integer.parseInt(tk.nextToken());
				if(S.contains(num)) {
					sb.append(1+"\n");
				}else {
					sb.append(0+"\n");
				}
			}else if(op.equals("toggle")) {// "toggle"이면 추가 or 삭제
				int num = Integer.parseInt(tk.nextToken());
				if(S.contains(num)) {
					S.remove(num);
				}else {
					S.add(num);
				}
			}else if(op.equals("all")) { // "all"이면 1~20 추가
				for(int j=1; j<=20; j++) {
					S.add(j);
				}
			}else if(op.equals("empty")) {// "empty"면 set 모든 원소 제거
				S.clear();
			}
		}
		
		// 결과 출력
		System.out.print(sb);
		
		//BufferedReader 해제
		br.close();
		
	}
}
~~~

### 2) 비트마스크

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

class Main{
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//입력받을 연산의 수
		int M = Integer.parseInt(br.readLine());
		
		//모든 출력 한 번에 모아서 출력하기위한 StringBuffer 객체 생성
		StringBuilder sb = new StringBuilder();
		
		int bitmask = 0;//공집합 비트마스크
		
		//연산하기
		for(int i=0; i<M; i++) {
			StringTokenizer tk = new StringTokenizer(br.readLine());
			String op = tk.nextToken();//연산 읽어오기
			
			if(op.equals("add")) {
				int num = Integer.parseInt(tk.nextToken());
				bitmask |= (1<<num); //num번째 bit를 1로
			}else if(op.equals("remove")){
				int num = Integer.parseInt(tk.nextToken());
				bitmask &= ~(1<<num); //num번째 bit를 0으로
			}else if(op.equals("check")) { //num번째 bit가 존재하면
				int num = Integer.parseInt(tk.nextToken());
				if((bitmask & (1<<num)) > 0) { //연산 결과 >0
					sb.append(1+"\n");
				}else { //아니면 연산결과는 0이다
					sb.append(0+"\n");
				}
			}else if(op.equals("toggle")) {
				int num = Integer.parseInt(tk.nextToken());
				bitmask ^= (1<<num); // XOR연산을 사용해서 num번째 bit 토글
			}else if(op.equals("all")) {
				bitmask |= (1<<21)-1; //22번째 비트만 1이고 아래로 모두 0인 2진수에서 1 빼면 1로만 채워진 21자리(0~20) 2진수가 된다.
			}else if(op.equals("empty")) {
				bitmask = 0; //모든 bit 0으로
			}
		}
		
		// 결과 출력
		System.out.print(sb);
		
		//BufferedReader 해제
		br.close();
		
	}
}
~~~

사실 위 두 알고리즘은 공간이나 시간 복잡도 면에서 큰 차이가 없다. 하지만 숫자가 많아지거나 집합이 원소가 될 수 있는 수의 범위가 넓어질수록 비트마스크 알고리즘이 큰 힘을 발휘한다. 비록 특정 조건이 주어지는 제한적인 문제에서만 사용할 수 있지만, 알아두면 도움이 될 수 있다.