---
title: (백준 6603)-로또
date: 2019-08-13T20:18:34+09:00
author: SWnomad
layout: post
categories: 알고리즘문제
tags:
  - 브루트포스
  - brute force
  - 자바
  - java
  - 백준
  - 6603
  - 순열
  - 로또
  - 재귀
---

[백준 6603 - 로또](https://www.acmicpc.net/problem/6603){: target="_blank" }

## 1. 풀이 전략
* * *

이 문제를 2가지 방법으로 풀어보았다. 1)순열 사용, 2)재귀호출

<br>

* 순열 사용

k개의 숫자 중 6개를 고르는 문제다. 

이 문제를 풀기 위한 핵심적인 알고리즘은 모든 순열을 계산하는 것이다. 아래 링크를 따라가면 다음 순열, 이전 순열에 대한 설명과 Java코드로 표현한 알고리즘을 볼 수 있다.

[순열](https://swnomad.github.io/2019/08/11/permutation/){: target="_blank" }

위 링크에서 나온 순열을 사용해서 문제를 풀어보자.

방법1) k개의 숫자를 next_permutation을 사용해 마지막 순열까지 구하면서 앞의 6개만 출력해본다. 그런데 이렇게 하면 같은 순열을 여러번 출력하게 된다. 그래서 생각한 것이, 6개가 오름차순일 때만, 그리고 뒤에 나머지 숫자들이 오름차순 혹은 내림차순일 때만 출력을 하는 것이다. 이렇게 하면 중복이 출력되지 않는다. 그런데 출력만 제한을 거는 것이지 결국은 모든 순열을 계산하는 과정을 거쳐야 한다. 하지만 6<k<13이라는 조건 때문에 k는 최대 12가 될 수 있고 이 때는 시간 복잡도가 O(12!*12)가 된다. 따라서 시간 초과가 난다.

방법2) 크기가 k인 배열을 하나 더 만든다. 그리고 index 0~5까지는 1로 초기화하고 나머지는 0으로 초기화한다. 이렇게 하면 1이 6개 있는 길이 k인 배열이 생긴다. 그리고 c에 대해서 모든 이전 순열(prev_permutation) 을 계산하면서 c[i]가 1인 i에 대해서만 S[i]를 출력해주면 된다. 이렇게 하면 오름차순, 사전순으로 출력된다. 그리고 시간복잡도 역시 O(N!*N/(6!*(k-6!)))으로 더욱 간단해진다.

<br>

* 재귀호출 사용

k개의 숫자들 중 가장 처음 숫자를 포함하는 경우, 포함하지 않는 경우로 나눌 수 있다. 포함하는 경우에는 리스트에 그 숫자를 추가, 포함하지 않는 경우에는 추가하지 않는다. 각각의 경우 서로 다른 함수 호출로 실행하는 재귀호출로 해결할 수 있다.

<br>

재귀호출 알고리즘은 크게 세 과정으로 분할하여 짜면 된다.

>1. 더 이상 진행해도 정답일 가능성이 없는 경우
>2. 정답 후보를 찾은 경우
>3. 아직 정답을 찾지 못하여 다음 순서를 호출하는 경우

각각의 과정으로 나누어 생각하면 비교적 쉽게 재귀호출 알고리즘을 짤 수 있다.

조금 더 자세한 내용은 아래의 링크로 이어지는 포스팅에서 볼 수 있다. 그렇게 길지 않으므로 시간적 여유가 된다면 한 번 봐두어 같은 유형의 문제에 계속해서 적용할 수 있다.

<br>
[재귀](https://swnomad.github.io/2019/08/11/recursion/){: target="_blank" }

<br>

## 2. 소스 코드
* * *

* 순열

~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

class Main{
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	
		while(true) {
			//한 줄 입력받기
			StringTokenizer tk = new StringTokenizer(br.readLine());
			
			int k = Integer.parseInt(tk.nextToken());
			
			//입력이 0이면 프로그램 종료
			if(k==0)
				break;
			
			//k개의 수를 위한 배열 생성 및 숫자 저장
			int[] S = new int[k];
			for(int i=0; i<k; i++) {
				S[i] = Integer.parseInt(tk.nextToken());
			}
			
			//S의 숫자 6개를 고르기 위한 6개의 1과 (k-6)개의 0을 가진 배열 생성
			int[] c = new int[k];
			for(int i=0; i<k; i++) {
				if(i<6) {
					c[i] = 1;
				}else {
					c[i] = 0;
				}
			}
			
			do {
				for(int i=0; i<k; i++) {
					if(c[i]==1) {
						System.out.print(S[i]+" ");
					}
				}
				System.out.println();
			}while(prev_permutation(c));
			
			System.out.println();
		}
		
	}
	
	public static boolean prev_permutation(int[] a) {
		
		//길이가 2보다 작으면 이전 순열 없으므로 false 리턴
		if(a.length<2)
			return false;
		
		//1. A[i-1]>A[i]를 만족하는 가장 큰 i를 찾는다.
		int i=a.length-1;
		while(i>0 && a[i-1]<=a[i])
			i--;
		
		//이미 모든 순열이 오름차순일 경우 이전 순열이 없고 이 때 i는 0이 되어있을 것이므로 false 반환
		if(i==0)
			return false;
		
		//2. i<=j이면서 A[i-1]>A[j]를 만족하는  가장 큰 A[j], 즉 가장 큰 j를 찾는다.
		int j=a.length-1;
		while(a[i-1]<=a[j])
			j--;
		
		//3. A[i-1]과 A[j]를 swap한다.
		int temp = a[i-1];
		a[i-1] = a[j];
		a[j] = temp;
		
		//4. A[i]부터 뒤로 있는 순열을 뒤집는다.
		j=a.length-1;
		while(i<j) {
			temp = a[i];
			a[i] = a[j];
			a[j] = temp;
			
			i++;
			j--;
		}
		
		return true;
	}
}
~~~

<br>
<br>

* 재귀호출

~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;

public class Main{
	
	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		while(true) {
			StringTokenizer tk = new StringTokenizer(br.readLine());
			int k = Integer.parseInt(tk.nextToken());
			
			//0이면 프로그램 종료
			if(k==0)
				break;
			
			//k개의 수의 집합 S
			int[] S = new int[k];
			for(int i=0; i<k; i++) {
				S[i] = Integer.parseInt(tk.nextToken());
			}
			
			recursion(S, 0, new ArrayList<>());
			System.out.println();
		}
		
	}
	
	static void recursion(int[] S, int idx, ArrayList<Integer> ans) {
		
		//정답 후보를 찾은 경우
		if(ans.size()==6) {
			for(int i=0; i<6; i++) {
				System.out.print(ans.get(i)+" ");
			}
			System.out.println();
			return;
		}
		
		//더 이상 정답일 가능성이 없는 경우
		if(idx >= S.length)
			return;
		
		//아직 정답을 찾지 못한 경우
		//1)S[idx]를 뽑는 경우
		ans.add(S[idx]);
		recursion(S, idx+1, ans);
		
		//2)S[idx]를 뽑지 않는 경우
		ans.remove(ans.size()-1);//1)에서 추가한 것을 다시 삭제
		recursion(S, idx+1, ans);
	}

}
~~~