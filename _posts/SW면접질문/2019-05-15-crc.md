---
title: 7. 순환 중복 검사(CRC-Cyclic Redundancy Check)
date: 2019-05-15T13:00:00+09:00
author: SWnomad
layout: post
categories: SW/IT지식
tags:
  - cyclic redundancy check
  - crc
  - checksum
  - crc8
  - xor
---

<br>
## 1. CRC란?
* * *

>CRC(Cyclic Redundancy Check)는 네트워크 등을 통하여 데이터를 전송할 때 전송된 데이터에 오류가 있는지를 확인하기 위한 체크값을 결정하는 방식을 말한다.
>데이터를 전송하기 전에 주어진 데이터의 값에 따라 CRC 값을 계산하여 데이터에 붙여 전송하고, 데이터 전송이 끝난 후 받은 데이터의 값으로 다시 CRC 값을 계산하게 된다. 이어서 두 값을 비교하고, 이 두 값이 다르면 데이터 전송 과정에서 잡음 등에 의해 오류가 덧붙여 전송된 것 임을 알 수 있다.

[출처 - 위키백과]

<br>

![8-1](/images/sw_interview/8-1.png){: width="100%" height="100%"}

<br>
기본적인 개념에서는 송신측에서 전송하고자 하는 Data를 Divisor로 나눈 나머지(remainder)가 CRC 값이다. 이 때, 우리가 n-bit 길이의 CRC를 사용하려고 하면 Divisor는 (n+1)-bit 길이를 써야한다. 그래야 Data를 Divisor로 나눈 나머지가 n-bit가 되기 때문이다. 이렇게 계산된 CRC를 Data에 붙여서 수신측으로 전송한다.

수신측에서는 메시지를 받으면 송신측과 같은 Divisor를 사용해 계산과정을 거친다. 방법은 송신측에서 보낸 Data 부분을 가지고 송신측과 같은 계산과정을 거쳐 계산된 CRC 값이 송신측에서 실어보낸 CRC값과 같은지 비교를 하면된다. 더 일반적으로 사용하는 방법은 CRC를 포함한 전체 메세지의 값을 Divisor로 나누어 나머지를 보는것이다. CRC는 Data를 Divisor로 나눈 나머지이기 때문에 (Data+CRC)/Divisor는 0이 되어야 정상이다. 따라서 나머지가 0이면 메세지를 받아들이고 0이 아니면 받아들이지 않는다. 

<br>
## 2. CRC에서의 나눗셈
* * *

CRC를 계산할 때의 나눗셈은 가환환(commutative ring)의 나눗셈에 기반한다. 가환환의 연산은 일반적인 사칙연산과 다르다. 예를들어 아래와 같은 방식으로 나눗셈을 진행한다.

![8-2](/images/sw_interview/8-2.png){: width="70%" height="70%"}

나눗셈의 몫은 x^2 + 1 이고 나머지는 -1, -1은 홀수이기 때문에 1이 된다. 계수가 홀수이면 무조건 1로, 짝수이면 0으로 된다.

CRC의 나눗셈도 가환환의 나눗셈을 따른다. Data의 bit는 다항식의 계수로써 생각하며, 이 때의 다항식들간의 나눗셈의 나머지가 CRC가 되는 것이다. 이런 의미에서 divisor는 generator polynomial라고도 불린다. 나눗셈의 예제를 한 번 보면서 파악해보자.

<p style="font-size: 15pt; font-family: Courier New, Courier, monospace; white-space:pre-wrap;"><span class="lightgraytext">ABCDEFGHIJKLMNOP</span>
<span style="color:red">11000010</span><span style="color:gray">00000000</span>
<span style="color:blue">100011101</span>
---------
010011001
 100011101
 ----------
 000101111
    100011101
    ---------
    001100101
      100011101
      ---------
      010001001
       100011101
       ---------
       0<span class="greentext">00001111</span> = 0x0F
</p>
	   
<br>
* Data(=divident) : 8bit

* generator polynomial(=divisor) : 9bit

divisor가 9bit인 것으로부터 우리가 계산하려는 것이 CRC의 bit수, 즉 8-bit CRC, 즉 CRC-8이라는 것을 알 수 있다.

나눗셈은 비트별 XOR 연산으로 진행하는데 그 전에 divident의 뒤에 0을 8bit만큼 붙여준다. 이후 연산은 아래의 과정에 따라 진행된다.

> 1. divisor의 가장 앞의 '1'과 divident의 가장 앞에있는 '1'을 align
> 2. 비트별 XOR 연산
> 3. 실제 Data column 라인(A~H)의 결과가 모두 0이면 계산 끝, 아니면 다시 1)의 과정 진행

계산이 끝났으면 padding zero bits(I~P) column 라인의 8개의 bit가 CRC이다. 위의 예제에서는 CRC는 0x0F=(0b00001111)이다.

매뉴얼한 계산은 알았는데, 결국은 이를 코드로 구현해야 한다. 코드로 구현할 때는 비트 이동 연산자를 사용하면 된다. 전체적인 방법은 아래 그림에 나온다.

![8-3](/images/sw_interview/8-3.png){: width="100%" height="100%"}

> 1. Data + padding '0' 8bit의 1이 8bit shift register의 MSB바로 앞에 오도록 위치시킨다.
> 2. divisor로 XOR 연산을 해준다.
> 3. 1) ~ 2)의 과정을 shift register 뒤에 더 이상 bit가 남아있지 않을 때 까지 한다.

위에서 매뉴얼하게 계산했던 예제를 가지고 진행해보면 같은 결과가 나온다. 이 알고리즘을 코드로 구현하는 것은 어렵지 않을 것이다.