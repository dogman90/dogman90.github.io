---
title: 12. 병합 정렬
date: 2018-11-12T22:10:04+09:00
author: SWnomad
layout: post
categories: 알고리즘
image: /images/2018/11/algorithm-thumbnail.jpg
tags:
  - merge sort
  - 병합
  - 병합 정렬
  - 알고리즘
  - 정렬
  - 파이썬
---
# 1. 문제 정의

* * *

병합 알고리즘은 다른 정렬 알고리즘과 마찬가지로 in/out이 리스트/정렬된 리스트 이다.

<img class="aligncenter wp-image-1341" src="/images/2018/11/no-name-10.jpg" alt="" width="615" height="154" srcset="/images/2018/11/no-name-10.jpg 783w, /images/2018/11/no-name-10-300x75.jpg 300w, /images/2018/11/no-name-10-768x192.jpg 768w" sizes="(max-width: 615px) 100vw, 615px" /> 

병합 정렬 알고리즘의 특별한 점은 재귀호출을 사용한다는 것이다.

재귀호출은 헷갈리면서 어느정도의 사고를 필요로 하는 알고리즘이므로 그림을 그려가며 따라가는 것이 이해가 쉽다.

&nbsp;

&nbsp;

# 2. 알고리즘

* * *

병합 정렬은 리스트를 반으로 나누어 각각 정렬하여 합하는 것이다. 합하는 과정에서도 순서를 생각한다.

<img class="aligncenter wp-image-1342" src="/images/2018/11/33.jpg" alt="" width="364" height="239" srcset="/images/2018/11/33.jpg 504w, /images/2018/11/33-300x197.jpg 300w" sizes="(max-width: 364px) 100vw, 364px" /> 

반으로 나뉜 리스트가 또 반으로 나뉘고 마지막 하나만 남을 때 까지 반으로 나뉜다. 이 부분에서 재귀 호출을 사용하는 것이다.

코드를 살펴보자.

~~~ python
def merge_sort(a):
    n=len(a)

    if n<=1:
        return a
    ### 일단 마지막까지 쪼개져서 1개가 남은 이후에는 그 값을 리턴안 이후 이 부분의 코드로는 다시 돌아오지 않는다.

    a1 = merge_sort(a[:n//2]) # 리스트를 반으로
    a2 = merge_sort(a[n//2:]) # 리스트를 반으로

    result = [] # 정렬된 리스트를 담을 그릇
    while a1 and a2: # a1과 a2 중 하나가 빌 때 까지
        if a1[0]< a2[0]: # a1[0]과 a2[0]을 계속 비교하여 정렬
            result.append(a1.pop(0))
        else:
            result.append(a2.pop(0))

    ### a1이나 a2 중 하나가 남았으면 차례대로 result의 뒤에 추가
    while a1:
        result.append(a1.pop(0))
    while a2:
        result.append(a2.pop(0))

    return result

list1 = [11,9,23,20,4,1,14]
list2 = [5,4,3,2,1]

print(merge_sort(list1)) # [1,4,9,11,14,20,23]
print(merge_sort(list2)) # [1,2,3,4,5]
~~~

헷갈리면 보고 또 보자. 결국은 이해하게 될 것이다.

&nbsp;

&nbsp;

# 3. 알고리즘 효율

* * *

병합 정렬 알고리즘의 핵심은 데이터를 계속해서 잘게 나누어 재귀호출을 이용한다는 것이다. 분할한다 하여 분할 정복 이라고도 부르는데, 이런 방법은 알고리즘의 효율을 높이는 데에도 크게 기여한다.

병합 정렬 알고리즘의 계산 복잡도는 O(nlog(n))이며 이는 O(n^2)의 계산복잡도를 가졌던 앞선 정렬 알고리즘들 보다 계산복잡도가 낮은 더욱 효율적인 알고리즘이다.

즉, 데이터의 수가 많을수록 병합 정렬은 그 힘을 발휘한다.