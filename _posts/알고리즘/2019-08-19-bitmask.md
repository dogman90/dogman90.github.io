---
title: 비트 마스크(Bit Mask)
date: 2019-08-19T18:24:34+09:00
author: SWnomad
layout: post
categories: 알고리즘
tags:
  - 알고리즘
  - algorithm
  - bit
  - mask
  - 비트
  - 마스크
---

## 1. 비트 연산
* * *

비트 연산이란 어떤 자료 혹은 자료들에 대해서 비트별로 연산을 하는 것이다.

비트 연산에는 총 4가지가 있다.

|---|---|----|-----|-----|-----|
| A | B | ~A | A&B | A\|B | A^B |
|---|---|----|-----|-----|-----|
|0|0|1|0|0|0|
|0|1|1|0|1|1|
|1|0|0|0|1|1|
|1|1|0|1|1|0|
|---|---|----|-----|-----|-----|

<br>

~~~ java
byte a = 17; //00010001
byte b = 4;  //00000100

System.out.println(~a);  //11101110 -> -18
System.out.println(a&b); //00000000 -> 0
System.out.println(a|b); //00010101 -> 21
System.out.println(a^b); //00010101 -> 21
~~~

<br>

byte형 정수 a와 b는 각각 17, 4를 저장하고있다. 주석에는 이들의 2진수 형태를 표현했다. 아래에서 4가지의 연산 결과를 출력해보면 직접 계산한 결과와 똑같이 나온다.

주의할 것이 있다. a와 b가 byte가 아니라 int형이라면 not 연산의 결과는 다르게 나올 수 있다. a가 int형이면 17은 00000000000000000000000000010001이다. 이를 ~연산을 하면 11111111111111111111111111101110가 되어 전혀 다른 숫자가 나온다. 즉, not 연산은 자료형에 따라 결과가 달라진다.

<br>

<br>

## 2. 비트 이동 연산
* * *

|---|-------------------|
|<<a|왼쪽으로 a 비트 만큼 이동|
|>>a|오른쪽으로 a 비트 만큼 이동|

<br>

비트를 한 칸씩 왼쪽으로 당긴다는 것은 2진수에서 한 자리씩 위로 올라가는 것이다. 따라서 왼쪽으로 한 비트를 밀면 크기가 2배 만큼 커진다.

비트를 한 칸씩 오른쪽으로 당긴다는 것은 2진수에서 한 자리씩 밑으로 내리는 것이다. 따라서 오른쪽으로 한 비트를 밀면 크기가 2배 만큼 작아진다.

정리하자면, a<<b는 a*2^b이고, a>>b는 a/2^b이다.

~~~ java
byte a = 54; //0011 0110
System.out.println(a<<4); // 54 * 2^4 = 864 
System.out.println(a>>4); // 54 / 2^4 = 3
~~~

<br>

## 3. 비트 마스크
* * *

비트 마스크는 0~N-1의 정수로만 이루어진 집합을 하나의 정수로 나타낼 수 있도록 해준다.

<br>
집합 {1,3,4,5,9}가 있다. 이 집합은 정수 570으로 간단하게 표기할 수 있다. 왜냐하면 570 = 2^1 + 2^3 + 2^4 + 2^5 + 2^9 이기 때문이다. 즉, 집합의 원소를 2진수 비트 자릿수로 생각하는 것이다. 차라리 배열을 쓰지 라고 생각할 수 있다. 그런데, 정수는 배열에 비해 메모리 공간을 훨씬 작게 차지할 뿐만 아니라, 더 간단하고 다양한 조작이 가능하다.

<br>

### 1) 집합이 n을 포함하는지 검사하기
<br>
비트마스크로 표현되는 집합이 특정한 숫자를 포함하고 있는지 간단히 확인할 수 있는 방법이 있다. 가령 배열 {1,3,4,5,9}가 n을 포함하는지 알아보고 싶다면 570 & (1<<n)의 결과가 2^n이 나오는지 보면 된다.

예를 몇가지 보자. 570은 2진수로 1000111010(2)이다.

<br>
ex)1 포함하는지 검사

<br>
1000111010(2)
0000000010(2)
-------------
0000000010(2)는 2^1이므로 1을 포함한다.

<br>

ex) 6을 포함하는지 검사

<br>
1000111010(2)
0001000000(2)
-------------
0000000000(2)는 0이므로 6을 포함하지 않는다.

<br>
<br>

### 2) 집합에 n 추가하기
<br>

위와 같은 논리로 어떤 집합에 특정 숫자를 포함하고자 한다. 예를 들어 {1,3,4,5,9}에 n을 추가하고 싶다면 570 | (1<<<n)을 해주면 된다. 그 결과가 n을 추가한 새로운 집합이 된다.

<br>
ex) 7 추가하기

<br>
1000111010(2)
0010000000(2)
-------------
1010111010(2) 는 698이다. 따라서 집합에 7을 추가하면 새로운 정수 698이 그 집합을 표현하게 된다.

<br>
<br>

### 3) 집합에서 n 제거하기
<br>

특정 수를 제거하려면 (원래의 정수) & ~(1<<n) 연산을 해주면 된다. 그럼 n자리 비트를 무조건 0으로 만들어준다.

### 4) 숫자 n 토글(있으면 제거, 없으면 추가)
<br>

(원래의 정수) ^ (1<<n)을 해주면 된다. 나머지 자리 숫자는 그대로 일것이고, n번째 비트는 1이었다면 0이, 0이었다면 1이 된다.

<br>

아래 링크로 이어지는 문제는 비트마스크를 사용하여 풀 수 있는 대표적인 알고리즘 문제이다.

[백준 11723 - 집합](https://www.acmicpc.net/problem/11723){: target="_blank" }