---
title: 그래프
date: 2019-08-24T16:28:34+09:00
author: SWnomad
layout: post
categories: 알고리즘
tags:
  - 그래프
  - graph
  - 정점
  - 간선
  - 노드
  - node
  - edge
  - 인접행렬
  - 인접리스트
  - 경로
  - 가중치
---

## 1. 그래프란?
***

그래프는 하나의 *자료구조*이다.

정점과 간선이 있으면 그래프라고 한다.

<br>
![1](/images/algorithm/graph/1.png){: width="30%" height="30%"}
<br>

+ 1. 정점(Node, Vertext) : 점을 나타낸다.

	- 위 그래프에는 1, 2, 3 세 개의 정점이 있다.

+ 2. 간선(Edge) : 정점 사이의 연결관계. 점과 점 사이를 잇는 선
	
	- 위 그래프에는 2->1, 3->1, 2->3 세 개의 간선이 존재한다.

<br>
+ 3. 경로(Path) : 하나의 정점(시작점)에서 다른 정점(도착점)으로 가기 위한 간선들의 나열

<br>	
![2](/images/algorithm/graph/2.png){: width="30%" height="30%"}

<br>
ex) A->B의 경로는 A->B, A->C->B, A->C->E->B, A->C->D->E->B 네 개가 있다.

<br>
그래프 내에서 특정 정점 사이 경로들 중에서 최단 경로를 구하는 문제가 자주 출제된다. 특히 각각의 간선에 가중치(weight)가 존재한다면 이 가중치의 합이 최소가 되는 경로를 최단 경로라고 한다.

+ 4. 사이클(cycle) : 시작점과 도착점이 같은 경로

<br>
![3](/images/algorithm/graph/3.png){: width="30%" height="30%"}

<br>
ex) A->A 사이클은 A->C->B->A, A->C->E->B->A, A->C->D->E->B->A 세 가지가 존재한다.

+ 5. 간선의 방향과 수

<br>
방향이 있는 간선은 한 쪽으로만 움직일 수 있음을 의미하며 일반적으로 화살표로 나타낸다.

방향이 없는 간선은 양 방향으로 움직일 수 있음을 의미하며 일반적으로 직선으로 나타낸다. 방향이 없는 간선은 배열에 저장할 때 각각의 방향에 대해 나누어 저장해주어야한다.

정점 사이에 간선이 여러 개 있을 수도 있다. 이 때에는 모든 간선에 대한 경우의 수를 고려해주어야한다.
<br>

+ 6. 가중치

<br>
![4](/images/algorithm/graph/4.png){: width="30%" height="30%"}

<br>
간선은 가중치라는 것을 가진다. 일반적으로 알고리즘 문제에서는 비용, 걸리는 시간 등으로 나타난다.
<br>

<br>
## 2. 그래프의 표현
***

프로그래밍에서 그래프를 저장한다는 것은 정점과 간선을 저장하는 것이다. 정점은 갯수 만큼의 크기를 가지는 배열에 저장할 수 있다. 그러나 간선은 문제에 따라 다른 형태로 저장해야한다.

간선을 저장하기 위한 인접행렬, 인접리스트 두 가지 방법이 있다.

<br>

### 1) 인접행렬

노드의 갯수를 N이라 하면 N*N 2차원 배열을 생성한다. A[i][j]에 노드 i에서 노드 j로 가는 가중치를 저장한다. i에서 j로 가는 경로가 존재하지 않을 경우 0을 넣어준다.

### 2) 인접리스트

정점갯수 크기의 배열을 만든다. 배열의 index는 각각의 정점 번호에 해당한다. 배열은 index에 해당하는 정점에서 갈 수 있는 모든 정점 번호들을 요소로 가진다. 이 때, 정점 사이 간선의 수는 미리 알 수 없으므로 동적으로 변경할 수 있는 리스트 객체를 사용해야한다. C++의 경우에는 vector, Java의 경우에는 ArrayList를 사용할 수 있다.

말하자면, Java의 경우 ArrayList<Integer>[] 배열 같은 것이다. 가중치가 존재한다면 ArrayList<Pair<Integer,Integer>>[] 배열을 만들어 이어지는 정점 번호와 그에대한 가중치를 하나의 Pair 객체로 저장할 수 있다.

<br>
<br>

인접 행렬과 인접 리스트를 비교해보자. 정점의 수가 N, 간선의 수가 E인 그래프 G(V,E)에 대해서

1) 정점 u에서 정점 v로 가는 간선이 존재하는지 알아볼 경우

인접 행렬에서는 A[u][v]가 1인지만 보면 되므로 시간복잡도가 O(1)이 된다. 인접 리스트의 경우는 A[u]에 해당하는 리스트 객체를 차례대로 훑으면서 v가 존재하는지 찾아야 하므로 O(A[u]의 갯수) 시간복잡도를 가진다. 따라서 이 경우에는 인접 행렬이 유리하다.

2) 정점 u에서 갈 수 있는 모든 정점을 알아볼 경우

인접 행렬의 경우 A[u][1] ~ A[u][N]까지 탐색하면서 1인 경우를 찾아야 한다. 인접 리스트의 경우 A[u]에 해당하는 객체를 불러오기만 하면 된다. 따라서 이 경우에는 인접리스트가 유리하다.

3) 공간 복잡도

공간 복잡도의 경우 인접 행렬은 O(N^2), 인접 리스트의 경우 O(E)가 된다. 따라서 정점의 갯수가 매우 많은 경우 인접 행렬보다는 인접 리스트가 유리하다.

<br>
위에서 말하고자 하는 것은, 문제의 조건에 따라 무엇을 사용해야 할지 유연하게 판단해야 한다는 것이다.

