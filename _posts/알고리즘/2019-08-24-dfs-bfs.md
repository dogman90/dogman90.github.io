---
title: DFS와 BFS
date: 2019-08-24T18:28:34+09:00
author: SWnomad
layout: post
categories: 알고리즘
tags:
  - 그래프
  - graph
  - 정점
  - 간선
  - 노드
  - node
  - edge
  - 인접행렬
  - 인접리스트
  - 경로
  - 가중치
  - dfs
  - bfs
---

## 1. 그래프의 탐색
***

우리가 그래프를 탐색하는 목적은 *하나의 정점에서 시작해서 모든 정점을 한 번씩 방문하는 경로를 찾는 것*이다. DFS와 BFS는 그래프를 탐색하는 가장 유명한 두 가지 방법이다.

![1](/images/algorithm/dfsbfs/1.gif){: width="30%" height="30%"}

<br>
위 그림만 보아도 DFS와 BFS가 탐색을 하는 방법에 대한 차이를 쉽게 알 수 있다.

### 1) 깊이 우선 탐색(DFS)
<br>

한 정점에서 시작해서 갈 수 있는 만큼 최대한 많이 들어가고 갈 수 없을 때가 되어서야 이전 정점으로 돌아와서 다시 탐색을 시작한다. 정점을 저장하기 위한 자료구조로 스택(stack)을 사용한다. 방문을 하는 순서대로 정점 번호를 스택에 저장하고, 더 이상 갈 수가 없으면 스택에서 버린다. 스택에 아무것도 남아있지 않으면 모든 정점을 방문한 것이므로 탐색을 종료한다.

<br>
DFS를 구현하는 가장 쉬운 방법은 재귀 호출을 사용하는 것이다.

<br>
~~~ java
//인접행렬 사용
static void dfs(int x) {
	c[x] = true;
	System.out.print(x+" ");
	
	for(int i=1; i<=N; i++) {
		if(A[x][i]==1 && !c[i]) {
			dfs(i);
		}
	}
}

//인접리스트 사용
static void dfs(int x) {
	c[x] = true; //시작점 방문
	System.out.print(x+" ");
	
	for(int i=0; i<arr[x].size(); i++) {
		int y = arr[x].get(i); //x에서 갈 수 있는 정점 탐색
		if(!c[y]) { //아직 방문하지 않은 정점이면
			dfs(y); //해당 정점 방문
		}
	}
}
~~~

정점을 저장하기 위해 사용한 자료구조에 따라 함수가 약간 다르게 구현된다. 따라서 원리는 완전히 동일하지만 시간 복잡도가 달라지게 된다.

1) 인접행렬의 경우 x에서 갈 수 있는 모든 정점을 찾기위해 1~N 모든 정점을 살펴봐야 한다. 이것을 정점 N개에 대해 실행하므로 시간 복잡도는 O(N^2)이다.

2) 인접리스트의 경우 N개의 정점에 대해서 갈 수 있는 정점을 살펴보는 것은 맞다. 그런데 지금은 갈 수 있는 정점이 리스트에 저장되어 있으므로 이것만 살펴보면 된다. 결국 갈 수 있는 모든 간선 수의 합을 E라고 하면, 시간 복잡도는 O(V+E)가 된다.

<br>

### 2) 넓이 우선 탐색(BFS)
<br>

자료구조 큐(queue)를 사용해서 갈 수 있는 정점들을 저장하면 된다. 반드시 큐에 저장할 때 해당 정점의 방문 처리를 해주어야한다. 왜냐하면 다음 정점을 탐색할 때 방문 처리를 해주지 않았지만 이미 큐에 들어있는 정점이 또 다시 추가될 수 있기 때문이다. 큐에서 하나씩 빼내어 해당 정점에서 갈 수 있는 모든 정점을 추가한다. 또 큐에서 하나를 빼내어 해당 정점에서 갈 수 있는 모든 정점을 추가한다. 큐에 아무것도 남아있지 않게 되면 탐색을 종료한다.

<br>
자바 코드를 통한 BFS의 구현을 보자. 이번에는 인접리스트를 사용한 그래프의 저장만 구현해본다.

<br>
~~~ java
static void bfs(int x) {
	Queue<Integer> q = new LinkedList<>();
	
	c[x] = true; q.add(x); //시작점 방문
	System.out.print(x+" ");
	
	while(!q.isEmpty()) {
		x = q.remove(); //가장 앞의 원소 빼기
		for(int i=0; i<arr[x].size(); i++) {
			int y = arr[x].get(i); //x에서 갈 수 있는 정점 탐색
			if(!c[y]) { //아직 방문하지 않은 정점이면
				c[y] = true; q.add(y); //해당 정점 방문
				System.out.print(y+" ");
			}
		}
	}
}
~~~

<br>
시간 복잡도의 경우는 인접행렬, 인접리스트를 사용할 경우 DFS와 완전히 동일하다.

그럼 예제 문제를 하나 풀어보자.

[백준 1260 - DFS와 BFS](https://www.acmicpc.net/problem/1260){: target="_blank" }

<br>

위에서 설명한 dfs와 bfs를 그대로 가져다쓰면 된다.

~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer tk = new StringTokenizer(br.readLine());
		
		//정점, 간선 수, 탐색 시작점
		N = Integer.parseInt(tk.nextToken());
		M = Integer.parseInt(tk.nextToken());
		int start = Integer.parseInt(tk.nextToken());
		
		//방문 체크 배열
		c = new boolean[N+1];
		
		//각 노드별 인접리스트 객체 생성
		arr = new ArrayList[N+1];
		for(int i=1; i<=N; i++) {
			arr[i] = new ArrayList<Integer>();
		}
		
		//인접리스트에 모든 경로 추가
		for(int i=0; i<M; i++) {
			tk = new StringTokenizer(br.readLine());
			int u = Integer.parseInt(tk.nextToken());
			int v = Integer.parseInt(tk.nextToken());
			arr[u].add(v);
			arr[v].add(u);
		}
		
		for(int i=1; i<=N; i++) {
			Collections.sort(arr[i]);
		}
		
		dfs(start);
		
		System.out.println(); //bfs경우 출력을 위해 한 줄 개행
		c = new boolean[N+1]; //방문 체크 배열 다시 초기화
		bfs(start);
		
	}
	
	static int N;
	static int M;
	static boolean[] c;
	static ArrayList<Integer>[] arr;
	
	static void dfs(int x) {
		c[x] = true;
		System.out.print(x+" ");
		
		for(int i=0; i<arr[x].size(); i++) {
			int y = arr[x].get(i);
			if(!c[y]) {
				dfs(y);
			}
		}
	}
	
	static void bfs(int x) {
		Queue<Integer> q = new LinkedList<>();
		
		c[x] = true; q.add(x); //시작점 방문
		System.out.print(x+" ");
		
		while(!q.isEmpty()) {
			x = q.remove(); //가장 앞의 원소 빼기
			for(int i=0; i<arr[x].size(); i++) {
				int y = arr[x].get(i); //x에서 갈 수 있는 정점 탐색
				if(!c[y]) {
					c[y] = true; q.add(y); //해당 정점 방문
					System.out.print(y+" ");
				}
			}
		}
	}
	
}
~~~