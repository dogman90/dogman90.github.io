---
title: N과 M
date: 2019-08-21T18:24:34+09:00
author: SWnomad
layout: post
categories: 알고리즘
tags:
  - 알고리즘
  - algorithm
  - 백준
  - 재귀
  - N과 M
---

<br>

여기서는 N개의 숫자들 중 M개의 숫자를 골라서 정렬하고 출력해주는 알고리즘들에 대해 다룰 것이다. 중복 여부, 오름차순, 내림차순 등등의 조건이 달라지면서 코드가 조금씩 달라진다. 그러나 핵심은 재귀호출을 사용하는 것이다. N개의 수들 중 M개를 고르는 문제를 유형별로 알아보고 코드도 정리할 것이다.

### N과 M(1)

<br>
[백준 15649 - N과 M(1)](https://www.acmicpc.net/problem/15649){: target="_blank" }

* 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
<br>

크기 M인 버퍼가 있다면 가장 처음에 1~M 중에서 하나를 고르고 그 다음 index로 넘어가서 사용한 것을 제외한 수들 중 하나를 고르면 된다. 이미 사용한것을 제외하기 위해 체크를 하는 배열 c를 만든다. 또한 서택한 숫자를 저장하기 위한 배열 a를 만든다. 코드로 표현하면 아래와 같다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//N, M 입력
		StringTokenizer tk = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		sb = new StringBuilder(); //출력 문자열 저장 버퍼
		
		a = new int[M]; //숫자 M개 저장 버퍼
		c = new boolean[N+1]; //1~N까지 숫자 사용 여부 체크 버퍼
		
		recursion(N, M, 0);
		
		System.out.print(sb);
		
	}
	
	static int[] a;
	static boolean[] c;
	static StringBuilder sb;
	
	static void recursion(int N, int M, int idx) {
		
		if(idx==M) { //idx가 M이면 M개의 수를 다 고른 것이므로 출력 버퍼에 추가
			for(int i=0; i<M; i++) {
				sb.append(a[i]+" ");
			}
			sb.append("\n");
			
			return;
		}
		
		for(int i=1; i<=N; i++) {
			if(c[i]) //숫자 i가 이미 사용됐으면 넘어가기 
				continue;
			
			//숫자 i 사용하지 않았으면 아래 과정 실행
			c[i] = true; a[idx] = i; //숫자 i 사용하기
			recursion(N, M, idx+1); //다음 index 수 고르기
			c[i] = false; //이번 자리에 사용한 숫자 i를 사용 취소하고 다음 i 고르기
			
			//c[i] = false;를 통해 사용을 취소하지 않으면 더 이상 사용할 수 없게 돼버린다.
		}
	}
}
~~~

<br>
### N과 M(2)

<br>
[백준 15650 - N과 M(2)](https://www.acmicpc.net/problem/15650){: target="_blank" }

* 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
* 고른 수열은 오름차순이어야 한다.
<br>

N과 M(1)과 다른 것은 오름차순만 허용한다는 것이다. 따라서 뒤에 있는 index의 수를 선택할 때는 이번에 선택한 숫자 다음 숫자부터만 탐색하면 되고, 이를 위해 재귀함수에 start라는 매개변수를 하나 더 추가한다. 또한 중복 가능성이 없으므로 이전 사용 여부를 체크하는 배열 c가 필요 없어진다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//N, M 입력
		StringTokenizer tk = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		sb = new StringBuilder(); //출력 문자열 저장 버퍼
		
		a = new int[M]; //숫자 M개 저장 버퍼
		
		recursion(N, M, 0, 1);
		
		System.out.print(sb);
		
	}
	
	static int[] a;
	static StringBuilder sb;
	
	static void recursion(int N, int M, int idx, int start) {
		
		if(idx==M) { //idx가 M이면 M개의 수 출력
			for(int i=0; i<M; i++) {
				sb.append(a[i]+" ");
			}
			sb.append("\n");
			
			return;
		}
		
		for(int i=start; i<=N; i++) {			
			a[idx] = i; //숫자 i 사용하기
			recursion(N, M, idx+1, i+1); //i를 추가했으면 그 뒤에 올 숫자는 i+1부터이므로 start에 i+1을 넣어준다
		}
	}
}
~~~

<br>
### N과 M(3)

<br>
[백준 15651 - N과 M(3)](https://www.acmicpc.net/problem/15651){: target="_blank" }

* 1부터 N까지 자연수 중에서 M개를 고른 수열
* 같은 수를 여러 번 골라도 된다.
<br>

N과 M(1)과 유일하게 다른 것은 같은 수를 여러 번 골라도 되므로 사용 여부를 체크하는 배열인 c가 필요 없다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//N, M 입력
		StringTokenizer tk = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		sb = new StringBuilder(); //출력 문자열 저장 버퍼
		
		a = new int[M]; //숫자 M개 저장 버퍼
		
		recursion(N, M, 0);
		
		System.out.print(sb);
		
	}
	
	static int[] a;
	static StringBuilder sb;
	
	static void recursion(int N, int M, int idx) {
		
		if(idx==M) { //idx가 M이면 M개의 수 출력
			for(int i=0; i<M; i++) {
				sb.append(a[i]+" ");
			}
			sb.append("\n");
			
			return;
		}
		
		for(int i=1; i<=N; i++) {
			a[idx] = i; //숫자 i 사용하기
			recursion(N, M, idx+1); //다음 index로 넘어가기
		}
	}
}
~~~

<br>
### N과 M(4)

<br>
[백준 15652 - N과 M(4)](https://www.acmicpc.net/problem/15652){: target="_blank" }

* 1부터 N까지 자연수 중에서 M개를 고른 수열
* 같은 수를 여러 번 골라도 된다.
* 고른 수열은 비내림차순이어야 한다.
<br>

N과 M(3)과 유일하게 다른 것은 비내림차순이란 것이다. 즉, 뒤의 index 숫자가 앞의 index 숫자보다 크거나 같아야 한다는 것이다. 작지만 않으면 된다. 따라서 start 매개변수를 추가해서 이번에 고른 숫자부터 for문이 시작되게 하면 된다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//N, M 입력
		StringTokenizer tk = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		sb = new StringBuilder(); //출력 문자열 저장 버퍼
		
		a = new int[M]; //숫자 M개 저장 버퍼
		
		recursion(N, M, 0, 1);
		
		System.out.print(sb);
		
	}
	
	static int[] a;
	static StringBuilder sb;
	
	static void recursion(int N, int M, int idx, int start) {
		
		if(idx==M) { //idx가 M이면 M개의 수 출력
			for(int i=0; i<M; i++) {
				sb.append(a[i]+" ");
			}
			sb.append("\n");
			
			return;
		}
		
		for(int i=start; i<=N; i++) {
			a[idx] = i; //숫자 i 사용하기
			recursion(N, M, idx+1, i); //다음 index로 넘어가기
		}
	}
}
~~~

<br>
### N과 M(5)

<br>
[백준 15654 - N과 M(5)](https://www.acmicpc.net/problem/15654){: target="_blank" }

* N개의 자연수 중에서 M개를 고른 수열
<br>

이번에는 1~N까지의 자연수 중 M개를 고르는 것이 아니라 N개의 입력된 자연수 중 M개의 숫자를 골라서 사전순으로 출력하는 것이다. 이번에는 중복을 허용하지 않으므로 선택여부를 체크하는 배열이 필요하다. 하지만 기본 원리는 N과 M(1)과 같다. 다만 N개의 수가 1~N이 아닌 N개의 입력된 수라는 점만 다르다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//N, M 입력
		StringTokenizer tk = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		//N개 숫자 입력
		nums = new int[N];
		tk = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(tk.nextToken());
		}
		
		Arrays.sort(nums); //nums 배열 오름차순으로 정렬
		
		sb = new StringBuilder(); //출력 문자열 저장 버퍼
		selectedNums = new int[M]; //숫자 M개 저장 버퍼
		
		c = new boolean[N]; //이미 선택된 수인지 체크하기 위한 배열
		
		recursion(N, M, 0);
		
		System.out.print(sb);
		
	}
	
	static int[] nums;
	static int[] selectedNums;
	static boolean[] c;
	
	static StringBuilder sb;
	
	static void recursion(int N, int M, int idx) {
		
		if(idx==M) { //M개 수 다 골랐으면 출력 버퍼에 저장
			for(int i=0; i<M; i++) {
				sb.append(selectedNums[i]+" ");
			}
			sb.append("\n");
			
			return;
		}
		
		for(int i=0; i<N; i++) {
			if(c[i]) continue; //i번째 수 선택했으면 넘어가기
			
			//i번째 수 선택
			c[i] = true;
			selectedNums[idx] = nums[i];
			recursion(N, M, idx+1); //다음 index의 수 선택
			
			//i번째 수 선택 취소
			c[i] = false;
		}
	}
}
~~~

<br>
### N과 M(6)

<br>
[백준 15655 - N과 M(6)](https://www.acmicpc.net/problem/15655){: target="_blank" }

* N개의 자연수 중에서 M개를 고른 수열
* 고른 수열은 오름차순이어야 한다.
<br>

N개의 숫자들 중 M개를 고르는데, 오름차순이어야 한다. N과M(5)와 다른 점은 오름차순이라는 것 뿐이므로, start 매개변수를 사용해서 for문의 시작점을 이번에 고른 index 숫자의 다음 index로 설정해주면 된다. 단, 이렇게 할 경우 중복은 일어날 수 없으므로 체크배열 c가 필요없게 된다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//N, M 입력
		StringTokenizer tk = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		//N개 숫자 입력
		nums = new int[N];
		tk = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(tk.nextToken());
		}
		
		Arrays.sort(nums); //nums 배열 오름차순으로 정렬
		
		sb = new StringBuilder(); //출력 문자열 저장 버퍼
		selectedNums = new int[M]; //숫자 M개 저장 버퍼
		
		recursion(N, M, 0, 0);
		
		System.out.print(sb);
		
	}
	
	static int[] nums;
	static int[] selectedNums;
	
	static StringBuilder sb;
	
	static void recursion(int N, int M, int idx, int start) {
		
		if(idx==M) { //M개 수 다 골랐으면 출력 버퍼에 저장
			for(int i=0; i<M; i++) {
				sb.append(selectedNums[i]+" ");
			}
			sb.append("\n");
			
			return;
		}
		
		for(int i=start; i<N; i++) {
			selectedNums[idx] = nums[i];
			recursion(N, M, idx+1, i+1); //다음 index의 수 선택. for문 시작점을 i+1로
		}
	}
}
~~~

<br>
### N과 M(7)

<br>
[백준 15656 - N과 M(7)](https://www.acmicpc.net/problem/15656){: target="_blank" }

* N개의 자연수 중에서 M개를 고른 수열
* 같은 수를 여러 번 골라도 된다.
<br>

N개의 수 중 M개를 고르는데, 중복을 허용한다. N과 M(5)와 다른점이 중복을 허용한다는 것이다. 따라서 이미 사용한 수를 뛰어넘기 위한 체크 배열 c를 삭제해주면 된다. 

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//N, M 입력
		StringTokenizer tk = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		//N개 숫자 입력
		nums = new int[N];
		tk = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(tk.nextToken());
		}
		
		Arrays.sort(nums); //nums 배열 오름차순으로 정렬
		
		sb = new StringBuilder(); //출력 문자열 저장 버퍼
		selectedNums = new int[M]; //숫자 M개 저장 버퍼
		
		recursion(N, M, 0);
		
		System.out.print(sb);
		
	}
	
	static int[] nums;
	static int[] selectedNums;
	
	static StringBuilder sb;
	
	static void recursion(int N, int M, int idx) {
		
		if(idx==M) { //M개 수 다 골랐으면 출력 버퍼에 저장
			for(int i=0; i<M; i++) {
				sb.append(selectedNums[i]+" ");
			}
			sb.append("\n");
			
			return;
		}
		
		for(int i=0; i<N; i++) {			
			//i번째 수 선택
			selectedNums[idx] = nums[i];
			recursion(N, M, idx+1); //다음 index의 수 선택
		}
	}
}
~~~

<br>
### N과 M(8)

<br>
[백준 15657 - N과 M(8)](https://www.acmicpc.net/problem/15657){: target="_blank" }

* N개의 자연수 중에서 M개를 고른 수열
* 같은 수를 여러 번 골라도 된다.
* 고른 수열은 비내림차순이어야 한다.
<br>

중복을 허용하지만 비내림차순이어야한다. N과 M(7)과 다른 점은 비내림차순이란 점이다. 즉, 뒤에 있는 수자가 앞에 있는 숫자보다 작지만 않으면 된다. 크거나 같아야 한다. 이를 위해 재귀 함수에 start라는 매개변수를 추가하여 for문이 이번에 고른 수부터 탐색을 시작하도록 하면 된다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//N, M 입력
		StringTokenizer tk = new StringTokenizer(br.readLine());
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		//N개 숫자 입력
		nums = new int[N];
		tk = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(tk.nextToken());
		}
		
		Arrays.sort(nums); //nums 배열 오름차순으로 정렬
		
		sb = new StringBuilder(); //출력 문자열 저장 버퍼
		selectedNums = new int[M]; //숫자 M개 저장 버퍼
		
		recursion(N, M, 0, 0);
		
		System.out.print(sb);
		
	}
	
	static int[] nums;
	static int[] selectedNums;
	
	static StringBuilder sb;
	
	static void recursion(int N, int M, int idx, int start) {
		
		if(idx==M) { //M개 수 다 골랐으면 출력 버퍼에 저장
			for(int i=0; i<M; i++) {
				sb.append(selectedNums[i]+" ");
			}
			sb.append("\n");
			
			return;
		}
		
		for(int i=start; i<N; i++) {			
			//i번째 수 선택
			selectedNums[idx] = nums[i];
			recursion(N, M, idx+1, i); //다음 index의 수 선택
		}
	}
}
~~~

<br>
### N과 M(9)

<br>
[백준 15663 - N과 M(9)](https://www.acmicpc.net/problem/15663){: target="_blank" }

* N개의 자연수 중에서 M개를 고른 수열
<br>

N개의 입력된 수 중에서 M개를 고르는 문제인데, 이번에는 지금까지와는 다르게 입력된 숫자들 중에서 중복된 것이 존재할 수 있다. 그런데 출력할 때 중복 출력은 허용하지 않는다. 따라서 같은 숫자가 여러개면 1개 빼고 모두 지우고 시작하면 된다고 생각할 수 있다. 그러나 중복을 허용하지 않는 것이 아니다. 단지 같은 숫자들의 나열이면 출력을 두 번 이상 하지 않는 것일 뿐이다. 따라서 애초에 M개의 숫자가 선택되면 숫자들의 나열을 문자열로 바꾸고 LinkedHashSet<String> 자료형의 객체에 저장하면 된다. 이 자료형은 Set 인터페이스의 하나로, 중복을 허용하지 않아 같은 자료가 들어오면 받아들이지 않는다. 또한 일반적인 Set이 순서를 보장하지 않는것에 비해 이 자료형은 자료를 입력된 순서대로 관리해주기까지 한다. 또한 마지막에 Iterator를 사용해서 LinkedHashSet에 있는 자료를 순차적으로 출력한다. 이 때, iteration을 돌며 바로바로 하나씩 출력해도 되지만 스트링빌더에 모아서 한 번에 출력하는게 속도에서 훨씬 유리하다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer tk = new StringTokenizer(br.readLine());
		
		//N,M 입력
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		//N개 수 입력
		nums = new int[N];
		tk = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(tk.nextToken());
		}
		
		//nums 배열 오름차순으로 정렬
		Arrays.sort(nums);
		
		selectedNums = new int[M]; //선택 된 M개의 수를 저장할 배열
		c = new boolean[N]; //i번째 숫자 선택 여부 체크를 위한 배열
		
		printSet = new LinkedHashSet<>(); //출력 버퍼
		//출력버퍼를 LinkedHashSet으로 하는 이유는 중복된 문자열이 저장되지 않게 하고, 자료를 입력 순서대로 관리하기 위해서다
		
		recursion(N, M, 0);
		
		//출력 : 수만개를 일일이 print하는 것 보다 StringBuilder에 모아서 한 번에 출력하는게 훨씬 빠르다
		StringBuilder sb = new StringBuilder();
		Iterator<String> iter = printSet.iterator();
		while(iter.hasNext()) 
			sb.append(iter.next()+"\n");		
		System.out.print(sb);
	}
	
	static int[] nums;
	static int[] selectedNums;
	static boolean[] c;
	static LinkedHashSet<String> printSet;
	
	static void recursion(int N, int M, int idx) {
		
		//M개의 숫자가 선택된 경우 출력 버퍼에 저장
		if(idx==M) {
			
			StringBuilder sb = new StringBuilder();
			//선택된 숫자들 문자열로 변환
			for(int i=0; i<M; i++) {
				sb.append(selectedNums[i]+" ");
			}
			printSet.add(sb.toString()); //출력 버퍼에 추가

			return; //재귀 호출 종료
		}
		
		for(int i=0; i<N; i++) {
			if(c[i]) //i번째 숫자 이미 선택된 경우 넘어가기
				continue;
			
			//i번째 숫자 선택
			c[i] = true;
			selectedNums[idx] = nums[i];
			recursion(N, M, idx+1);
			
			//i번째 숫자 선택하지 않기
			c[i] = false;
		}
	}
}
~~~

<br>
### N과 M(10)

<br>
[백준 15664 - N과 M(10)](https://www.acmicpc.net/problem/15664){: target="_blank" }

* N개의 자연수 중에서 M개를 고른 수열
* 고른 수열은 비내림차순이어야 한다.
<br>

N과 M(9)와 같이 입력으로 들어오는 수들 중에 같은 것이 존재할 수 있다. 유일한 차이는 비내림차순인 수열만 출력해주어야한다. 따라서 재귀함수 내의 숫자를 탐색하는 for문의 시작점을 가장 마지막에 선택한 숫자 다음 숫자로 하면 된다. 이를 위해 start 매개변수를 사용한다. 다만, 이 때는 start 매개변수 때문에 애초에 중복이 될 가능성이 없으므로 boolean배열 c[]는 필요 없으므로 삭제해준다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer tk = new StringTokenizer(br.readLine());
		
		//N,M 입력
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		//N개 수 입력
		nums = new int[N];
		tk = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(tk.nextToken());
		}
		
		//nums 배열 오름차순으로 정렬
		Arrays.sort(nums);
		
		selectedNums = new int[M]; //선택 된 M개의 수를 저장할 배열
		
		printSet = new LinkedHashSet<>(); //출력 버퍼
		//출력버퍼를 LinkedHashSet으로 하는 이유는 중복된 문자열이 저장되지 않게 하고, 자료를 입력 순서대로 관리하기 위해서다
		
		recursion(N, M, 0, 0);
		
		//출력 : 수만개를 일일이 print하는 것 보다 StringBuilder에 모아서 한 번에 출력하는게 훨씬 빠르다
		StringBuilder sb = new StringBuilder();
		Iterator<String> iter = printSet.iterator();
		while(iter.hasNext()) 
			sb.append(iter.next()+"\n");		
		System.out.print(sb);
	}
	
	static int[] nums;
	static int[] selectedNums;
	static LinkedHashSet<String> printSet;
	
	static void recursion(int N, int M, int idx, int start) {
		
		//M개의 숫자가 선택된 경우 출력 버퍼에 저장
		if(idx==M) {
			
			StringBuilder sb = new StringBuilder();
			//선택된 숫자들 문자열로 변환
			for(int i=0; i<M; i++) {
				sb.append(selectedNums[i]+" ");
			}
			printSet.add(sb.toString()); //출력 버퍼에 추가

			return; //재귀 호출 종료
		}
		
		for(int i=start; i<N; i++) {
			//i번째 숫자 선택
			selectedNums[idx] = nums[i];
			recursion(N, M, idx+1, i+1); //i번째 숫자를 선택한 경우 다음 호출에서는 i+1번째 숫자부터 탐색
		}
	}
}
~~~

<br>
### N과 M(11)

<br>
[백준 15665 - N과 M(11)](https://www.acmicpc.net/problem/15665){: target="_blank" }

* N개의 자연수 중에서 M개를 고른 수열
* 같은 수를 여러 번 골라도 된다.
<br>

같은 숫자를 여러번 골라도 된다. 그러나 중복된 수열을 출력하면 안된다. 이 문제와 N과 M(9)의 유일한 차이점은 같은 숫자를 여러번 골라도 된다는 것이다. 따라서 이미 고른 숫자를 제외하기 위해 만든 boolean 배열인 c[]를 삭제해주면 끝이다.
<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer tk = new StringTokenizer(br.readLine());
		
		//N,M 입력
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		//N개 수 입력
		nums = new int[N];
		tk = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(tk.nextToken());
		}
		
		//nums 배열 오름차순으로 정렬
		Arrays.sort(nums);
		
		selectedNums = new int[M]; //선택 된 M개의 수를 저장할 배열
		
		printSet = new LinkedHashSet<>(); //출력 버퍼
		//출력버퍼를 LinkedHashSet으로 하는 이유는 중복된 문자열이 저장되지 않게 하고, 자료를 입력 순서대로 관리하기 위해서다
		
		recursion(N, M, 0);
		
		//출력 : 수만개를 일일이 print하는 것 보다 StringBuilder에 모아서 한 번에 출력하는게 훨씬 빠르다
		StringBuilder sb = new StringBuilder();
		Iterator<String> iter = printSet.iterator();
		while(iter.hasNext()) 
			sb.append(iter.next()+"\n");		
		System.out.print(sb);
	}
	
	static int[] nums;
	static int[] selectedNums;
	static LinkedHashSet<String> printSet;
	
	static void recursion(int N, int M, int idx) {
		
		//M개의 숫자가 선택된 경우 출력 버퍼에 저장
		if(idx==M) {
			
			StringBuilder sb = new StringBuilder();
			//선택된 숫자들 문자열로 변환
			for(int i=0; i<M; i++) {
				sb.append(selectedNums[i]+" ");
			}
			printSet.add(sb.toString()); //출력 버퍼에 추가

			return; //재귀 호출 종료
		}
		
		for(int i=0; i<N; i++) {
			//i번째 숫자 선택
			selectedNums[idx] = nums[i];
			recursion(N, M, idx+1);
				
		}
	}
}
~~~

<br>
### N과 M(12)

<br>
[백준 15666 - N과 M(12)](https://www.acmicpc.net/problem/15666){: target="_blank" }

* N개의 자연수 중에서 M개를 고른 수열
* 같은 수를 여러 번 골라도 된다.
* 고른 수열은 비내림차순이어야 한다.
<br>

같은 숫자를 여러번 골라도 되고, 비내림 차순이다. N과 M(10), N과 M(11)은 N과 M(9)에서 각각의 조건을 한 가지씩만 적용한 문제였다. 여기서는 그 두 가지 조건을 모두 구현해주면 된다. 먼저, 같은 숫자의 중복 추가를 막기 위해 만들었던 배열인 c[]를 삭제해준다. 그리고 start 매개변수를 추가해주면 되는데, N과 M(10)과 다른 점이 하나 있다. N과 M(10)에서는 다음 재귀함수를 호출할 때 start 매개변수로 i+1을 넣어주었다. 그런데, 여기서는 같은 숫자의 중복을 허용하므로 i번째 숫자부터 넣어주면 된다.

<br>
~~~ java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.StringTokenizer;

public class Main{
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer tk = new StringTokenizer(br.readLine());
		
		//N,M 입력
		int N = Integer.parseInt(tk.nextToken());
		int M = Integer.parseInt(tk.nextToken());
		
		//N개 수 입력
		nums = new int[N];
		tk = new StringTokenizer(br.readLine());
		for(int i=0; i<N; i++) {
			nums[i] = Integer.parseInt(tk.nextToken());
		}
		
		//nums 배열 오름차순으로 정렬
		Arrays.sort(nums);
		
		selectedNums = new int[M]; //선택 된 M개의 수를 저장할 배열
		
		printSet = new LinkedHashSet<>(); //출력 버퍼
		//출력버퍼를 LinkedHashSet으로 하는 이유는 중복된 문자열이 저장되지 않게 하고, 자료를 입력 순서대로 관리하기 위해서다
		
		recursion(N, M, 0, 0);
		
		//출력 : 수만개를 일일이 print하는 것 보다 StringBuilder에 모아서 한 번에 출력하는게 훨씬 빠르다
		StringBuilder sb = new StringBuilder();
		Iterator<String> iter = printSet.iterator();
		while(iter.hasNext()) 
			sb.append(iter.next()+"\n");		
		System.out.print(sb);
	}
	
	static int[] nums;
	static int[] selectedNums;
	static LinkedHashSet<String> printSet;
	
	static void recursion(int N, int M, int idx, int start) {
		
		//M개의 숫자가 선택된 경우 출력 버퍼에 저장
		if(idx==M) {
			
			StringBuilder sb = new StringBuilder();
			//선택된 숫자들 문자열로 변환
			for(int i=0; i<M; i++) {
				sb.append(selectedNums[i]+" ");
			}
			printSet.add(sb.toString()); //출력 버퍼에 추가

			return; //재귀 호출 종료
		}
		
		for(int i=start; i<N; i++) {
			//i번째 숫자 선택
			selectedNums[idx] = nums[i];
			recursion(N, M, idx+1, i); //i번째 숫자를 선택한 경우 다음 호출에서는 i번째 숫자부터 탐색(같은 숫자 중복 가능하면서 비내림차순)
		}
	}
}
~~~
