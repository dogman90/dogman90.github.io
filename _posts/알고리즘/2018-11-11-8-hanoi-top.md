---
title: 8. 재귀호출 (3) - 하노이 탑 옮기기
date: 2018-11-11T16:20:05+09:00
author: SWnomad
layout: post
categories: 알고리즘
image: /images/2018/11/algorithm-thumbnail.jpg
tags:
  - algorithm
  - hanoi
  - hanoi top
  - recursion
  - 알고리즘
  - 옮기기
  - 재귀호출
  - 하노이
  - 하노이 탑
  - 하노이의 탑
---
# 1. 하노이 탑

* * *

<img class="aligncenter  wp-image-1321" src="/images/2018/11/1.jpg" alt="" width="491" height="212" srcset="/images/2018/11/1.jpg 725w, /images/2018/11/1-300x130.jpg 300w" sizes="(max-width: 491px) 100vw, 491px" /> 

하노이 탑 옮기기는 세 개의 기둥이 있을 때, 첫 번째 기둥에 있는 원반을 모두 세 번째 기둥으로 옮기는 문제이다.

원반을 옮길 때에는 아래의 두 가지 규칙을 지켜야 한다.

1) 한 번에 한 개의 원반만 움직일 수 있다.

2) 큰 원반이 작은 원반 위에 있을 수 없다.

&nbsp;

&nbsp;

&nbsp;

# 2. 문제 정의

* * *

하노이의 탑 문제는 원반의 갯수가 입력으로 들어오면, 모든 원반을 세 번째 기둥으로 옮기는 방법들 중 원반 이동 횟수가 최소화가 되는 루트를 찾는 것이다.

<img class="aligncenter  wp-image-1322" src="/images/2018/11/no-name-6.jpg" alt="" width="610" height="155" srcset="/images/2018/11/no-name-6.jpg 771w, /images/2018/11/no-name-6-300x76.jpg 300w, /images/2018/11/no-name-6-768x195.jpg 768w" sizes="(max-width: 610px) 100vw, 610px" /> 

&nbsp;

&nbsp;

&nbsp;

# 3. 알고리즘

* * *

이 문제를 정해진 알고리즘으로 풀 수 있다는 것은, 원반의 갯수 n이 몇 개가 되든 상관없이 공통적으로 적용되는 규칙이 있다는 사실을 말한다.

&nbsp;

1) 원반이 1개인 경우는 1->3의 1 번의 이동횟수를 가지는 루트가 최소 루트이다.

2) 원반이 2개인 경우는 1->2,  1->3,  2->3의 3 번의 이동횟수를 가지는 루트가 최소 루트이다.

3) 원반이 3개인 경우는 1->3,  1->2,  3->2,  1->3,  2->1,  2->3,  1->3의 7번의 이동횟수를 가지는 루트가 최소 루트이다.

이 경우는 위의 원반 2개를 일단 보조기둥으로 옮기는데, 이 경우는 원반이 2개인 경우랑 같은 실행 과정을 거친다. 그리고 마지막으로 남은 세 번째 원반을 세 번째 기둥으로 옮긴 다음 2번기둥에 있는 원반 2개를 세 번째 기둥으로 옮기는 &#8216;원반 2개 옮기기 과정&#8217;을 실행하면 된다.

&nbsp;

이렇게 생각해보니 원반이 n개인 경우에 대해서도 통찰이 생긴다.

원반 n개를 세 번째 기둥으로 옮기는 과정은 원반 n-1개를 먼저 두 번째 기둥으로 옮기고 가장 큰 원반을 세 번째 기둥으로 옮긴 후 다시 n-1개의 원반을 세 번째 기둥으로 옮기는 과정을 거치면 된다.

<img class="aligncenter  wp-image-1323" src="/images/2018/11/1-1.jpg" alt="" width="522" height="211" srcset="/images/2018/11/1-1.jpg 717w, /images/2018/11/1-1-300x121.jpg 300w" sizes="(max-width: 522px) 100vw, 522px" /> 

&nbsp;

다시 한 번 정리하자면 다음과 같다.

n개의 원반 이동 = n-1개 원반이동 + n번째 원반이동

= (n-2개 원반이동 + n-1번째 원반이동) + n번째 원반이동

= conitnue&#8230;

단, 괄호 안에 있는 이동은 3번째 기둥이 아닌 두 번째 기둥으로의 임시적 이동이다.

&nbsp;

이 과정을 코드로 표현하면 다음과 같다.

~~~ python
#hianoi(원반 갯수, 출발지, 도착지, 임시거처)

def hanoi(n, start, end, temp):   #hianoi(원반 갯수, 출발지, 도착지, 임시거처)
    if n==1:   #원반이 한 개인 경우. 재귀호출의 마지막 종착지. n==1이 되면 재귀호출 종료
        print(start, "->", end)
    else:
        hanoi(n-1, start, temp, end)   # n-1개를 일단 start에서 temp로 옮기는데, end를 임시 거처로 사용
        print(start,'->', end)   # n번째 원반을 start에서 end로 이동
        hanoi(n-1, temp, end, start)   # n-1개를 다시 temp에서 end로 옮기는데, 출발지를 임시거처로 사용

print("----n=2----")
hanoi(2,1,3,2)
print("-----n=5----")
hanoi(5,1,3,2)
~~~

실행 결과는 다음과 같이 나온다.

`----n=2----


1 -> 2


1 -> 3


2 -> 3


-----n=5----


1 -> 3


1 -> 2


3 -> 2


1 -> 3


2 -> 1


2 -> 3


1 -> 3


1 -> 2


3 -> 2


3 -> 1


2 -> 1


3 -> 2


1 -> 3


1 -> 2


3 -> 2


1 -> 3


2 -> 1


2 -> 3


1 -> 3


2 -> 1


3 -> 2


3 -> 1


2 -> 1


2 -> 3


1 -> 3


1 -> 2


3 -> 2


1 -> 3


2 -> 1


2 -> 3


1 -> 3`

&nbsp;

&nbsp;

# 4. 알고리즘 효율

* * *

위 알고리즘에서 가장 중요한 실행은 이동 경로의 출력이다.

원반 1개 : 1번

원반 2개 : 3번

원반 3개 : 7번

원반 4개 : 15번

원반 5개 : 31번

n을 늘리며 실행시키면 위와 같은 실행 횟수가 나온다.

규칙을 찾으면 원반이 n개인 경우의 실행횟수는 2^n-1이다.

따라서 하노이 탑 옮기기 알고리즘의 시간 복잡도는 O(n^2)이다.