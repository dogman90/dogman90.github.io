---
title: 3. 알고리즘의 복잡도 - big-O 표기법
date: 2018-11-07T22:43:12+09:00
author: SWnomad
layout: post
categories: 알고리즘
image: /images/2018/11/algorithm-thumbnail.jpg
tags:
  - algorithm
  - big-O
  - O(1)
  - O(n^2)
  - O(n)
  - 공간 복잡도
  - 빅 오
  - 빅오
  - 시간 복잡도
  - 알고리즘
  - 연산
  - 표기법
  - 횟수
---
알고리즘의 복잡도를 나타내는 방법 중 big-O(빅 오) 표기법 이란 것이 있다.

알고리즘의 복잡도에는 크게 &#8216;시간 복잡도&#8217;와 &#8216;공간 복잡도&#8217;가 있다. 둘 모두 big-O 표기법으로 나타낼 수 있다.

&nbsp;

# 1. 시간 복잡도

* * *

알고리즘의 수학 연산이 잡아먹는 시간을 나타낸다. 연산의 횟수와 관련이 있다.

연산의 횟수가 아주 작을 경우는 O(1)과 O(n), O(n^2)의 복잡도를 가진 알고리즘들이 비슷한 효율을 낸다. 시간 복잡도는 데이터의 갯수가 충분히 큰 경우에 의미가 있다.

&nbsp;

O(1) : 연산의 횟수가 데이터의 입력에 관계없이 일정

&nbsp;

O(n) : 연산의 횟수가 데이터의 수에 정비례

ex) 데이터의 수 10개일 때 연산이 50번 필요하다면 데이터의 수 20개 일 때 연산이 100번 필요

&nbsp;

O(n^2) : 연산의 횟수가 데이터의 수의 제곱에 비례

ex) 데이터의 수 10개일 때 연산이 50번 필요하다면 데이터의 수가 2배인 20개일 때 연산이 2^2 = 4배인 200번 필요

&nbsp;

위와 같은 느낌으로 알고리즘의 시간 복잡도를 계산하면 된다. 일반적으로 시간 복잡도는 아래의 순서에 따라 증가한다.

<img class="alignleft" src="https://latex.codecogs.com/gif.latex?O(1)<O(log(n))<O(n)<O(nlog(n))<O(n^{2})" alt="O(1)<O(log(n))<O(n)<O(nlog(n))<O(n^{2})" align="absmiddle" /><img class="alignleft" src="https://latex.codecogs.com/gif.latex?<O(2^{n})<O(n!)<O(n^{n})" alt="<O(2^{n})<O(n!)<O(n^{n})" align="absmiddle" /> 

&nbsp;

&nbsp;

&nbsp;

# 2. 공간 복잡도

* * *

알고리즘의 연산을 수행하는 데 필요한 메모리공간이 얼마나 필요한지를 나타낸다. 컴퓨터 하드웨어의 비약적인 발전으로 공간 복잡도는 시간 복잡도에 비해 그 중요함이 훨씬 덜하다.

1부터 n^2까지를 순차적으로 리스트에 저장한다고 할 때, n이 10이라면 100개의 리스트가 필요하다. 그런데 n이 20이라면 400개의 리스트가 필요해진다. 이 경우 필요한 메모리 공간이 n의 제곱에 비례하므로 이 알고리즘의 공간 복잡도는 O(n^2)을 따른다.

&nbsp;

&nbsp;

&nbsp;

# 3. 예제

* * *

## 1) 1부터 n까지의 합

~~~ python
n = int(input("n을 입력하세요: "))

def sum(n):
    result = 0
    for i in range(n+1):
        result = result + i
    return result

print("1부터 n까지의 합 : %d" %sum(n))
~~~

n이 10이면 10번, 20이면 20번의 연산이 필요하므로 연산의 횟수가 n에 정비례한다.

따라서 위의 알고리즘의 시간 복잡도는 **O(n)**

&nbsp;

## 2) n의 제곱까지의 합

~~~ python
n = int(input("n을 입력하세요: "))

def sum(n):
    result = 0
    for i in range(n+1):
        result = result + i**2
    return result

print("1부터 n까지의 합 : %d" %sum(n))
~~~

n이 10일 때는 20번, 20일 때는 40번의 연산이 필요하다. 이 때에도 절대적인 크기는 알고리즘 1)의 경우와 같지만 마찬가지로 정비례한다. 이 때에도 시간 복잡도는 **O(n)**을 따른다.

&nbsp;

## 3) (n+1)^2 계산

~~~ python
n = int(input("n을 입력하세요: "))

def sum(n):
    result = 0
    for i in range(n+1):
        for j in range(n+1):
            result = result + 1

    return result

print("1부터 n까지의 합 : %d" %sum(n))
~~~

n이 1일 때는 i=0,1/j=0,1 각각의 경우를 고려하므로 4번의 연산이, n이 2일 때는 i=0,1,2/j=0,1,2 각각의 경우를 고려하므로 9번의 연산이 필요하다. n이 2배 늘어날 때 연산의 횟수는 n^2배 늘어나므로 이 알고리즘의 시간 복잡도는 **O(n^2)**이다.