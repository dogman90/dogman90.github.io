---
title: 순열
date: 2019-08-11T15:28:34+09:00
author: SWnomad
layout: post
categories: 알고리즘
tags:
  - 순열
  - permutation
  - next
  - previous
---

## 1. 순열이란?
***

순열이란 순서가 있는 수열이다. 가령 1,2,3,4,5 다섯 개의 자연수를 나열하는 방법은 총 5!=120가지 이다. 보통 알고리즘 문제에서는 어떤 요소들을 던져주고 이것들을 나열하는 방법의 갯수나 모든 나열을 출력하라는 문제가 주어진다.

<br>

## 2. 다음 순열(next permutation)
***

모든 순열을 사전순으로 출력하라는 문제가 있다. 가령 1,2,3,4,5 다음에는 1,2,3,5,4를 출력하고 그 다음은 1,2,4,3,5 이런식으로 출력하라는 것이다. 임의의 숫자들을 던져주고 이들을 사전순으로 출력하라고 했을때 사용할 수 있는 방법은 다음 순열을 계산해주는 함수를 만들어 차례대로 처음부터 끝까지 출력해주는 것이다. 위에서 위에서 예로 든 1,2,3,4,5로 만든다고 해보자.

<br>

1,2,3,4,5

1,2,3,5,4

1,2,4,3,5

1,2,4,5,3

...

2,1,3,4,5

2,1,3,5,4

...

2,5,4,3,1

...

5,4,3,1,2

5,4,3,2,1

총 120가지가 나온다. 자세히 살펴보면 첫 순열은 오름차순, 마지막 순열은 내림차순이다.

<br>

C++의 STL에는 next_permutation이라는 함수가 있어 라이브러리를 불러와 간단히 사용할 수 있다. python에도 비슷한 함수가 있지만 부족하다. Java에는 이런 함수가 아예 없다. 그러나 한 번 만들어두면 계속해서 사용할 수 있다.

next_permutation함수를 만드는 방법은 다음과 같다.

>1. A[i-1]<A[i]를 만족하는 가장 큰 i를 찾는다. 즉, i부터는 뒤로 내림차순으로 이미 정렬이 되어있는 i를 찾는 것을 의미한다.
>2. i≤j 이면서 A[i-1]<A[j]를 만족하는 가장 큰 j를 찾는다. 즉, A[i-1]보다 큰 숫자들 중 가장 작은 숫자를 찾으라는 것이다. 뒤로는 이미 내림차순으로 정렬되어있기 때문에 이는 가장 큰 j와 같은 의미이다.
>3. A[i-1]과 A[j]를 swap한다.
>4. A[i]부터 뒤로 있는 순열을 거꾸로 뒤집는다.

<br>

잘 이해가 가지 않을 수 있으므로 예시를 보면서 이해해보자.

1,2,3,4,7,6,5 라는 순열이 있다. 그 다음 수열을 구하기 위해서 위의 과정대로 진행해본다.

1. 7,6,5는 이미 내림차순으로 정렬되어 있으므로 A[i-1]=4, A[i]=7이다.

2. A[i-1]=4, A[j]=5 이다.

3. 4와 5의 위치를 서로 바꾸면 1,2,3,5,7,6,4가 된다.

4. 7,6,4부분만 거꾸로 뒤집으면 1,2,3,5,4,6,7이 나온다.

따라서 1,2,3,4,7,6,5의 다음 순열은 1,2,3,5,4,6,7이 된다.

이런 식으로 계속 진행해나가다 보면 마지막 순열은 7,6,5,4,3,2,1이 될 것이다.

이러한 일을 해주는 next_permutation 함수를 Java로 작성해보자.

<br>

~~~ java
public static boolean next_permutation(int[] a) {
	
	//길이가 2보다 작으면 다음 순열 없으므로 false 리턴
	if(a.length<2)
		return false;
	
	//1. A[i-1]<A[i]인 가장 큰 i를 찾는다.
	int i = a.length-1;
	while(i>0 && a[i-1]>=a[i]) {
		i--;
	}
	
	//이미 모든 순열이 내림차순일 경우 다음 순열이 없고 이 때 i는 0이 되어있을 것이므로 false 반환
	if(i==0)
		return false;
	
	//2. i<=j이면서 A[i-1]<A[j]를 만족하는 가장 작은 A[j], 즉 가장 큰 j를 찾는다.
	int j=a.length-1;
	while(a[i-1]>=a[j])
		j--;
	
	//3. A[i-1]과 A[j]를 swap한다.
	int temp = a[i-1];
	a[i-1] = a[j];
	a[j] = temp;
	
	//4. A[i]부터 뒤로 있는 순열을 뒤집는다.
	j=a.length-1;
	while(i<j) {
		temp = a[i];
		a[i] = a[j];
		a[j] = temp;
		
		i++;
		j--;
	}
	
	return true;
}
~~~

<br>

그렇다면 이 알고리즘의 시간 복잡도는 어떻게 될까? 1~4 각각의 과정에 대한 시간복잡도를 우선 구해보자.

>1. i는 많으면 1~N-1까지 총 N-1번 비교연산을 할 수 있으므로 O(N)
>2. j도 마찬가지로 i부터 N까지 비교연산을 할 수 있으므로 O(N)
>3. 두 개를 단순히 바꾸는 것이므로 1번만 수행하면 된다. 따라서 시간복잡도는 O(1)
>4. 최대 비교횟수의 경우 1과 N-1를 바꾸고, 2와 N-2, 3과 N-3, ...로 N/2번 바꾸어야하므로 O(N)

위 과정은 각각 독립된 과정이므로 O(N)+O(N)+O(1)+O(N) = O(N)이다. 따라서 next_permutation 알고리즘 전체의 시간 복잡도는 O(N)이다.

<br>

## 3. 이전 순열(previous permutation)
***

이전 순열은 다음 순열과 같은 원리이다.

>1. A[i-1]>A[i]를 만족하는 가장 큰 i를 찾는다. 즉, i부터는 뒤로 오름차순으로 이미 정렬이 되어있는 i를 찾는 것을 의미한다.
>2. i≤j 이면서 A[i-1]>A[j]를 만족하는 가장 큰 j를 찾는다. 즉, A[i-1]보다 작은 숫자들 중 가장 큰 숫자를 찾으라는 것이다. 뒤로는 이미 오름차순으로 정렬되어있기 때문에 이는 가장 큰 j와 같은 의미이다.
>3. A[i-1]과 A[j]를 swap한다.
>4. A[i]부터 뒤로 있는 순열을 거꾸로 뒤집는다.

Java 소스코드도 몇개의 부등호만 바뀔 뿐 next_permutation과 거의 비슷하다.

<br>

~~~ java
public static boolean prev_permutation(int[] a) {
	
	//길이가 2보다 작으면 이전 순열 없으므로 false 리턴
	if(a.length<2)
		return false;
	
	//1. A[i-1]>A[i]를 만족하는 가장 큰 i를 찾는다.
	int i=a.length-1;
	while(i>0 && a[i-1]<=a[i])
		i--;
	
	//이미 모든 순열이 오름차순일 경우 이전 순열이 없고 이 때 i는 0이 되어있을 것이므로 false 반환
	if(i==0)
		return false;
	
	//2. i<=j이면서 A[i-1]>A[j]를 만족하는  가장 큰 A[j], 즉 가장 큰 j를 찾는다.
	int j=a.length-1;
	while(a[i-1]<=a[j])
		j--;
	
	//3. A[i-1]과 A[j]를 swap한다.
	int temp = a[i-1];
	a[i-1] = a[j];
	a[j] = temp;
	
	//4. A[i]부터 뒤로 있는 순열을 뒤집는다.
	j=a.length-1;
	while(i<j) {
		temp = a[i];
		a[i] = a[j];
		a[j] = temp;
		
		i++;
		j--;
	}
	
	return true;
}
~~~

<br>

시간 복잡도는 next_permutation과 마찬가지로 O(N)이다.