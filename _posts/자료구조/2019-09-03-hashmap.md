---
title: 연결리스트(LinkedList)
date: 2019-09-03T23:28:34+09:00
author: SWnomad
layout: post
categories: 자료구조
tags:
  - 자료구조
  - 자바
  - java
  - HashMap
  - 해시맵
---

## 1. 해시(Hash)란?
* * *

해시란 입력을 해시 알고리즘을 통해서 계산하여 출력을 만만드는 것이다. 해시(hash)는 임의의 길이의 입력 데이터를 고정된 길이의 출력 데이터로 변환시킨다. 입력을 넣었을 때 해시 값이 계산되는 알고리즘을 해시함수라고 한다.

해시함수를 이용한 대표적인 자료구조가 해시 테이블이다. 해시 테이블은 \<Key,Value\>(키, 값) 쌍으로 이루어진 데이터를 저장할 때 유용하다. 배열, 리스트가 순차적인 index를 가지는 것과 다르게 해시 테이블은 Key를 가지고 해시 알고리즘을 돌려 나온 결과값을 index로 사용한다. 이미 내부적으로는 배열을 통해서 많은 저장소(이를 버킷이라 부른다)가 만들어져 있다.

&nbsp;

![hash](/images/datastructure/hash_function.png){: width="30%" height="30%"}

&nbsp;
&nbsp;
해시 함수의 특징은 아래와 같다.

1. 가변적인 길이의 입력 데이터에 적용 가능해야한다.
2. 출력 데이터 길이가 일정해야한다.
3. 해시 결과값으로 입력 데이터를 역추적 하는 것이 불가능해야한다.
4. 해시 충돌 빈도가 낮아야한다.

&nbsp;
&nbsp;
**※해시 충돌**

여러 Key들이 해싱(hashing)되었을 때 같은 해시 값을 가지는 경우가 존재하는데 이것을 **해시 충돌(collision)**이라고 한다. 현재까지 개발된 모든 해시 함수들은 해시 충돌을 가지고 있다.

이러한 해시 충돌을 해결하는 방법에는 여러가지가 있는데 가장 대표적으로 알려진 두 가지를 살펴보자.

<br>

+ 체이닝(chaining)

체이닝은 해시 충돌이 일어났을 경우 데이터를 연결하여 쌓는 것이다. 단, 체이닝을 사용하기 위해서는 내부 배열에 저장될 자료형을 연결리스트로 만들어야한다.

<br>

+ 개방 주소법(Open Address)

충돌이 일어나면 다른 버킷에 데이터를 저장한다. 여기에는 여러가지 방법이 있는데 대표적인 3가지를 소개한다.

<br>

*1)선형 탐색* : 해시 충돌 시 몇 칸을 건너뛰어 저장한다.

*2)제곱 탐색* : 해시 충돌 시 제곱만큼 건너뛴 버킷에 데이터를 저장한다.(1,4,9,16,...)

*3)이중 해시* : 해시 충돌 시 두 번째 해시함수를 통해 index를 다시 계산한다.

<br>
해시를 사용했을 때의 장단점은 아래와 같다.

<br>

### 1) 빠른 탐색

해시(Hash)는 내부적으로 배열을 사용하기 때문에 검색 속도가 빠르다. 해시 테이블에서 자료를 검색할 때는 key에 해당하는 value가 있는지만 확인하면 되므로 (해시 충돌이 0에 가깝다는 가정하에)시간 복잡도가 *O(1)*이다. 데이터의 추가, 삭제시 기존 데이터의 이동이 필요없는 링크드리스트의 장점또한 가지고 있다.

### 2) 공간 낭비
해시 자료구조에서는 배열의 index가 연속적이지 않고, 해시함수에 의해 계산된 데이터 자신만의 고유한 값을 가진다. 따라서 공간낭비적 측면이 있으며, 공간을 팔아 속도를 가지는 자료구조라고 볼 수도 있다.

<br>
<br>

##2. Java Collections의 Hash 자료구조
* * *

Java의 Collections 프레임워크에는 Hash를 사용한 여러 자료구조들이 존재한다.

<br>

![Collections](/images/datastructure/collections.png){: width="70%" height="70%"}

<br>

\<Key, Value\> 데이터쌍을 저장하기 위한 HashMap과 HashTable은 Map 인터페이스를 구현한다. 이 둘의 차이는 동기화의 지원 유무이다. HashTable이 동기화를 지원하는데 반해 HashMap은 동기화를 지원하지 않는다. 따라서 멀티스레드 환경에서는 HashMap이 아닌 HashTable을 사용해야한다. 대신에 HashTable은 동기화 처리라는 비용을 지불하는 만큼 성능면에서 HashMap보다 느리다. 따라서 싱글스레드인 경우에는 HashTable보다는 HashMap을 사용하기를 권장한다.

HashSet은 \<Key, Value\> 형태의 데이터를 저장하는 것이 아니다. 단지 입력을 해싱했을 때의 결과를 index로 사용한다. 또한 Set(집합) 인터페이스를 구현하는 만큼 자료의 중복저장이 안되며, 순서 또한 보장하지 않는다. 이에 반해 LinkedHashSet은 이름에서 유추할 수 있듯이 LinkedList와 HashSet을 결합하여 순서를 보장해주지 않는 HashSet의 특징을 변경한 것이다.

<br>

##3. HashMap의 시간 복잡도
* * *

내부적으로 배열을 사용하는 만큼 Key를 해싱한 배열의 index번째 데이터에 랜덤 액세스를 통해 접근하므로 O(1)이다. 단, 이는 해시충돌이 없는 이상적일 경우이다. 만약 모든 데이터가 하나의 버킷안에 체이닝을 통해 링크된 형태로 저장되었다하면, 첫 데이터부터 끝까지 순차적인 탐색을 통해 찾아야 하므로 최악의 경우 시간 복잡도는 O(N)이라고 할 수 있다.