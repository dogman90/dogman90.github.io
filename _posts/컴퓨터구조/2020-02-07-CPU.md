---
title: (컴퓨터구조) 1. CPU
date: 2020-02-07T19:37:19+09:00
author: nobbaggu
layout: post
categories: 컴퓨터구조
tags:
  - CPU
  - 구조
  - 기능
  - 명령어
  - 인출
  - 해독
  - fetch
  - decode
  - ALU
  - 산술논리연산장치
  - 레지스터
---

## 목차 ##

1. CPU의 구조
2. 명령어 실행
3. 명령어 파이프라이닝
4. 명령어 세트

<br>
## 0.Intro ##
---

CPU는 프로그램 실행을 하는 가장 핵심적인 부품이다. CPU는 아래의 동작들을 차례로 수행함으로써 프로그램을 실행한다.

**1. 명령어 인출(fetch)** : 메모리에서 명령어 가져오기

**2. 명령어 해독(decode)** : 명령어를 해석하여 연산 수행 및 결과를 저장

**3. 데이터 인출**

**4. 데이터 처리**

**5. 데이터 저장**

명령어를 실행하기 위해 필요한 데이터가 있고, 그 결과를 저장할 필요가 있다면 3,4,5가 실행된다.

이러한 CPU의 동작을 세부적으로 알기위해 생겨먹은 구조를 간단히 파악할 필요가 있다.

<br>
<br>
## 1. CPU의 구조 ##
---

![cpu_structure](/images/computer_architecture/2/cpu_structure.png){: width="50%" height="50%"}

**ALU**
- 각종 산술연산(4칙연산) 및 논리연산(AND, OR, NOT 등) 수행

**레지스터(Register)**
- CPU내부에 위치한 기억장치로 명령어 실행도중 발생하는 데이터들을 임시 저장
- 메인 메모리보다 CPU가 더 빨리 접근할 수 있음
- 부피가 커 많은 수를 포함시키지는 못함

**제어(Control) 유닛**
- 명령어 해석
- 명령어 실행을 위한 신호 발생

<br>
<br>
## 2. 명령어 실행 ##
---
- 명령어 사이클(instruction cycle)
CPU가 한 개의 명령어를 실행하는 전체 과정으로 인출 + 실행 단계로 구성

![instruction_cycle](/images/computer_architecture/2/instruction_cycle.png){: width="50%" height="50%"}

프로그램 시작부터 종료까지 명령어 사이클이 반복적으로 실행된다.

아래는 명령어 사이클에 사용되는 CPU 내부 레지스터들이다.

**프로그램 카운터(Program Counter: PC)**

다음에 인출(fetch)될 명령어가 존재하는 메모리 주소가 저장된다. 마지막 명령어 인출 후 '명령어 주소 크기 단위'만큼 자동으로 증가하거나 혹은 분기(if나 switch와 같은)문의 경우 목적지 주소로 업데이트된다. 이 주소는 주소버스를 통해 내보내진다.

<br>
**누산기(Accumulator: AC)**

연산 과정에 필요한 데이터를 일시적으로 저장한다. 따라서 비트 수는 워드 크기와 같다.

<br>
**명령어 레지스터(Instruction Register: IR)**

가장 최근에 인출된 명령어를 저장한다. 이후에 여기에 저장된 명령어가 실행된다.

<br>
**기억장치 주소 레지스터(Memory Address Register: MAR)**

PC의 주소값을 주소버스에 내보기전 일시적으로 저장하는 곳이다. MAR이 주소버스와 직접 연결된다. 즉 인출할 명령어의 주소는 PC -> MAR -> 주소버스 -> 메모리를 거친다.

<br>
**기억장치 버퍼 레지스터(Memory Buffer Register: MBR)**

메모리에 저장할 데이터 혹은 메모리로부터 읽은 데이터(인출된 명령어 포함)를 임시적으로 저장하기 위한 버퍼 레지스터이다. 따라서 데이터 버스와 접속되어 있다. 예를들어 다음에 실행할 명령어를 인출한다면 메모리 -> 데이터버스 -> MBR -> IR -> 제어유닛 순으로 데이터가 이동한다.

![cpu_inner_architecture](/images/computer_architecture/2/cpu_inner_architecture.png){: width="50%" height="50%"}

위에서 설명한 CPU의 내부구조를 기반으로 명령어 인출 및 실행 사이클에서 일어나는 동작에 대해 살펴보자.

<br>
### 인출 사이클 ###

프로그램 카운터가 가리키는 주소를 통해 메모리에서 명령어를 인출한다. 이후 PC의 값이 다음 메모리주소값으로 증가한다(혹은 분기의 경우 목적지 주소로 갱신한다). 인출 사이클은 더 작게는 마이크로 연산(micro-operation)들로 나타낼 수 있다.

![micro_operation](/images/computer_architecture/2/micro_operation.png){: width="30%" height="30%"}

인출 사이클은 위에서 보는바와 같이 3개의 마이크로 연산으로 이루어져있다. 각 마이크로 연산은 CPU 클럭 주기에 하나씩 실행된다. 즉, 인출사이클이 실행되기 위해서는 총 3 CPU 클럭이 필요하다.

첫 번째 주기에서는 PC의 다음 인출 명령어가 있는 주소가 MAR로 이동한다.

두 번째 주기에서는 MAR의 값이 주소버스를 통해 메모리로 이동하고 인출된 명령어가 데이터버스를 타고 MBR로 들어온다. 이 과정이 진행되는 동시에 PC값이 명령어 주소 크기 단위만큼 증가한다. 가령 메모리주소에 8bit가 사용되고 명령어가 16bit로 이루어져있다면 하나의 명령어는 2개의 번지수를 차지하게 된다. 따라서 PC값은 2가 증가한다.

마지막 주기에서는 MBR에서 IR로 명령어가 이동한다.

여기까지가 인출 사이클이다. 이후 IR에 저장된 명령어가 실행되는 단계가 실행 단계이다. 아래 그림은 인출 사이클이 실행되는 흐름도이다.

![fetch_cycle](/images/computer_architecture/2/fetch_cycle.png){: width="50%" height="50%"}

<br>
### 실행 사이클 ###

IR에 저장된 명령어를 해독하고 명령실행한다. 명령어는 크게 4가지로 분류된다.

**데이터 읽기**

- CPU와 메모리, 혹은 I/O장치 사이의 데이터 교환

**데이터 쓰기**

연산결과 혹은 입력장치에서 읽은 데이터를 메모리나 보조기억장치에 저장

**데이터 처리**

- 산술연산과 논리연산 

**프로그램 제어**

프로그램의 실행순서 결정

<br>
명령어 종류별로 마이크로 연산 과정이 다를 것이다. 명령어 종류별로 예시를 보겠다.

그 전에 명령어는 연산 종류를 나타내는 연산코드와 연산에 필요한 연산과 관련된 메모리 주소를 나타내는 오퍼랜드로 구성되어있다는 것을 상기하자.

![instruction_format](/images/computer_architecture/2/instruction_format.png){: width="30%" height="30%"}

<br>
*데이터 읽기 예제: 메모리의 특정 주소에서 데이터를 읽어서 AC에 저장(LOAD addr)*

![data_read_execution](/images/computer_architecture/2/data_read_execution.png){: width="30%" height="30%"}

첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 읽을 메모리 주소)가 MAR로 이동한다.

두 번째 주기에서 해당 주소의 데이터(M\[MAR\])가 데이터 버스를타고 MBR로 이동한다.

세 번째 주기에서는 MBR에 임시로 저장되었던 데이터가 AC로 이동한다.

<br>
*데이터 쓰기 예제: AC의 값을 메모리의 특정 주소에 저장(STA addr)*

![data_write_execution](/images/computer_architecture/2/data_write_execution.png){: width="30%" height="30%"}

첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 저장할 메모리 주소)가 MAR로 이동한다.

두 번째 주기에서 AC의 데이터가 MBR로 이동한다.

세 번째 주기에서 해당 메모리 주소(M\[MAR\])와 MBR의 데이터가 각각 주소버스와 데이터버스를 타고 메모리로 전송된 후 데이터가 저장된다.

<br>
*데이터 처리 예제: 메모리의 특정 주소에서 데이터를 읽어 AC값과 더해서 AC에 저장(ADD addr)*

![data_process_execution](/images/computer_architecture/2/data_process_execution.png){: width="30%" height="30%"}

첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 읽을 메모리 주소)가 MAR로 이동한다.(곧바로 주소버스를 타고 메모리로 이동한다.)

두 번째 주기에서 메모리로부터 값이 들어와 MBR에 저장된다.

세 번째 주기에서 AC값과 MBR값이 더해져 AC에 저장된다.

<br>
*프로그램 제어 예제: PC가 아닌 다른 주소로의 분기 명령어(JUMP addr)*

![program_control_execution](/images/computer_architecture/2/program_control_execution.png){: width="30%" height="30%"}

이 경우에는 명령어 실행 마이크로 오퍼레이션이 한 주기만에 실행된다.

명령어의 오퍼랜드(분기할 목적지 주소)를 PC로 보내버리면 된다. 그러면 다음 명령어를 메모리의 해당 주소에서 인출할 것이다.
