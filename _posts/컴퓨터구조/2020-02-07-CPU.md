---
title: (컴퓨터구조) 2. CPU
date: 2020-02-07T19:37:19+09:00
author: nobbaggu
layout: post
categories: 컴퓨터구조
tags:
  - CPU
  - 구조
  - 기능
  - 명령어
  - 인출
  - 해독
  - fetch
  - decode
  - ALU
  - 산술논리연산장치
  - 레지스터
---

## 목차 ##
==

1. CPU의 구조
2. 명령어 실행
3. 명령어 파이프라이닝
4. 명령어 세트

<br>
## 0.Intro ##
====

CPU는 프로그램 실행을 하는 가장 핵심적인 부품이다. CPU는 아래의 동작들을 차례로 수행함으로써 프로그램을 실행한다.

**1. 명령어 인출(fetch)** : 메모리에서 명령어 가져오기

**2. 명령어 해독(decode)** : 명령어를 해석하여 연산 수행 및 결과를 저장

**3. 데이터 인출**

**4. 데이터 처리**

**5. 데이터 저장**

명령어를 실행하기 위해 필요한 데이터가 있고, 그 결과를 저장할 필요가 있다면 3,4,5가 실행된다.

이러한 CPU의 동작을 세부적으로 알기위해 생겨먹은 구조를 간단히 파악할 필요가 있다.

<br>
<br>
## 1. CPU의 구조 ##
====

![cpu_structure](/images/computer_architecture/2/cpu_structure.png){: width="50%" height="50%"}

**ALU**
- 각종 산술연산(4칙연산) 및 논리연산(AND, OR, NOT 등) 수행

**레지스터(Register)**
- CPU내부에 위치한 기억장치로 명령어 실행도중 발생하는 데이터들을 임시 저장
- 메인 메모리보다 CPU가 더 빨리 접근할 수 있음
- 부피가 커 많은 수를 포함시키지는 못함

**제어(Control) 유닛**
- 명령어 해석
- 명령어 실행을 위한 신호 발생

<br>
<br>
## 2. 명령어 실행 ##
====

- 명령어 사이클(instruction cycle)

	CPU가 한 개의 명령어를 실행하는 전체 과정으로 인출 + 실행 단계로 구성

![instruction_cycle](/images/computer_architecture/2/instruction_cycle.png){: width="50%" height="50%"}

프로그램 시작부터 종료까지 명령어 사이클이 반복적으로 실행된다.

<br>
![cpu_inner_architecture](/images/computer_architecture/2/cpu_inner_architecture.png){: width="50%" height="50%"}

위 그림은 명령어 사이클에 사용되는 CPU 내부 레지스터들이다. 각 레지스터의 역할은 아래와 같다.

**프로그램 카운터(Program Counter: PC)**

다음에 인출(fetch)될 명령어가 존재하는 메모리 주소가 저장된다. 마지막 명령어 인출 후 '명령어 주소 크기 단위'만큼 자동으로 증가하거나 혹은 분기(if나 switch와 같은)문의 경우 목적지 주소로 업데이트된다. 이 주소는 주소버스를 통해 내보내진다.

<br>
**누산기(Accumulator: AC)**

연산 과정에 필요한 데이터를 일시적으로 저장한다. 따라서 비트 수는 워드 크기와 같다.

<br>
**명령어 레지스터(Instruction Register: IR)**

가장 최근에 인출된 명령어를 저장한다. 이후에 여기에 저장된 명령어가 실행된다.

<br>
**기억장치 주소 레지스터(Memory Address Register: MAR)**

PC의 주소값을 주소버스에 내보기전 일시적으로 저장하는 곳이다. MAR이 주소버스와 직접 연결된다. 즉 인출할 명령어의 주소는 PC → MAR → 주소버스 → 메모리를 거친다.

<br>
**기억장치 버퍼 레지스터(Memory Buffer Register: MBR)**

메모리에 저장할 데이터 혹은 메모리로부터 읽은 데이터(인출된 명령어 포함)를 임시적으로 저장하기 위한 버퍼 레지스터이다. 따라서 데이터 버스와 접속되어 있다. 예를들어 다음에 실행할 명령어를 인출한다면 메모리 → 데이터버스 → MBR → IR → 제어유닛 순으로 데이터가 이동한다.

위에서 설명한 CPU의 내부구조를 기반으로 명령어 인출 및 실행 사이클에서 일어나는 동작에 대해 살펴보자.

<br>
### 2-1. 인출 사이클 ###
----

프로그램 카운터가 가리키는 주소를 통해 메모리에서 명령어를 인출한다. 이후 PC의 값이 다음 메모리주소값으로 증가한다(혹은 분기의 경우 목적지 주소로 갱신한다). 인출 사이클은 더 작게는 마이크로 연산(micro-operation)들로 나타낼 수 있다.

![micro_operation](/images/computer_architecture/2/micro_operation.png){: width="30%" height="30%"}

인출 사이클은 위에서 보는바와 같이 3개의 마이크로 연산으로 이루어져있다. 각 마이크로 연산은 CPU 클럭 주기에 하나씩 실행된다. 즉, 인출사이클이 실행되기 위해서는 총 3 CPU 클럭이 필요하다.

첫 번째 주기에서는 다음 인출 명령어가 존재하는 주소가 PC에서  MAR로 이동한다. 곧바로 해당 주소가 주소버스를 타고 메모리로 전달된다.

두 번째 주기에서는 메모리의 해당 번지수에 있던 명령어가 데이터버스를 타고 MBR로 들어온다. 이 과정이 진행되는 동시에 PC값이 명령어 주소 크기 단위만큼 증가한다. 가령 메모리주소에 8bit가 사용되고 명령어가 16bit로 이루어져있다면 하나의 명령어는 2개의 번지수를 차지하게 된다. 따라서 PC값은 2가 증가한다.

마지막 주기에서는 MBR에서 IR로 명령어가 이동한다.

여기까지가 인출 사이클이다. 이후 IR에 저장된 명령어가 실행되는 단계가 실행 단계이다. 아래 그림은 인출 사이클이 실행되는 흐름도이다.

![fetch_cycle](/images/computer_architecture/2/fetch_cycle.png){: width="60%" height="60%"}

<br>
### 2-2. 실행 사이클 ###
----

IR에 저장된 명령어를 해독하고 명령실행한다. 명령어는 크게 4가지로 분류된다.

**데이터 읽기**

- CPU와 메모리, 혹은 I/O장치 사이의 데이터 교환

**데이터 쓰기**

연산결과 혹은 입력장치에서 읽은 데이터를 메모리나 보조기억장치에 저장

**데이터 처리**

- 산술연산과 논리연산 

**프로그램 제어**

프로그램의 실행순서 결정

<br>
명령어 종류별로 마이크로 연산 과정이 다를 것이다. 명령어 종류별로 예시를 보겠다.

그 전에 명령어는 연산 종류를 나타내는 연산코드와 연산에 필요한 연산과 관련된 메모리 주소를 나타내는 오퍼랜드로 구성되어있다는 것을 상기하자.

![instruction_format](/images/computer_architecture/2/instruction_format.png){: width="20%" height="20%"}

<br>
*a)데이터 읽기 예제: 메모리의 특정 주소에서 데이터를 읽어서 AC에 저장(LOAD addr)*

![data_read_execution](/images/computer_architecture/2/data_read_execution.png){: width="20%" height="20%"}

첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 읽을 메모리 주소)가 MAR로 이동한다.

두 번째 주기에서 해당 주소의 데이터(M\[MAR\])가 데이터 버스를타고 MBR로 이동한다.

세 번째 주기에서는 MBR에 임시로 저장되었던 데이터가 AC로 이동한다.

<br>
*b)데이터 쓰기 예제: AC의 값을 메모리의 특정 주소에 저장(STA addr)*

![data_write_execution](/images/computer_architecture/2/data_write_execution.png){: width="20%" height="20%"}

첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 저장할 메모리 주소)가 MAR로 이동한다.

두 번째 주기에서 AC의 데이터가 MBR로 이동한다.

세 번째 주기에서 해당 메모리 주소(M\[MAR\])와 MBR의 데이터가 각각 주소버스와 데이터버스를 타고 메모리로 전송된 후 데이터가 저장된다.

<br>
*c)데이터 처리 예제: 메모리의 특정 주소에서 데이터를 읽어 AC값과 더해서 AC에 저장(ADD addr)*

![data_process_execution](/images/computer_architecture/2/data_process_execution.png){: width="20%" height="20%"}

첫 번째 주기에서 IR에 저장된 명령어의 오퍼랜드(데이터를 읽을 메모리 주소)가 MAR로 이동한다.(곧바로 주소버스를 타고 메모리로 이동한다.)

두 번째 주기에서 메모리로부터 값이 들어와 MBR에 저장된다.

세 번째 주기에서 AC값과 MBR값이 더해져 AC에 저장된다.

<br>
*d)프로그램 제어 예제: PC가 아닌 다른 주소로의 분기 명령어(JUMP addr)*

![program_control_execution](/images/computer_architecture/2/program_control_execution.png){: width="20%" height="20%"}

이 경우에는 명령어 실행 마이크로 오퍼레이션이 한 주기만에 실행된다.

명령어의 오퍼랜드(분기할 목적지 주소)를 PC로 보내버리면 된다. 그러면 다음 명령어를 메모리의 해당 주소에서 인출할 것이다.

<br>
### 2-3. 인터럽트 사이클 ###
----

**1) 인터럽트란?**

**인터럽트(interrupt)**란 현재 진행중인 명령어 실행 사이클을 즉시 중단하고 다른 동작을 처리하도록 요구하는 매커니즘이다. 순차적인 명령어에 포함되지는 않지만 CPU 외부로부터 요구가 들어오면 실행된다.

인터럽트 발생시 실행해야 하는 동작을 인터럽트 서비스 루틴(ISR - Interrupt Service Routine)이라고 부른다. 인터럽트 서비스 루틴에대한 처리가 끝나면 CPU는 원래 루틴으로 복귀하여 계속 프로그램을 실행한다.

![interrupt](/images/computer_architecture/2/interrupt.png){: width="70%" height="70%"}

사실 명령어 인출 및 실행 단계에서 설명하지 않은 추가 동작이 더 있다. 실행 사이클이 끝난 뒤 새로운 인출 사이클이 시작되기 전에 인터럽트 요구신호가 대기중인지 검사하는 것이다. 만약 인터럽트 비트가 SET 되어있다면 아래의 동작을 수행한다.

<br>
**2) 인터럽트 사이클 실행 순서**

	a) ISR수행이 끝난 뒤 복귀하기 위해서 PC의 값을 스택(stack)에 저장
	b) ISR의 시작 주소를 PC에 로드한다. 이 주소는 인터럽트를 요구한 장치로부터 받거나 미리 계획된 인터럽트일경우 메모리에서 가져온다.

요약하자면 인터럽트 사이클은 아래의 순서대로 실행된다.

__*\[인터럽트 요구신호 검사 → 현재 내용을 스택에 저장 → 인터럽트 시작주소를 PC에 로드\]*__

인터럽트 시작 주소를 PC에 로드하는 것 까지가 인터럽트 사이클이다. ISR의 시작주소가 PC에 적재되었기 때문에 다음 사이클에서는 ISR에 대해 명령어 인출-실행 단계를 거친다. 이를 마이크로연산으로 분리해보면 아래 그림과 같다.

![interrupt_micro_operation](/images/computer_architecture/2/interrupt_micro_operation.png){: width="30%" height="30%"}

첫 번째 주기에서는 현재 PC의 내용이 시스템버스를 타고 MBR을 통해 메모리로 이동한다.

두 번째 주기에서는 스택포인터(SP)가 가르키는 스택의 마지막 주소를 MAR를 통해 메모리로 내보낸다. 동시에 ISR의 시작 주소를 PC에 올린다.

마지막 주기에서는 MBR에 저장되어있던 원래의 PC내용이 데이터버스를 타고 메모리로 이동하면 두 번째 주기에서 메모리가 받았던 스택의 마지막 주소에 이 내용이 저장된다.(이로써 원래의 순차적 프로그램 순서에서 다음에 인출할 명령어 주소가 스택에 저장된 것이다.) 그리고 동시에 스택포인터 SP의 값이 1 감소한다.

결론적으로 PC에 있던 내용이 스택에 저장되고, PC에 ISR의 시작주소가 적재되었기 때문에 다음 사이클에는 ISR이 수행되는 것이다. 그리고 ISR이 끝나면 스택에 저장되어있던 원래 PC의 내용을 가져와 계속 수행하게된다.

스택포인터인 SP는 CPU 내부에 있는 특수목적 레지스터들 중의 하나이다. SP는 항상 스택의 최상위 주소(Top Of Stack - TOS)를 가리킨다. 또한 일반적으로 스택 영역은 메모리의 끝 부분이 사용되므로 스택에 내용이 쌓일수록 SP는 1씩 감소하게 된다.

아래 그림은 인터럽트가 포함된 전체 명령어 사이클을 표현한다.

![instruction_cycle_with_interrupt](/images/computer_architecture/2/instruction_cycle_with_interrupt.png){: width="50%" height="50%"}

인터럽트라고 항상 현재 실행중인 사이클을 중단하고 ISR이 실행되는것은 아니다. CPU 설정값에서 INTERRUPT_ENABLE 비트와 같이 인터럽트 가능 여부를 세트할수 있는 값이 SET되어있어야한다.

<br>
**3) 인터럽트 도중 레지스터 내용의 변경을 방지하는 방법**

인터럽트 사이클 도중에 원래 사이클에서 계산된 값들이 저장된 레지스터의 값이 변경된다면? 예를들어 연산 중간 결과가 AC에 저장되어있었는데 ISR 수행 도중 AC값을 변경한다면 원래의 사이클의 결과가 달라지게 된다. 이를 해결하기 위해 ISR 시작 단계에서는 CPU 레지스터들의 내용을 스택에 저장하였다가 ISR 수행 후 다시 가져오는 절차가 수행된다.

**4) 다중 인터럽트**

ISR 수행도중 다른 외부장치가 인터럽트를 요구하는 경우를 다중 인터럽트(Multiple Interrupt)라고 부른다.

다중 인터럽트를 처리하는 방법에는 2가지가 있다.

**a) interrupt disable 상태로 변경**

ISR 수행 도중에는 interrupt를 disable하여 다른 인터럽트가 끼어들지 못하게 한다. 현재 처리중인 ISR이 끝나고 다시 interrupt enable 상태가 되면 대기중인 인터럽트가 인식된다.

**b) 인터럽트 우선순위 설정**

ISR 수행도중 우선순위가 더 높은 인터럽트 요구가 들어올 경우에는 해당 인터럽트로 새로 분기하고 우선순위가 낮은 인터럽트에 대해서는 대기를 시켜놓는 것이다. 이 내용을 그림으로 표현하면 아래와 같다.

![multiple_interrupt](/images/computer_architecture/2/multiple_interrupt.png){: width="50%" height="50%"}

이 경우 PC와 다른 인터럽트 내용을 저장하고 ISR이 끝난 후 갱신하는 내용은 앞에서 설명한 절차와 동일하다.

<br>
### 2-4. 간접 사이클 ###
----

연산이 필요한 경우(더하기, 빼기같은) 명령어의 오퍼랜드는 데이터가 있는 메모리의 주소를 나타낸다고 했었다. 그런데 데이터의 주소가 아닌 데이터의 주소를 내용으로 가지고있는 메모리의 주소 경우가 있다. 다시말하면 메모리에서 데이터가 저장된 곳의 주소를 받아와 다시 그 주소로 찾아가 데이터를 가져와야한다. 이 경우 데이터의 실제 주소를 가지고 있는 주소를 가져오는 과정을 간접 사이클이라고 하는데, 간접 사이클은 인출 사이클과 실행 사이클 사이에 위치한다. 이 사이클은 간접주소방식(이후 내용에서 설명한다)에서 사용된다.

간접 사이클에서는 IR의 오퍼랜드를 MAR로 내보내고 메모리의 해당 주소에서 데이터가 저장된 곳의 주소를 가져와 MBR에 저장한다. 여기까지는 일반적인 실행 사이클과 같다. 그런데 여기사 MBR의 값을 IR의 오퍼랜드와 바꿔치기하는 과정이 한번 더 일어난다. 이제야 IR에 있는 명령어의 오퍼랜드가 데이터의 실제 주소를 가지게 되어 데이터를 가져올 수 있게된 것이다.

이를 마이크로 연산으로 나타내면 아래 그림과 같다.

![indirect_cycle](/images/computer_architecture/2/indirect_cycle.png){: width="20%" height="20%"}

<br>
<br>
## 3. 명령어 파이프라이닝 ##
====

### 3-1. 2단계 명령어 파이프라인 ###
---

### 3-2. 4단계 명령어 파이프라인 ###
---

### 3-3. 슈퍼스칼라 ###
---

### 3-4. 듀얼코어 및 멀티코어 ###
---

## 4. 명령어 세트 ##

