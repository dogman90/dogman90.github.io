---
title: (컴퓨터구조) 3. 컴퓨터의 산술연산과 논리연산
date: 2020-02-15T19:37:19+09:00
author: nobbaggu
layout: post
categories: 컴퓨터구조
tags:
  - ALU
  - 정수
  - 부동소수점
  - 시프트연산
  - 논리연산
  - 레지스터
  - 보수
  - AND
  - OR
  - XOR
  - NOR
  - NOT
  - CPU
  - 부호비트
---

## 목차 ##
----

1. ALU의 구성요소
2. 정수 표현방식
3. 논리연산
4. 시프트연산
5. 정수 연산
6. 부동소수점 표현방식
7. 부동소수점 연산


<br>
## 0. Intro ##
----

컴퓨터의 출발은 4칙연산 계산기이며 지금도 근본적인 기능은 수치의 산술연산 및 논리 연산이다. 산술연산은 정수와 이외의 실수(부동소수점으로 표현)에 대한 계산이고 논리연산은 2진수로 표현되는 데이터에 대하여(AND, OR, NOT 등) 이루어진다.

이 장에서는 산술 및 논리연산을 수행하는 CPU의 핵심 부품인 산술논리연산장치(ALU - Arithmetic and Logical Unit)의 내부 구성과 연산 방법에 대한 내용이다.

<br>
## 1. ALU의 구성요소 ##
----

ALU는 CPU를 구성하는 모듈들 중 하나로 수치 및 논리 데이터에 대한 연산을 수행하는 하드웨어이다. ALU의 내부 구성요소들은 아래와 같다.

**1) 산술연산장치**

4칙연산 수행

**2) 논리연산장치**

논리연산(AND, OR, NOT, NOR, XOR 등)을 수행

**3) 시프트 레지스터(shift register)**

비트를 좌,우로 이동

**4) 보수기(complementer)**

2의 보수 출력

**5) 상태 레지스터(status register)**

연산 결과의 상태를 나타내는 플래그(flag)들을 저장

![alu_modules](/images/computer_architecture/3/alu_modules.png){: width="50%" height="50%"}

ALU는 CPU의 제어유닛으로부터 오는 제어신호를 받아 계산에 필요한 모듈을 선택하여 연산을 수행하고 결과의 상태들을 상태 레지스터에 저장한다. 상태 레지스터의 플래그들은 조건 분기 등의 이후 프로그램 실행에 사용된다.

<br>
## 2. 정수 표현방식 ##
----

컴퓨터는 2진수(binary number) 시스템을 사용하므로 모든것을 0과 1로 표현할 수 밖에 없다.

만약 음수가 없고 양수만 존재한다면 표현 방법은 수학시간에 배운 일반적인 2진수 표현 방법만큼 간단하다. 예를들어 8bit를 사용해 10진수 60을 나타낸다면 00111100처럼 쓸 수 있다. 혹은 255를 나타낸다면 11111111이 된다.

그러나 컴퓨터는 음수도 표현해야 하므로 부호 비트(sign bit)를 사용한다. 부호비트를 사용하는 2진수 표현에는  3가지 방법이 있다.

**a) 부호화-크기 표현**

최상위 비트(MSB - Most Significant Bit)가 0이면 양수, 1이면 음수이다. MSB를 제외한 하위 비트들은 수의 크기를 나타낸다.

ex1) 8bit를 이용한 +10 표현 -> 00001010
ex2) 8bit를 이용한 -10 표현 -> 10001010

이 방법의 단점 중 첫번째는 두 개 이상의 정수사이 연산과정에서 부호를 별도로 처리해야한다는 점이다. 두 번째는 0을 표현하는 경우가 2가지가 된다는 점이다. 이 경우 데이터가 '0'인지 검사하는 과정이 더 복잡해진다.

부호화-크기 표현에서 n비트가 표현할 수 있는 수들의 갯수는 (2^n-1) 개이다.

**b) 보수 표현**

보수(complementary number)의 어원적 의미는 상호보완하는 수이다. 보수에는 2가지 종류가 있다. n진법에는 (n-1)의 보수와 n의 보수가 존재한다. 따라서 10진법에서는 9의보수와 10의보수가 사용된다.

274의 9의 보수는 (999-274) = 725이며, 10의 보수는 (1000-274) = 726이다.

마찬가지로 2진법에서는 1의보수와 2의보수가 존재한다. 100101의 1의 보수는 모든 비트를 반전시켜 011010이 되며, 2의 보수는 1의 보수에 1을 더한 011011이 된다.

정리하면 아래와 같다.

**1) 1의 보수** : 모든 비트를 반전시킨다.(0 -> 1, 1 -> 0)

**2) 2의 보수** : 모든 비트를 반전시키고(1의 보수를 취하고) 1을 더한다.

일반적으로 거의 모든 컴퓨터의 숫자 체계는 2의 보수표현을 사용한다. 이유는 2의 보수 표현이 1의 보수 표현보다 표현할 수 있는 수의 가짓수가 1개 더 많기 때문이다. 1의 보수 표현에서는 부호화-크기 표현과 마찬가지로 0에 대한 표현이 2가지 존재한다.

아래 표는 8비트를 사용하여 표현할 수 있는 수의 범위를 1의 보수 표현과 2의 보수 표현으로 나타낸 것이다.

![complement_representation](/images/computer_architecture/3/complement_representation.png){: width="50%" height="50%"}

결론적으로 컴퓨터의 정수 체계를 이해한다는 것은 2의 보수 표현을 이해한다는 것이다.

**a) 10진수 -> 2진수 변환**

양수 : 일반적인 2진수 계산

음수 : 매칭되는 양수의 2진수를 계산 후 2의 보수로 변환(비트 반전 -> 1 더하기)

ex) -100을 8bit의 2진수로 변환 : 100은 2진수로 01100100이고 이를 비트 반전시키면 10011011이며, 1을 더하면 최종적으로 10011100이 된다.

**b) 2진수 -> 10진수 변환**

양수 : 일반적인 2진수 계산

음수 : MSB가 1일 것이므로 n비트의 경우 -2^(n-1)에다가 나머지 비트들을 10진수로 변환 후 더하기

ex) 10011100 = -2^7 + 2^4 + 2^3 + 2^2 = -128 + 16 + 8 + 4 = -100

<br>
## 3. 논리 연산 ##
----

논리 연산은 비트 단위로 의미를 가지며, 연산도 비트 단위로 처리된다. 1비트 사이의 기본적인 논리 연산이 아래 표와같이 정리되었다.

![logical_operation](/images/computer_architecture/3/logical_operation.png){: width="50%" height="50%"}

참고로 XOR 연산은 exclusive-OR 이라는 의미로서 두 비트가 서로 다른 경우에는 결과가 1, 같은 경우에는 0이 된다.

위의 논리 연산을 위한 실제 하드웨어는 아래 그림과 같이 설계될 수 있다.

![logical_operation_unit](/images/computer_architecture/3/logical_operation_unit.png){: width="50%" height="50%"}

입력비트 A와 B는 모든 게이트들을 통과하지만 두 개의 선택 신호(Selection Bit)에 의해 어떤 게이트의 결과가 출력되어 F로 나갈지 선택된다.

위의 논리연산 모듈을 n개 이어붙이면 n-bit 데이터 사이의 논리연산도 가능해진다. 아래 그림은 4bit 데이터 사이의 논리 연산을 위한 장치이다.

![logical_operation_module](/images/computer_architecture/3/logical_operation_module.png){: width="50%" height="50%"}

데이터의 처리는 CPU의 워드(word) 단위로 처리되므로 실제 CPU 하드웨어에는 논리연산 유닛을 n개 이어붙인 형태가 될 것이다.


<br>
## 4. 시프트 연산 ##
----

**1) 논리적 시프트 연산**

데이터 내의 모든 비트를 왼쪽, 혹은 오른쪽으로 한 칸씩 이동시키는 연산이다. 예를들어 좌측 시프트(shift left) 연산을 수행하면 모든 비트가 왼쪽으로 한칸씩 이동한다. 이 때 최상위 비트(MSB - Most Significant Bit)는 날아가고 최하위 비트(LSB - Least Significant Bit)에는 0이 채워진다.

![logical_shift](/images/computer_architecture/3/logical_shift.png){: width="50%" height="50%"}

가령 11001011을 좌측 시프트연산 시키면 10010110이 된다. 우측 시프트연산 시키면 01100101이 된다.

아래는 시프트 레지스터의 내부 구성도이다.

![logical_shift_unit](/images/computer_architecture/3/logical_shift_unit.png){: width="50%" height="50%"}

위 그림에서 좌측 시프트 신호(L)를 1로 SET하면 오른쪽 플립플롭의 출력(Q)과 AND연산이 되어서 왼쪽 플립플롭의 입력(D)로 들어가게 된다. 이 때 가장 오른쪽의 AND게이트의 입력으로는 0이 들어와 가장 오른쪽 플립플롭에는 0이 채워진다다.

우측 시프트 신호(R)를 1로 SET하면 왼쪽 플립플롭의 출력(Q)과 AND연산되어 오른쪽 플립플롭의 입력(D)로 들어가게 된다. 이 때 가장 왼쪽의 AND게이트 입력으로 0이 들어와 가장 왼쪽 플립플롭에는 0이 채워진다.

<br>
**2) 순환 시프트 연산**

순환 시프트(circular shift) 연산은 논리적 시프트 연산과 같지만 MSB나 LSB를 버리지 않고 반대편 끝에있는 비트 위치로 이동시키는 것이다. 아래 그림은 순환 좌측 시프트 연산을 보여준다.

![circular_shift_left](/images/computer_architecture/3/circular_shift_left.png){: width="50%" height="50%"}

위 그림에서는 MSB가 버려지는 대신 0으로 채워질 LSB 위치로 이동하는 것이다.

결론적으로 논리적 시프트 연산과 다르게 비트가 버려지거나 0으로 채워지는 대신 버려질 비트를 0으로 채워질 비트 자리에 채우는 것이다.

<br>
**3) 산술적 시프트 연산**

부호비트를 고려하여 수행되는 논리적 시프트 연산이다. 부호 비트는 변하지 않는다는 특징이 있다.

	a) 산술적 좌측 시프트 연산 : MSB는 변하지 않고 나머지 비트들에 대해 논리적 좌측 시프트가 수행된다. LSB는 0으로 채워진다.
	
	b) 산술적 우측 시프트 연산 : MSB는 변하지 않고 나머지 비트들에 대해 논리적 우측 시프트가 수행된다. MSB의 바로 오른쪽 비트는 MSB와 같은 비트로 채워진다.

<br>
산술적 시프트 연산의 설명을 종합해보면 양수이건 음수이건 상관없이 좌측 시프트 연산은 원래 데이터에 2를 곱하는 결과를, 우측 시프트 연산은 원래 데이터를 2로 나눈 결과가 된다는 점이다.

<br>
## 5. 정수 연산 ##
----

**1) 덧셈**

두 수를 더하면 된다. 여기서 올림수(carry)가 발생하여 새로운 자리의 비트가 생성되면 버리면 된다.

ex1) -4 + 5
 1100
+0101
10001 -> carry 날리면 0001 = 1
 
ex2) -100+45
 10011100
+00101101
 11001001 = -55
 
이처럼 덧셈을 수행하는 하드웨어 유닛을 병렬 가산기(parallel adder)라고 부른다. 가산기에는 반가산기(half adder)와 전가산기(full adder)가 있다. 병렬 가산기는 전가산기를 병렬로 연결한 모듈이다. n개의 전가산기를 병렬로 연결한 병렬 가산기는 n자리 이진수 사이의 덧셈을 수행할 수 있다.

![parallel_adder](/images/computer_architecture/3/parallel_adder.png){: width="50%" height="50%"}

병렬 가산기에서 올림수 비트(carry bit)는 상위 전가산기로 전송된다.

2진 데이터 (A4A3A2A1)과 (B4B3B2B1)을 더하여 나온 결과는 S4S3S2S1으로 출력된다.

덧셈의 결과와 관련된 정보를 저장해주는 상태 레지스터에는 아래와같은 플래그들이 포함되어 있다.

S : 부호 플래그. 최상위 비트(MSB)를 저장한다. 따라서 양수면 0, 음수면 1이 된다. 즉, 덧셈 결과가 음수면 SET이 된다.

C : 올림수 플래그. 최상위 단계의 전가산기에서 올림수가 발생하면 SET된다.

Z : 제로(Zero) 플래그. 덧셈결과 각각의 비트가 NOR 게이트를 통과한다. 모든 비트가 0인 경우에만 1이 되므로 덧셈결과가 0이면 Z플래그가 SET이 된다.

V : 오버플로(overflow) 플래그. 가장 최상위 두 단계의 전가산기의 올림수(위 그림에서는 C4와 C3)가 다르다는 것은 두 수의 덧셈 결과가 비트의 표현 범위를 초과하게 되었다는 것이다. C4와 C3의 값이 XOR 게이트를 통과하므로 두 값이 다르면 V값이 SET된다.

ex) 오버플로 예제

4bit로 표현되는 두 수 8과 9를 덧셈해보자.

 1000
+1001
10001 -> 올림수 버리면 0001 = 1

2의 보수 표현법에서 4비트가 표현 가능한 범위는 -8 ~ +7 이다. 

<br>
**2) 뺄셈**

뺄셈을 위한 회로는 따로 없다. 예를들어 A에서 B를 빼야하는 경우(A-B)에는 B를 2의 보수화 시켜서 더하면 된다. 논리적으로는 A-B = A+(-B)이다. 물론 덧셈과 마찬가지로 최상위비트에서 발생하는 올림수는 버린다.

<br>
**3) 곱셈**

**a) 부호 없는 정수의 곱셈**

곱셈은 컴퓨터 입장에서 꽤 복잡한 연산이다. 2의 보수로 표현되는 정수의 곱셈을 보기 전 부호 없는 정수간의 곱셈부터 살펴본다.

![unsigned_integer_multiply](/images/computer_architecture/3/unsigned_integer_multiply.png){: width="50%" height="50%"}

승수의 각 비트들에 대해 차례대로 곱셈이 수행되고 피승수에 더해진다. 더해진 부분적들은 오른쪽으로 shift하여 새로 나온 부분적과 자릿수를 맞춘다.

컴퓨터에서는 위 계산을 병렬 가산기를 사용하여 수행한다. 승수 비트가 1이면 피승수를 현재까지의 누적 부분적에 더하고, 0이면 더하지 않으면 된다. 왜냐하면 2진수에서는 모든 비트가 0 혹은 1이기 때문이다. 이 과정을 수행하는 하드웨어 구성도는 아래 그림과 같다.

![unsigned_integer_multiply_hardware](/images/computer_architecture/3/unsigned_integer_multiply_hardware.png){: width="50%" height="50%"}

레지스터 C와 A, 그리고 Q는 논리적으로 하나의 레지스터로 본다. 계산이 수행될때마다 오른쪽으로 1번씩 shift 연산을 하고 최종적으로 C-A-Q에 저장된 비트들이 곱셈 결과이다.

초기에는 C와 A는 0으로 채워진다. 그리고 Q에는 승수로 초기화되어있다. 또한 M에 피승수가 저장되어있다.

매번 연산이 수행될 때 Q의 최하위비트 Q0비트가 1이면 M레지스터의 피승수와 A레지스터의 중간결과가 더해지고, 0이면 더해지지 않는다. 만약 올림수가 발생하면 레지스터 C에 저장된다. 이후에 C-A-Q에서 오른쪽으로 shift연산이 이루어진다. Q레지스터의 최하위비트는 곱셈에 사용되었으므로 버려진다.

위 예제의 계산이 진행됨에따라 위 그림 하드웨어의 레지스터들 값의 상태변화는 아래 실행도와 같다.

![unsigned_integer_multiply_flow](/images/computer_architecture/3/unsigned_integer_multiply_flow.png){: width="50%" height="50%"}

<br>
**b) 2의 보수의 곱셈**

2의 보수의 곱셈을 위해서는 부호 없는 정수의 곱셈을 위한 하드웨어에 추가적인 모듈이 필요하다.

- 피승수를 저장하는 레지스터 M과 병렬 가산기 사이에 보수기(complementer)가 추가된다.
- Q레지스터의 오른쪽에 1비트짜리 Q-1 레지스터가 추가된다. Q0 레지스터와 함께 Q-1 레지스터의 값이 제어회로에 입력된다.

<br>

2의 보수 곱셈을 컴퓨터를 통해 하는 과정은 상당히 난해하다. 가장 널리 쓰이는 알고리즘이 Booth 알고리즘인데, 알고리즘의 흐름도는 아래와 같다.

![booth_algorithm_flowchart](/images/computer_architecture/3/booth_algorithm_flowchart.png){: width="50%" height="50%"}

<br>
**4) 나눗셈**

나눗셈에서도 곱셈과 마찬가지로 반복적인 뺄셈과 시프트 연산으로 수행된다. 

![unsigned_integer_divide](/images/computer_architecture/3/unsigned_integer_divide.png){: width="50%" height="50%"}

위 그림은 부호없는 나눗셈 과정이다. 일반적인 나눗셈 과정을 생각해보면 피제수의 비트를 하나씩 내리면서 제수보다 커질 경우 제수를 빼고 부분 나머지를 획득한다. 여기에 피제수의 남은 비트들을 하나씩 이어붙이면서 제수보다 커지면 제수를 빼고 부분 나머지를 획득한다. 이 과정의 반복이다. 다만 곱셈 연산과 다른 점은 시프트연산이 좌측으로 일어난다는 점이다. 이것은 나눗셈의 계산과정과 관련있다. 피제수에서 상위 비트부터 아래로 내려가면서 제수를 빼줄수 있는지 탐색하기 때문이다.

위 알고리즘의 흐름도는 아래 그림과 같다.

![unsigned_integer_divide_flowchart](/images/computer_architecture/3/unsigned_integer_divide_flowchart.png){: width="50%" height="50%"}

부분 나머지는 레지스터 A에 저장된다. 또한 몫은 레지스터 Q의 최하위비트(Q0)에 한 사이클당 하나씩 채워진다. 그리고 시프트 연산이 수행되는 과정들이 반복되면 최후에 레지스터 Q에는 몫이, A에는 최종 나머지가 저장되어있다.

특이하게도 피제수를 뺄 수 있는지 체크를 하지않고 부분나머지 A에서 제수 M을 일단 뺀다. 이후 빼는 행위가 정당했다면 A는 0보다 크거나 같을 것이다. 0보다 작다면 몫에 Q0에 0을 넣고 A에 M을 다시 더한다.

2의 보수의 나눗셈은 위의 알고리즘을 약간 고치면 된다.

<br>

지금까지 정수의 4칙연산에 대해 다루었다. 덧셈과 뺄셈은 병렬 가산기에 의해 수행된다. 곱셈과 나눗셈은 알고리즘이 상당히 복잡하다. 그러나 핵심 포인트는 병렬 가산기와 시프트연산의 반복 수행이란 점이다. 실제 곱셈이나 나눗셈 연산을 한 비트씩 진행하면서 중간 결과들을 레지스터에 저장하는 동작이 반복적으로 일어난다는 점이 중요하다. 그 결과로 컴퓨터 입장에서 덧셈과 나눗셈보다는 곱셈, 나눗셈의 연산에 더 많은 자원이 소모된다는 점이 중요하다.

<br>
## 6. 부동소수점 표현방식 ##
----



<br>
## 7. 부동소수점 연산 ##
----